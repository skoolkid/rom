@start
@writer=:rom.ROMAsmWriter
@expand=#DEFINE2,1(LOGO,#UDGARRAY(12,#EVAL(56+7*{0}-48*{1}),3,12,tindex=2,alpha=#IF({1})(0,255));$8000-$800B({{ImagePath}}/{2}|Spectrum ROM))
@expand=#DEFINE0(BUG,#LINK:Bugs)
@expand=#DEFINE1(CHAR,#UDG{0}(char#EVAL(({0}-$3C00)/8,16)))
@replace=/#pi/#CHR(960)
@replace=/#power/#CHR(8593)
@replace=/#i([xy][+-])(\$..)/#REGi\1#N(\2,,,1,1)($)
@replace=/#o([0-9A-F]{2,4})/#N($\1,,,1,1)($)
@replace=/&([0-9A-F]{2,4})/#IF({base}==10)(#EVAL($\1),+#S|\1|)
@replace=/#h([0-9A-F]{2,4})/#N($\1,,,,1)
@set-handle-unsupported-macros=1
@defb=$800C:$3C,$00,$00,$00,$10,$00,$00,$00,$00,$7C,$3C,$42 ; Logo
@defb=$8018:$40,$78,$38,$1C,$38,$1C,$44,$68,$00,$42,$42,$66 ;
@defb=$8024:$3C,$44,$44,$20,$10,$20,$44,$54,$00,$42,$42,$5A ;
@defb=$8030:$02,$44,$78,$20,$10,$20,$44,$54,$00,$7C,$42,$42 ;
@defb=$803C:$42,$78,$40,$20,$10,$20,$44,$54,$00,$44,$42,$42 ;
@defb=$8048:$3C,$40,$3C,$1C,$0C,$20,$38,$54,$00,$42,$3C,$42 ;
@defb=$8055:$40                                             ;

; 48K Spectrum ROM disassembly
;
; Annotations taken from 'The Complete Spectrum ROM Disassembly' by Dr Ian
; Logan and Dr Frank O'Hara, published by Melbourne House.
;
; Copyright 1982 Amstrad
; Copyright 1983 Dr Ian Logan & Dr Frank O'Hara
; Copyright 2013-2020 Richard Dymond
@bfix+begin
;
; This disassembly contains fixes for the following bugs:
;   * No step back
;   * A step back too far
;   * Anything equals SCREEN$ (x,y)
;   * The 34th bit of division
; See https://skoolkit.ca/disassemblies/rom/reference/bugs.html for full
; descriptions of these bugs.
@bfix+end

@equ=KSTATE=$5C00
@equ=LAST_K=$5C08
@equ=REPDEL=$5C09
@equ=REPPER=$5C0A
@equ=DEFADD=$5C0B
@equ=K_DATA=$5C0D
@equ=TVDATA=$5C0E
@equ=STRMS=$5C10
@equ=CHARS=$5C36
@equ=RASP=$5C38
@equ=PIP=$5C39
@equ=ERR_NR=$5C3A
@equ=FLAGS=$5C3B
@equ=TV_FLAG=$5C3C
@equ=ERR_SP=$5C3D
@equ=LIST_SP=$5C3F
@equ=MODE=$5C41
@equ=NEWPPC=$5C42
@equ=NSPPC=$5C44
@equ=PPC=$5C45
@equ=SUBPPC=$5C47
@equ=BORDCR=$5C48
@equ=E_PPC=$5C49
@equ=VARS=$5C4B
@equ=DEST=$5C4D
@equ=CHANS=$5C4F
@equ=CURCHL=$5C51
@equ=PROG=$5C53
@equ=NXTLIN=$5C55
@equ=DATADD=$5C57
@equ=E_LINE=$5C59
@equ=K_CUR=$5C5B
@equ=CH_ADD=$5C5D
@equ=X_PTR=$5C5F
@equ=WORKSP=$5C61
@equ=STKBOT=$5C63
@equ=STKEND=$5C65
@equ=BREG=$5C67
@equ=MEM=$5C68
@equ=FLAGS2=$5C6A
@equ=DF_SZ=$5C6B
@equ=S_TOP=$5C6C
@equ=OLDPPC=$5C6E
@equ=OSPCC=$5C70
@equ=FLAGX=$5C71
@equ=STRLEN=$5C72
@equ=T_ADDR=$5C74
@equ=SEED=$5C76
@equ=FRAMES=$5C78
@equ=UDG=$5C7B
@equ=COORDS=$5C7D
@equ=P_POSN=$5C7F
@equ=PR_CC=$5C80
@equ=ECHO_E=$5C82
@equ=DF_CC=$5C84
@equ=DF_CCL=$5C86
@equ=S_POSN=$5C88
@equ=S_POSNL=$5C8A
@equ=SCR_CT=$5C8C
@equ=ATTR_P=$5C8D
@equ=MASK_P=$5C8E
@equ=ATTR_T=$5C8F
@equ=MASK_T=$5C90
@equ=P_FLAG=$5C91
@equ=MEMBOT=$5C92
@equ=NMIADD=$5CB0
@equ=RAMTOP=$5CB2
@equ=P_RAMT=$5CB4
@equ=CHINFO=$5CB6
@org=$0000
; THE 'START'
;
; It all starts here when the Spectrum is powered on.
; .
; The maskable interrupt is disabled and the #REGde register pair set to hold
; the 'top of possible RAM'.
@label=START
c$0000 DI            ; Disable the 'keyboard interrupt'.
 $0001 XOR A         ; &00 for start (but &FF for 'NEW').
 $0002 LD DE,$FFFF   ; Top of possible RAM.
 $0005 JP $11CB      ; Jump forward.

; THE 'ERROR' RESTART
;
; Used by the routines at #R$03F8, #R$053F, #R$0605, #R$0802, #R$0C55, #R$0EF4,
; #R$15C4, #R$15D4, #R$1601, #R$171E, #R$175D, #R$1B76, #R$1B9E, #R$1BD1,
; #R$1C22, #R$1C79, #R$1CEE, #R$1D03, #R$1DAB, #R$1DEC, #R$1E94, #R$1EAC,
; #R$1F23, #R$21B9, #R$21E1, #R$24B7, #R$27BD, #R$2996, #R$30CA, #R$34BC,
; #R$35C9, #R$36C4 and #R$3713.
; .
; The error pointer is made to point to the position of the error.
@label=ERROR_1
c$0008 LD HL,($5C5D) ; {The address reached by the interpreter
 $000B LD ($5C5F),HL ; (#SYSVAR(CH-ADD)) is copied to the error pointer
 $000E JR $0053      ; (#SYSVAR(X-PTR)) before proceeding.}

; THE 'PRINT A CHARACTER' RESTART
;
; Used by the routines at #R$0605, #R$0C3B, #R$12A2, #R$17F9, #R$1855, #R$1925,
; #R$1FF5, #R$1FFC, #R$204E, #R$21E1 and #R$2DE3.
;
; A Code of the character to be printed
@label=PRINT_A_1
c$0010 JP $15F2      ; Jump forward immediately.

; Unused
s$0013 DEFS $05,$FF  ; Unused locations.

; THE 'COLLECT CHARACTER' RESTART
;
; Used by the routines at #R$0605, #R$12A2, #R$17F9, #R$1B28, #R$1B6F, #R$1BF4,
; #R$1CBE, #R$1DEC, #R$1FDF, #R$1FFC, #R$204E, #R$2089, #R$21B9, #R$21E1,
; #R$2320, #R$2382, #R$24FB, #R$2522, #R$25B3, #R$268D, #R$26C9, #R$27BD,
; #R$28B2, #R$2996, #R$2A52, #R$2C02, #R$2C9B and #R$35DE.
; .
; The contents of the location currently addressed by #SYSVAR(CH-ADD) are
; fetched. A return is made if the value represents a printable character,
; otherwise #SYSVAR(CH-ADD) is incremented and the tests repeated.
;
; O:A Code of the character
@label=GET_CHAR
c$0018 LD HL,($5C5D) ; {Fetch the value that is addressed by #SYSVAR(CH-ADD).
 $001B LD A,(HL)     ; }
; This entry point is used by the routine at #R$0020.
@label=TEST_CHAR
*$001C CALL $007D    ; Find out if the character is printable.
 $001F RET NC        ; Return if it is so.
; This routine continues into #R$0020.

; THE 'COLLECT NEXT CHARACTER' RESTART
;
; Used by the routines at #R$0605, #R$17F9, #R$198B, #R$19FB, #R$1B28, #R$1B6F,
; #R$1C79, #R$1D03, #R$1DEC, #R$1E27, #R$1F60, #R$1FFC, #R$204E, #R$2070,
; #R$2089, #R$21E1, #R$2320, #R$2382, #R$2522, #R$25AF, #R$25E8, #R$2627,
; #R$2634, #R$2668, #R$2672, #R$267B, #R$26C9, #R$27BD, #R$28B2, #R$2996,
; #R$2A52, #R$2C02 and #R$2C9B.
; .
; The routine at #R$0018 continues here.
; .
; As a BASIC line is interpreted, this routine is called repeatedly to step
; along the line.
;
; O:A Code of the next character
@label=NEXT_CHAR
c$0020 CALL $0074    ; #SYSVAR(CH-ADD) needs to be incremented.
 $0023 JR $001C      ; Jump back to test the new value.

; Unused
s$0025 DEFS $03,$FF  ; Unused locations.

; THE 'CALCULATOR' RESTART
;
; Used by the routines at #R$03F8, #R$1736, #R$1CDE, #R$1CF0, #R$1D03, #R$1DAB,
; #R$1DDA, #R$2320, #R$2382, #R$247D, #R$25F8, #R$2627, #R$26C9, #R$2AFF,
; #R$2C9B, #R$2D2B, #R$2D3B, #R$2D4F, #R$2DA2, #R$2DC1, #R$2DE3, #R$353B,
; #R$36A0, #R$36AF, #R$36C4, #R$3713, #R$3783, #R$37AA, #R$37B5, #R$37DA,
; #R$37E2, #R$3833, #R$3843, #R$384A and #R$3851.
; .
; The floating point calculator is entered at #R$335B.
@label=FP_CALC
c$0028 JP $335B      ; Jump forward immediately.

; Unused
s$002B DEFS $05,$FF  ; Unused locations.

; THE 'MAKE BC SPACES' RESTART
;
; Used by the routines at #R$0605, #R$08B6, #R$2089, #R$2535, #R$25B3, #R$2634,
; #R$2AFF, #R$359C, #R$35C9, #R$35DE, #R$361F and #R$3645.
; .
; This routine creates free locations in the work space.
;
;   BC Number of free locations to create
; O:DE Address of the first byte of new free space
; O:HL Address of the last byte of new free space
@label=BC_SPACES
c$0030 PUSH BC       ; Save the 'number'.
 $0031 LD HL,($5C61) ; {Fetch the present address of the start of the work
 $0034 PUSH HL       ; space (#SYSVAR(WORKSP)) and save that also before
 $0035 JP $169E      ; proceeding.}

; THE 'MASKABLE INTERRUPT' ROUTINE
;
; The real time clock is incremented and the keyboard scanned whenever a
; maskable interrupt occurs.
@label=MASK_INT
c$0038 PUSH AF       ; {Save the current values held in these registers.
 $0039 PUSH HL       ; }
 $003A LD HL,($5C78) ; {The lower two bytes of the frame counter
 $003D INC HL        ; (#SYSVAR(FRAMES)) are incremented every 20 ms. (U.K.)
 $003E LD ($5C78),HL ; The highest byte of the frame counter is only
 $0041 LD A,H        ; incremented when the value of the lower two bytes is
 $0042 OR L          ; zero.
 $0043 JR NZ,$0048   ;
 $0045 INC (IY+$40)  ; }
@label=KEY_INT
*$0048 PUSH BC       ; {Save the current values held in these registers.
 $0049 PUSH DE       ; }
 $004A CALL $02BF    ; Now scan the keyboard.
 $004D POP DE        ; {Restore the values.
 $004E POP BC        ;
 $004F POP HL        ;
 $0050 POP AF        ; }
 $0051 EI            ; {The maskable interrupt is enabled before returning.
 $0052 RET           ; }

; THE 'ERROR-2' ROUTINE
;
; Used by the routine at #R$0008.
; .
; The return address to the interpreter points to the 'DEFB' that signifies
; which error has occurred. This 'DEFB' is fetched and transferred to
; #SYSVAR(ERR-NR).
; .
; The machine stack is cleared before jumping forward to clear the calculator
; stack.
@label=ERROR_2
c$0053 POP HL        ; {The address on the stack points to the error code.
 $0054 LD L,(HL)     ; }
; This entry point is used by the routine at #R$1F05.
@label=ERROR_3
*$0055 LD (IY+$00),L ; It is transferred to #SYSVAR(ERR-NR).
 $0058 LD SP,($5C3D) ; {The machine stack is cleared by setting the stack
 $005C JP $16C5      ; pointer to #SYSVAR(ERR-SP) before exiting via #R$16C5.}

; Unused
s$005F DEFS $07,$FF  ; Unused locations.

; THE 'NON-MASKABLE INTERRUPT' ROUTINE
;
; This routine is not used in the standard Spectrum but the code allows for a
; system reset to occur following activation of the NMI line. The system
; variable at 5CB0, named here #SYSVAR(NMIADD), has to have the value zero for
; the reset to occur.
@label=RESET
u$0066 PUSH AF       ; {Save the current values held in these registers.
 $0067 PUSH HL       ; }
 $0068 LD HL,($5CB0) ; {The two bytes of #SYSVAR(NMIADD) must both be zero for
 $006B LD A,H        ; the reset to occur.
 $006C OR L          ; }
 $006D JR NZ,$0070   ; Note: this should have been '#S/JR Z/'!
 $006F JP (HL)       ; Jump to #R$0000.
@label=NO_RESET
*$0070 POP HL        ; {Restore the current values to these registers and
 $0071 POP AF        ; return.
 $0072 RETN          ; }

; THE 'CH-ADD+1' SUBROUTINE
;
; Used by the routines at #R$0020, #R$250F and #R$2D3B.
; .
; The address held in #SYSVAR(CH-ADD) is fetched, incremented and restored. The
; contents of the location now addressed by #SYSVAR(CH-ADD) are fetched. The
; entry points of #R$0077 and #R$0078 are used to set #SYSVAR(CH-ADD) for a
; temporary period.
;
; O:A Code of the character at #SYSVAR(CH-ADD)+1
@label=CH_ADD_1
c$0074 LD HL,($5C5D) ; Fetch the address from #SYSVAR(CH-ADD).
; This entry point is used by the routines at #R$1DEC and #R$268D.
@label=TEMP_PTR1
*$0077 INC HL        ; Increment the pointer.
; This entry point is used by the routine at #R$1DEC.
@label=TEMP_PTR2
*$0078 LD ($5C5D),HL ; Set #SYSVAR(CH-ADD).
 $007B LD A,(HL)     ; {Fetch the addressed value and then return.
 $007C RET           ; }

; THE 'SKIP-OVER' SUBROUTINE
;
; Used by the routine at #R$0018.
; .
; The value brought to the subroutine in the #REGa register is tested to see if
; it is printable. Various special codes lead to #REGhl being incremented once
; or twice, and #SYSVAR(CH-ADD) amended accordingly.
;
; A Character code
@label=SKIP_OVER
c$007D CP $21        ; {Return with the carry flag reset if ordinary character
 $007F RET NC        ; code.}
 $0080 CP $0D        ; {Return if the end of the line has been reached.
 $0082 RET Z         ; }
 $0083 CP $10        ; {Return with codes &00 to &0F but with carry set.
 $0085 RET C         ; }
 $0086 CP $18        ; {Return with codes &18 to &20 again with carry set.
 $0088 CCF           ;
 $0089 RET C         ; }
 $008A INC HL        ; Skip over once.
 $008B CP $16        ; {Jump forward with codes &10 to &15 (INK to OVER).
 $008D JR C,$0090    ; }
 $008F INC HL        ; Skip over once more (AT and TAB).
@label=SKIPS
*$0090 SCF           ; {Return with the carry flag set and #SYSVAR(CH-ADD)
 $0091 LD ($5C5D),HL ; holding the appropriate address.
 $0094 RET           ; }

; THE TOKEN TABLE
;
; Used by the routine at #R$0C0A.
; .
; All the tokens used by the Spectrum are expanded by reference to this table.
; The last code of each token is 'inverted' by having its bit 7 set.
@label=TOKENS
t$0095 DEFM "?"+$80            ; ?
 $0096 DEFM "RN","D"+$80       ; RND
 $0099 DEFM "INKEY","$"+$80    ; INKEY$
 $009F DEFM "P","I"+$80        ; PI
 $00A1 DEFM "F","N"+$80        ; FN
 $00A3 DEFM "POIN","T"+$80     ; POINT
 $00A8 DEFM "SCREEN","$"+$80   ; SCREEN$
 $00AF DEFM "ATT","R"+$80      ; ATTR
 $00B3 DEFM "A","T"+$80        ; AT
 $00B5 DEFM "TA","B"+$80       ; TAB
 $00B8 DEFM "VAL","$"+$80      ; VAL$
 $00BC DEFM "COD","E"+$80      ; CODE
 $00C0 DEFM "VA","L"+$80       ; VAL
 $00C3 DEFM "LE","N"+$80       ; LEN
 $00C6 DEFM "SI","N"+$80       ; SIN
 $00C9 DEFM "CO","S"+$80       ; COS
 $00CC DEFM "TA","N"+$80       ; TAN
 $00CF DEFM "AS","N"+$80       ; ASN
 $00D2 DEFM "AC","S"+$80       ; ACS
 $00D5 DEFM "AT","N"+$80       ; ATN
 $00D8 DEFM "L","N"+$80        ; LN
 $00DA DEFM "EX","P"+$80       ; EXP
 $00DD DEFM "IN","T"+$80       ; INT
 $00E0 DEFM "SQ","R"+$80       ; SQR
 $00E3 DEFM "SG","N"+$80       ; SGN
 $00E6 DEFM "AB","S"+$80       ; ABS
 $00E9 DEFM "PEE","K"+$80      ; PEEK
 $00ED DEFM "I","N"+$80        ; IN
 $00EF DEFM "US","R"+$80       ; USR
 $00F2 DEFM "STR","$"+$80      ; STR$
 $00F6 DEFM "CHR","$"+$80      ; CHR$
 $00FA DEFM "NO","T"+$80       ; NOT
 $00FD DEFM "BI","N"+$80       ; BIN
 $0100 DEFM "O","R"+$80        ; OR
 $0102 DEFM "AN","D"+$80       ; AND
 $0105 DEFM "<","="+$80        ; <=
 $0107 DEFM ">","="+$80        ; >=
 $0109 DEFM "<",">"+$80        ; <>
 $010B DEFM "LIN","E"+$80      ; LINE
 $010F DEFM "THE","N"+$80      ; THEN
 $0113 DEFM "T","O"+$80        ; TO
 $0115 DEFM "STE","P"+$80      ; STEP
 $0119 DEFM "DEF F","N"+$80    ; DEF FN
 $011F DEFM "CA","T"+$80       ; CAT
 $0122 DEFM "FORMA","T"+$80    ; FORMAT
 $0128 DEFM "MOV","E"+$80      ; MOVE
 $012C DEFM "ERAS","E"+$80     ; ERASE
 $0131 DEFM "OPEN ","#"+$80    ; OPEN #
 $0137 DEFM "CLOSE ","#"+$80   ; CLOSE #
 $013E DEFM "MERG","E"+$80     ; MERGE
 $0143 DEFM "VERIF","Y"+$80    ; VERIFY
 $0149 DEFM "BEE","P"+$80      ; BEEP
 $014D DEFM "CIRCL","E"+$80    ; CIRCLE
 $0153 DEFM "IN","K"+$80       ; INK
 $0156 DEFM "PAPE","R"+$80     ; PAPER
 $015B DEFM "FLAS","H"+$80     ; FLASH
 $0160 DEFM "BRIGH","T"+$80    ; BRIGHT
 $0166 DEFM "INVERS","E"+$80   ; INVERSE
 $016D DEFM "OVE","R"+$80      ; OVER
 $0171 DEFM "OU","T"+$80       ; OUT
 $0174 DEFM "LPRIN","T"+$80    ; LPRINT
 $017A DEFM "LLIS","T"+$80     ; LLIST
 $017F DEFM "STO","P"+$80      ; STOP
 $0183 DEFM "REA","D"+$80      ; READ
 $0187 DEFM "DAT","A"+$80      ; DATA
 $018B DEFM "RESTOR","E"+$80   ; RESTORE
 $0192 DEFM "NE","W"+$80       ; NEW
 $0195 DEFM "BORDE","R"+$80    ; BORDER
 $019B DEFM "CONTINU","E"+$80  ; CONTINUE
 $01A3 DEFM "DI","M"+$80       ; DIM
 $01A6 DEFM "RE","M"+$80       ; REM
 $01A9 DEFM "FO","R"+$80       ; FOR
 $01AC DEFM "GO T","O"+$80     ; GO TO
 $01B1 DEFM "GO SU","B"+$80    ; GO SUB
 $01B7 DEFM "INPU","T"+$80     ; INPUT
 $01BC DEFM "LOA","D"+$80      ; LOAD
 $01C0 DEFM "LIS","T"+$80      ; LIST
 $01C4 DEFM "LE","T"+$80       ; LET
 $01C7 DEFM "PAUS","E"+$80     ; PAUSE
 $01CC DEFM "NEX","T"+$80      ; NEXT
 $01D0 DEFM "POK","E"+$80      ; POKE
 $01D4 DEFM "PRIN","T"+$80     ; PRINT
 $01D9 DEFM "PLO","T"+$80      ; PLOT
 $01DD DEFM "RU","N"+$80       ; RUN
 $01E0 DEFM "SAV","E"+$80      ; SAVE
 $01E4 DEFM "RANDOMIZ","E"+$80 ; RANDOMIZE
 $01ED DEFM "I","F"+$80        ; IF
 $01EF DEFM "CL","S"+$80       ; CLS
 $01F2 DEFM "DRA","W"+$80      ; DRAW
 $01F6 DEFM "CLEA","R"+$80     ; CLEAR
 $01FB DEFM "RETUR","N"+$80    ; RETURN
 $0201 DEFM "COP","Y"+$80      ; COPY

; THE KEY TABLES
;
; Used by the routines at #R$031E and #R$0333.
; .
; There are six separate key tables. The final character code obtained depends
; on the particular key pressed and the 'mode' being used.
;
; .
;
; (a) The main key table - L mode and CAPS SHIFT.
@label=KEYTABLE_A
b$0205 DEFB $42      ; B
 $0206 DEFB $48      ; H
 $0207 DEFB $59      ; Y
 $0208 DEFB $36      ; 6
 $0209 DEFB $35      ; 5
 $020A DEFB $54      ; T
 $020B DEFB $47      ; G
 $020C DEFB $56      ; V
 $020D DEFB $4E      ; N
 $020E DEFB $4A      ; J
 $020F DEFB $55      ; U
 $0210 DEFB $37      ; 7
 $0211 DEFB $34      ; 4
 $0212 DEFB $52      ; R
 $0213 DEFB $46      ; F
 $0214 DEFB $43      ; C
 $0215 DEFB $4D      ; M
 $0216 DEFB $4B      ; K
 $0217 DEFB $49      ; I
 $0218 DEFB $38      ; 8
 $0219 DEFB $33      ; 3
 $021A DEFB $45      ; E
 $021B DEFB $44      ; D
 $021C DEFB $58      ; X
 $021D DEFB $0E      ; SYMBOL SHIFT
 $021E DEFB $4C      ; L
 $021F DEFB $4F      ; O
 $0220 DEFB $39      ; 9
 $0221 DEFB $32      ; 2
 $0222 DEFB $57      ; W
 $0223 DEFB $53      ; S
 $0224 DEFB $5A      ; Z
 $0225 DEFB $20      ; SPACE
 $0226 DEFB $0D      ; ENTER
 $0227 DEFB $50      ; P
 $0228 DEFB $30      ; 0
 $0229 DEFB $31      ; 1
 $022A DEFB $51      ; Q
 $022B DEFB $41      ; A
; (b) Extended mode. Letter keys and unshifted.
@label=KEYTABLE_B
 $022C DEFB $E3      ; READ
 $022D DEFB $C4      ; BIN
 $022E DEFB $E0      ; LPRINT
 $022F DEFB $E4      ; DATA
 $0230 DEFB $B4      ; TAN
 $0231 DEFB $BC      ; SGN
 $0232 DEFB $BD      ; ABS
 $0233 DEFB $BB      ; SQR
 $0234 DEFB $AF      ; CODE
 $0235 DEFB $B0      ; VAL
 $0236 DEFB $B1      ; LEN
 $0237 DEFB $C0      ; USR
 $0238 DEFB $A7      ; PI
 $0239 DEFB $A6      ; INKEY$
 $023A DEFB $BE      ; PEEK
 $023B DEFB $AD      ; TAB
 $023C DEFB $B2      ; SIN
 $023D DEFB $BA      ; INT
 $023E DEFB $E5      ; RESTORE
 $023F DEFB $A5      ; RND
 $0240 DEFB $C2      ; CHR$
 $0241 DEFB $E1      ; LLIST
 $0242 DEFB $B3      ; COS
 $0243 DEFB $B9      ; EXP
 $0244 DEFB $C1      ; STR$
 $0245 DEFB $B8      ; LN
; (c) Extended mode. Letter keys and either shift.
@label=KEYTABLE_C
 $0246 DEFB $7E      ; ~
 $0247 DEFB $DC      ; BRIGHT
 $0248 DEFB $DA      ; PAPER
 $0249 DEFB $5C      ; \
 $024A DEFB $B7      ; ATN
 $024B DEFB $7B      ; { {}}
 $024C DEFB $7D      ; }
 $024D DEFB $D8      ; CIRCLE
 $024E DEFB $BF      ; IN
 $024F DEFB $AE      ; VAL$
 $0250 DEFB $AA      ; SCREEN$
 $0251 DEFB $AB      ; ATTR
 $0252 DEFB $DD      ; INVERSE
 $0253 DEFB $DE      ; OVER
 $0254 DEFB $DF      ; OUT
 $0255 DEFB $7F      ; #CHR169
 $0256 DEFB $B5      ; ASN
 $0257 DEFB $D6      ; VERIFY
 $0258 DEFB $7C      ; |
 $0259 DEFB $D5      ; MERGE
 $025A DEFB $5D      ; ]
 $025B DEFB $DB      ; FLASH
 $025C DEFB $B6      ; ACS
 $025D DEFB $D9      ; INK
 $025E DEFB $5B      ; [
 $025F DEFB $D7      ; BEEP
; (d) Control codes. Digit keys and CAPS SHIFT.
@label=KEYTABLE_D
 $0260 DEFB $0C      ; DELETE
 $0261 DEFB $07      ; EDIT
 $0262 DEFB $06      ; CAPS LOCK
 $0263 DEFB $04      ; TRUE VIDEO
 $0264 DEFB $05      ; INV. VIDEO
 $0265 DEFB $08      ; Cursor left
 $0266 DEFB $0A      ; Cursor down
 $0267 DEFB $0B      ; Cursor up
 $0268 DEFB $09      ; Cursor right
 $0269 DEFB $0F      ; GRAPHICS
; (e) Symbol code. Letter keys and symbol shift.
@label=KEYTABLE_E
 $026A DEFB $E2      ; STOP
 $026B DEFB $2A      ; *
 $026C DEFB $3F      ; ?
 $026D DEFB $CD      ; STEP
 $026E DEFB $C8      ; >=
 $026F DEFB $CC      ; TO
 $0270 DEFB $CB      ; THEN
 $0271 DEFB $5E      ; #power
 $0272 DEFB $AC      ; AT
 $0273 DEFB $2D      ; -
 $0274 DEFB $2B      ; +
 $0275 DEFB $3D      ; =
 $0276 DEFB $2E      ; .
 $0277 DEFB $2C      ; ,
 $0278 DEFB $3B      ; ;
 $0279 DEFB $22      ; "
 $027A DEFB $C7      ; <=
 $027B DEFB $3C      ; <
 $027C DEFB $C3      ; NOT
 $027D DEFB $3E      ; >
 $027E DEFB $C5      ; OR
 $027F DEFB $2F      ; /
 $0280 DEFB $C9      ; <>
 $0281 DEFB $60      ; #CHR163
 $0282 DEFB $C6      ; AND
 $0283 DEFB $3A      ; :
; (f) Extended mode. Digit keys and symbol shift.
@label=KEYTABLE_F
 $0284 DEFB $D0      ; FORMAT
 $0285 DEFB $CE      ; DEF FN
 $0286 DEFB $A8      ; FN
 $0287 DEFB $CA      ; LINE
 $0288 DEFB $D3      ; OPEN
 $0289 DEFB $D4      ; CLOSE
 $028A DEFB $D1      ; MOVE
 $028B DEFB $D2      ; ERASE
 $028C DEFB $A9      ; POINT
 $028D DEFB $CF      ; CAT

; THE 'KEYBOARD SCANNING' SUBROUTINE
;
; This very important subroutine is called by both the main keyboard subroutine
; (#R$02BF) and the INKEY$ routine (#R$2634).
; .
; In all instances the #REGe register is returned with a value in the range of
; &00 to &27, the value being different for each of the forty keys of the
; keyboard, or the value &FF, for no-key.
; .
; The #REGd register is returned with a value that indicates which single shift
; key is being pressed. If both shift keys are being pressed then the #REGd and
; #REGe registers are returned with the values for the CAPS SHIFT and SYMBOL
; SHIFT keys respectively.
; .
; If no key is being pressed then the #REGde register pair is returned holding
; &FFFF.
; .
; The zero flag is returned reset if more than two keys are being pressed, or
; neither key of a pair of keys is a shift key.
;
; O:D Shift key pressed (&18 or &27), or &FF if no shift key pressed
; O:E Other key pressed (&00 to &27), or &FF if no other key pressed
; O:F Zero flag reset if an invalid combination of keys is pressed
@label=KEY_SCAN
c$028E LD L,$2F      ; The initial key value for each line will be &2F,
                     ; &2E,..., &28. (Eight lines.)
 $0290 LD DE,$FFFF   ; Initialise #REGde to 'no-key'.
 $0293 LD BC,$FEFE   ; #REGc=port address, #REGb=counter.
; Now enter a loop. Eight passes are made with each pass having a different
; initial key value and scanning a different line of five keys. (The first line
; is CAPS SHIFT, Z, X, C, V.)
@label=KEY_LINE
*$0296 IN A,(C)      ; Read from the port specified.
 $0298 CPL           ; {A pressed key in the line will set its respective bit,
 $0299 AND $1F       ; from bit 0 (outer key) to bit 4 (inner key).}
 $029B JR Z,$02AB    ; Jump forward if none of the five keys in the line are
                     ; being pressed.
 $029D LD H,A        ; {The key-bits go to the #REGh register whilst the
 $029E LD A,L        ; initial key value is fetched.}
@label=KEY_3KEYS
*$029F INC D         ; {If three keys are being pressed on the keyboard then
 $02A0 RET NZ        ; the #REGd register will no longer hold &FF - so return
                     ; if this happens.}
@label=KEY_BITS
*$02A1 SUB $08       ; {Repeatedly subtract 8 from the present key value until
 $02A3 SRL H         ; a key-bit is found.
 $02A5 JR NC,$02A1   ; }
 $02A7 LD D,E        ; Copy any earlier key value to the #REGd register.
 $02A8 LD E,A        ; Pass the new key value to the #REGe register.
 $02A9 JR NZ,$029F   ; If there is a second, or possibly a third, pressed key
                     ; in this line then jump back.
@label=KEY_DONE
*$02AB DEC L         ; The line has been scanned so the initial key value is
                     ; reduced for the next pass.
 $02AC RLC B         ; {The counter is shifted and the jump taken if there are
 $02AE JR C,$0296    ; still lines to be scanned.}
; Four tests are now made.
 $02B0 LD A,D        ; {Accept any key value which still has the #REGd register
 $02B1 INC A         ; holding &FF, i.e. a single key pressed or 'no-key'.
 $02B2 RET Z         ; }
 $02B3 CP $28        ; {Accept the key value for a pair of keys if the #REGd
 $02B5 RET Z         ; key is CAPS SHIFT.}
 $02B6 CP $19        ; {Accept the key value for a pair of keys if the #REGd
 $02B8 RET Z         ; key is SYMBOL SHIFT.}
 $02B9 LD A,E        ; {It is however possible for the #REGe key of a pair to
 $02BA LD E,D        ; be SYMBOL SHIFT - so this has to be considered.
 $02BB LD D,A        ;
 $02BC CP $18        ; }
 $02BE RET           ; Return with the zero flag set if it was SYMBOL SHIFT and
                     ; 'another key'; otherwise reset.

; THE 'KEYBOARD' SUBROUTINE
;
; Used by the routine at #R$0038.
; .
; This subroutine is called on every occasion that a maskable interrupt occurs.
; In normal operation this will happen once every 20 ms. The purpose of this
; subroutine is to scan the keyboard and decode the key value. The code
; produced will, if the 'repeat' status allows it, be passed to the system
; variable #SYSVAR(LAST-K). When a code is put into this system variable bit 5
; of #SYSVAR(FLAGS) is set to show that a 'new' key has been pressed.
@label=KEYBOARD
c$02BF CALL $028E     ; {Fetch a key value in the #REGde register pair but
 $02C2 RET NZ         ; return immediately if the zero flag is reset.}
; A double system of '#SYSVAR(KSTATE) system variables' (KSTATE0-KSTATE3 and
; KSTATE4-KSTATE7) is used from now on.
; .
; The two sets allow for the detection of a new key being pressed (using one
; set) whilst still within the 'repeat period' of the previous key to have been
; pressed (details in the other set).
; .
; A set will only become free to handle a new key if the key is held down for
; about 1/10th. of a second, i.e. five calls to #R$02BF.
 $02C3 LD HL,$5C00    ; Start with #R$5C00(KSTATE0).
@label=K_ST_LOOP
*$02C6 BIT 7,(HL)     ; {Jump forward if a 'set is free', i.e.
 $02C8 JR NZ,$02D1    ; #R$5C00(KSTATE0/4) holds &FF.}
 $02CA INC HL         ; {However if the set is not free decrease its '5 call
 $02CB DEC (HL)       ; counter' and when it reaches zero signal the set as
 $02CC DEC HL         ; free.
 $02CD JR NZ,$02D1    ;
 $02CF LD (HL),$FF    ; }
; After considering the first set change the pointer and consider the second
; set.
@label=K_CH_SET
*$02D1 LD A,L         ; {Fetch the low byte of the address and jump back if the
@ssub=LD HL,$5C00+$04
 $02D2 LD HL,$5C04    ; second set (#R$5C04(KSTATE4)) has still to be
 $02D5 CP L           ; considered.
 $02D6 JR NZ,$02C6    ; }
; Return now if the key value indicates 'no-key' or a shift key only.
 $02D8 CALL $031E     ; {Make the necessary tests and return if needed. Also
 $02DB RET NC         ; change the key value to a 'main code'.}
; A key stroke that is being repeated (held down) is now separated from a new
; key stroke.
 $02DC LD HL,$5C00    ; Look first at #R$5C00(KSTATE0).
 $02DF CP (HL)        ; {Jump forward if the codes match - indicating a repeat.
 $02E0 JR Z,$0310     ; }
 $02E2 EX DE,HL       ; Save the address of #R$5C00(KSTATE0).
@ssub=LD HL,$5C00+$04
 $02E3 LD HL,$5C04    ; Now look at #R$5C04(KSTATE4).
 $02E6 CP (HL)        ; {Jump forward if the codes match - indicating a repeat.
 $02E7 JR Z,$0310     ; }
; But a new key will not be accepted unless one of the sets of #SYSVAR(KSTATE)
; system variables is 'free'.
 $02E9 BIT 7,(HL)     ; Consider the second set.
 $02EB JR NZ,$02F1    ; Jump forward if 'free'.
 $02ED EX DE,HL       ; Now consider the first set.
 $02EE BIT 7,(HL)     ; {Continue if the set is 'free' but exit if not.
 $02F0 RET Z          ; }
; The new key is to be accepted. But before the system variable #SYSVAR(LAST-K)
; can be filled, the #SYSVAR(KSTATE) system variables, of the set being used,
; have to be initialised to handle any repeats and the key's code has to be
; decoded.
@label=K_NEW
*$02F1 LD E,A         ; {The code is passed to the #REGe register and to
 $02F2 LD (HL),A      ; #R$5C00(KSTATE0/4).}
 $02F3 INC HL         ; {The '5 call counter' for this set is reset to '5'.
 $02F4 LD (HL),$05    ; }
 $02F6 INC HL         ; {The third system variable of the set holds the
 $02F7 LD A,($5C09)   ; #SYSVAR(REPDEL) value (normally 0.7 secs.).
 $02FA LD (HL),A      ; }
 $02FB INC HL         ; Point to #R$5C00(KSTATE3/7).
; The decoding of a 'main code' depends upon the present state of
; #SYSVAR(MODE), bit 3 of #SYSVAR(FLAGS) and the 'shift byte'.
 $02FC LD C,(IY+$07)  ; Fetch #SYSVAR(MODE).
 $02FF LD D,(IY+$01)  ; Fetch #SYSVAR(FLAGS).
 $0302 PUSH HL        ; {Save the pointer whilst the 'main code' is decoded.
 $0303 CALL $0333     ;
 $0306 POP HL         ; }
 $0307 LD (HL),A      ; The final code value is saved in #R$5C00(KSTATE3/7),
                      ; from where it is collected in case of a repeat.
; The next three instructions are common to the handling of both 'new keys' and
; 'repeat keys'.
@label=K_END
*$0308 LD ($5C08),A   ; {Enter the final code value into #SYSVAR(LAST-K) and
 $030B SET 5,(IY+$01) ; signal 'a new key' by setting bit 5 of #SYSVAR(FLAGS).}
 $030F RET            ; Finally return.
; A key will 'repeat' on the first occasion after the delay period
; (#SYSVAR(REPDEL) - normally 0.7s) and on subsequent occasions after the delay
; period (#SYSVAR(REPPER) - normally 0.1s).
@label=K_REPEAT
*$0310 INC HL         ; {Point to the '5 call counter' of the set being used
 $0311 LD (HL),$05    ; and reset it to 5.}
 $0313 INC HL         ; {Point to the third system variable - the
 $0314 DEC (HL)       ; #SYSVAR(REPDEL)/#SYSVAR(REPPER) value - and decrement
                      ; it.}
 $0315 RET NZ         ; Exit from the #R$02BF subroutine if the delay period
                      ; has not passed.
 $0316 LD A,($5C0A)   ; {However once it has passed the delay period for the
 $0319 LD (HL),A      ; next repeat is to be #SYSVAR(REPPER).}
 $031A INC HL         ; {The repeat has been accepted so the final code value
 $031B LD A,(HL)      ; is fetched from #R$5C00(KSTATE3/7) and passed to
 $031C JR $0308       ; #R$0308.}

; THE 'K-TEST' SUBROUTINE
;
; Used by the routines at #R$02BF and #R$2634.
; .
; The key value is tested and a return made if 'no-key' or 'shift-only';
; otherwise the 'main code' for that key is found.
;
;   D Shift key pressed (&18 or &27), or &FF if no shift key pressed
;   E Other key pressed (&00 to &27), or &FF if no other key pressed
; O:A Main code (from the #R$0205#$0205(main key table))
; O:F Carry flag reset if an invalid combination of keys is pressed
@label=K_TEST
c$031E LD B,D        ; Copy the shift byte.
 $031F LD D,$00      ; Clear the #REGd register for later.
 $0321 LD A,E        ; Move the key number.
 $0322 CP $27        ; {Return now if the key was 'CAPS SHIFT' only or
 $0324 RET NC        ; 'no-key'.}
 $0325 CP $18        ; {Jump forward unless the #REGe key was SYMBOL SHIFT.
 $0327 JR NZ,$032C   ; }
 $0329 BIT 7,B       ; {However accept SYMBOL SHIFT and another key; return
 $032B RET NZ        ; with SYMBOL SHIFT only.}
; The 'main code' is found by indexing into the main key table.
@label=K_MAIN
*$032C LD HL,$0205   ; The base address of the #R$0205#$0205(main key table).
 $032F ADD HL,DE     ; {Index into the table and fetch the 'main code'.
 $0330 LD A,(HL)     ; }
 $0331 SCF           ; {Signal 'valid keystroke' before returning.
 $0332 RET           ; }

; THE 'KEYBOARD DECODING' SUBROUTINE
;
; Used by the routines at #R$02BF and #R$2634.
; .
; This subroutine is entered with the 'main code' in the #REGe register, the
; value of #SYSVAR(FLAGS) in the #REGd register, the value of #SYSVAR(MODE) in
; the #REGc register and the 'shift byte' in the #REGb register.
; .
; By considering these four values and referring, as necessary, to the
; #R$0205(six key tables) a 'final code' is produced. This is returned in the
; #REGa register.
;
;   B Shift key pressed (&18 or &27), or &FF if no shift key pressed
;   C #SYSVAR(MODE)
;   D #SYSVAR(FLAGS)
;   E Main code (from the #R$0205#$0205(main key table))
; O:A Final code (from the #R$0205(key tables))
@label=K_DECODE
c$0333 LD A,E         ; Copy the 'main code'.
 $0334 CP $3A         ; {Jump forward if a digit key is being considered; also
 $0336 JR C,$0367     ; SPACE, ENTER and both shifts.}
 $0338 DEC C          ; Decrement the #SYSVAR(MODE) value.
 $0339 JP M,$034F     ; {Jump forward, as needed, for modes 'K', 'L', 'C' and
 $033C JR Z,$0341     ; 'E'.}
; Only 'graphics' mode remains and the 'final code' for letter keys in graphics
; mode is computed from the 'main code'.
 $033E ADD A,$4F      ; Add the offset.
 $0340 RET            ; Return with the 'final code'.
; Letter keys in extended mode are considered next.
@keep=$41
@ssub=LD HL,$022C-$41
@label=K_E_LET
*$0341 LD HL,$01EB    ; The base address for #R$022C(table 'b').
 $0344 INC B          ; {Jump forward to use this table if neither shift key is
 $0345 JR Z,$034A     ; being pressed.}
 $0347 LD HL,$0205    ; Otherwise use the base address for #R$0246(table 'c').
; Key tables 'b-f' are all served by the following look-up routine. In all
; cases a 'final code' is found and returned.
@label=K_LOOK_UP
*$034A LD D,$00       ; Clear the #REGd register.
 $034C ADD HL,DE      ; {Index the required table and fetch the 'final code'.
 $034D LD A,(HL)      ; }
 $034E RET            ; Then return.
; Letter keys in 'K', 'L' or 'C' modes are now considered. But first the
; special SYMBOL SHIFT codes have to be dealt with.
@nowarn
@ssub=LD HL,$026A-$41
@label=K_KLC_LET
*$034F LD HL,$0229    ; The base address for #R$026A(table 'e').
 $0352 BIT 0,B        ; {Jump back if using the SYMBOL SHIFT key and a letter
 $0354 JR Z,$034A     ; key.}
 $0356 BIT 3,D        ; {Jump forward if currently in 'K' mode.
 $0358 JR Z,$0364     ; }
 $035A BIT 3,(IY+$30) ; {If CAPS LOCK is set (bit 3 of #R$5C6A(FLAGS2) set)
 $035E RET NZ         ; then return with the 'main code'.}
 $035F INC B          ; {Also return in the same manner if CAPS SHIFT is being
 $0360 RET NZ         ; pressed.}
 $0361 ADD A,$20      ; {However if lower case codes are required then &20 has
 $0363 RET            ; to be added to the 'main code' to give the correct
                      ; 'final code'.}
; The 'final code' values for tokens are found by adding &A5 to the 'main
; code'.
@label=K_TOKENS
*$0364 ADD A,$A5      ; {Add the required offset and return.
 $0366 RET            ; }
; Next the digit keys, SPACE, ENTER and both shifts are considered.
@label=K_DIGIT
*$0367 CP "0"         ; {Proceed only with the digit keys, i.e. return with
 $0369 RET C          ; SPACE (&20), ENTER (&0D) and both shifts (&0E).}
 $036A DEC C          ; Now separate the digit keys into three groups -
                      ; according to the mode.
 $036B JP M,$039D     ; {Jump with 'K', 'L' and 'C' modes, and also with 'G'
 $036E JR NZ,$0389    ; mode. Continue with 'E' mode.}
@nowarn
@keep=$30
@ssub=LD HL,$0284-$30
 $0370 LD HL,$0254    ; The base address for #R$0284(table 'f').
 $0373 BIT 5,B        ; {Use this table for SYMBOL SHIFT and a digit key in
 $0375 JR Z,$034A     ; extended mode.}
 $0377 CP "8"         ; {Jump forward with digit keys '8' and '9'.
 $0379 JR NC,$0382    ; }
; The digit keys '0' to '7' in extended mode are to give either a 'paper colour
; code' or an 'ink colour code' depending on the use of CAPS SHIFT.
 $037B SUB $20        ; Reduce the range &30 to &37 giving &10 to &17.
 $037D INC B          ; {Return with this 'paper colour code' if CAPS SHIFT is
 $037E RET Z          ; not being used.}
 $037F ADD A,$08      ; {But if it is then the range is to be &18 to &1F
 $0381 RET            ; instead - indicating an 'ink colour code'.}
; The digit keys '8' and '9' are to give 'BRIGHT' and 'FLASH' codes.
@label=K_8_9
*$0382 SUB $36        ; &38 and &39 go to &02 and &03.
 $0384 INC B          ; {Return with these codes if CAPS SHIFT is not being
 $0385 RET Z          ; used. (These are 'BRIGHT' codes.)}
 $0386 ADD A,$FE      ; {Subtract '2' if CAPS SHIFT is being used; giving &00
 $0388 RET            ; and &01 (as 'FLASH' codes).}
; The digit keys in graphics mode are to give the block graphic characters (&80
; to &8F), the GRAPHICS code (&0F) and the DELETE code (&0C).
@nowarn
@keep=$30
@ssub=LD HL,$0260-$30
@label=K_GRA_DGT
*$0389 LD HL,$0230    ; The base address of #R$0260(table 'd').
 $038C CP "9"         ; {Use this table directly for both digit key '9' that is
 $038E JR Z,$034A     ; to give GRAPHICS, and digit key '0' that is to give
 $0390 CP "0"         ; DELETE.
 $0392 JR Z,$034A     ; }
 $0394 AND $07        ; {For keys '1' to '8' make the range &80 to &87.
 $0396 ADD A,$80      ; }
 $0398 INC B          ; {Return with a value from this range if neither shift
 $0399 RET Z          ; key is being pressed.}
 $039A XOR $0F        ; {But if 'shifted' make the range &88 to &8F.
 $039C RET            ; }
; Finally consider the digit keys in 'K', 'L' and 'C' modes.
@label=K_KLC_DGT
*$039D INC B          ; {Return directly if neither shift key is being used.
 $039E RET Z          ; (Final codes &30 to &39.)}
 $039F BIT 5,B        ; {Use #R$0260(table 'd') if the CAPS SHIFT key is also
@nowarn
@keep=$30
@ssub=LD HL,$0260-$30
 $03A1 LD HL,$0230    ; being pressed.
 $03A4 JR NZ,$034A    ; }
; The codes for the various digit keys and SYMBOL SHIFT can now be found.
 $03A6 SUB $10        ; Reduce the range to give &20 to &29.
 $03A8 CP $22         ; {Separate the '@' character from the others.
 $03AA JR Z,$03B2     ; }
 $03AC CP $20         ; The '_' character has also to be separated.
 $03AE RET NZ         ; Return now with the 'final codes' &21, &23 to &29.
 $03AF LD A,"_"       ; {Give the '_' character a code of &5F.
 $03B1 RET            ; }
@label=K_AT_CHAR
*$03B2 LD A,"@"       ; {Give the '@' character a code of &40.
 $03B4 RET            ; }

; THE 'BEEPER' SUBROUTINE
;
@ignoreua
; Used by the routines at #R$03F8, #R$0F2C, #R$107F and #R$111D.
; .
; The loudspeaker is activated by having D4 low during an '#S/OUT/' instruction
; that is using port &FE. When D4 is high in a similar situation the
; loudspeaker is deactivated. A 'beep' can therefore be produced by regularly
; changing the level of D4.
; .
; Consider now the note 'middle C' which has the frequency 261.63 Hz. In order
; to get this note the loudspeaker will have to be alternately activated and
; deactivated every 1/523.26th of a second. In the Spectrum the system clock is
; set to run at 3.5 MHz. and the note of 'middle C' will require that the
; requisite '#S/OUT/' instruction be executed as close as possible to every
; 6689 T states. This last value, when reduced slightly for unavoidable
; overheads, represents the 'length of the timing loop' in this subroutine.
; .
; This subroutine is entered with the #REGde register pair holding the value
; 'f*t', where a note of given frequency 'f' is to have a duration of 't'
; seconds, and the #REGhl register pair holding a value equal to the number of
; T states in the 'timing loop' divided by 4, i.e. for the note 'middle C' to
; be produced for one second #REGde holds &0105 (INT(261.3*1)) and #REGhl holds
; &066A (derived from 6689/4-30.125).
;
; DE Number of passes to make through the sound generation loop
; HL Loop delay parameter
@label=BEEPER
c$03B5 DI            ; Disable the interrupt for the duration of a 'beep'.
 $03B6 LD A,L        ; Save #REGl temporarily.
 $03B7 SRL L         ; {Each '1' in the #REGl register is to count 4 T states,
 $03B9 SRL L         ; but take INT (#REGl/4) and count 16 T states instead.}
 $03BB CPL           ; {Go back to the original value in #REGl and find how
 $03BC AND $03       ; many were lost by taking 3-(#REGa mod 4).
 $03BE LD C,A        ;
 $03BF LD B,$00      ; }
@nowarn
 $03C1 LD IX,$03D1   ; The base address of the timing loop.
 $03C5 ADD IX,BC     ; Alter the length of the timing loop. Use an earlier
                     ; starting point for each '1' lost by taking INT
                     ; (#REGl/4).
 $03C7 LD A,($5C48)  ; {Fetch the present border colour from #SYSVAR(BORDCR)
 $03CA AND $38       ; and move it to bits 2, 1 and 0 of the #REGa register.
 $03CC RRCA          ;
 $03CD RRCA          ;
 $03CE RRCA          ; }
 $03CF OR $08        ; Ensure the MIC output is 'off'.
@ignoreua
; Now enter the sound generation loop. #REGde complete passes are made, i.e. a
; pass for each cycle of the note.
; .
; The #REGhl register holds the 'length of the timing loop' with 16 T states
; being used for each '1' in the #REGl register and 1024 T states for each '1'
; in the #REGh register.
 $03D1 NOP           ; {Add 4 T states for each earlier entry point that is
 $03D2 NOP           ; used.
 $03D3 NOP           ; }
 $03D4 INC B         ; {The values in the #REGb and #REGc registers will come
 $03D5 INC C         ; from the #REGh and #REGl registers - see below.}
@label=BE_H_L_LP
*$03D6 DEC C         ; {The 'timing loop', i.e. #REGbc*4 T states. (But note
 $03D7 JR NZ,$03D6   ; that at the half-cycle point, #REGc will be equal to
 $03D9 LD C,$3F      ; #REGl+1.)
 $03DB DEC B         ;
 $03DC JP NZ,$03D6   ; }
; The loudspeaker is now alternately activated and deactivated.
 $03DF XOR $10       ; Flip bit 4.
 $03E1 OUT ($FE),A   ; Perform the '#S/OUT/' operation, leaving the border
                     ; unchanged.
 $03E3 LD B,H        ; Reset the #REGb register.
 $03E4 LD C,A        ; Save the #REGa register.
 $03E5 BIT 4,A       ; {Jump if at the half-cycle point.
 $03E7 JR NZ,$03F2   ; }
; After a full cycle the #REGde register pair is tested.
 $03E9 LD A,D        ; {Jump forward if the last complete pass has been made
 $03EA OR E          ; already.
 $03EB JR Z,$03F6    ; }
 $03ED LD A,C        ; Fetch the saved value.
 $03EE LD C,L        ; Reset the #REGc register.
 $03EF DEC DE        ; Decrease the pass counter.
 $03F0 JP (IX)       ; Jump back to the required starting location of the loop.
; The parameters for the second half-cycle are set up.
@label=BE_AGAIN
*$03F2 LD C,L        ; Reset the #REGc register.
 $03F3 INC C         ; Add 16 T states as this path is shorter.
 $03F4 JP (IX)       ; Jump back.
; Upon completion of the 'beep' the maskable interrupt has to be enabled.
@label=BE_END
*$03F6 EI            ; Enable interrupt.
 $03F7 RET           ; Finally return.

; THE 'BEEP' COMMAND ROUTINE
;
; The address of this routine is found in the #R$1AE3(parameter table).
; .
; The subroutine is entered with two numbers on the calculator stack. The
; topmost number (P) represents the 'pitch' of the note and the number
; underneath it (t) represents the 'duration'.
@refs=$1C0D
@label=BEEP
c$03F8 RST $28                  ; The floating-point calculator is used to
                                ; manipulate the two values: t, P.
 $03F9 DEFB $31                 ; #R$33C0: t, P, P
 $03FA DEFB $27                 ; #R$36AF: t, P, i (where i=INT P)
 $03FB DEFB $C0                 ; #R$342D(st_mem_0): t, P, i (mem-0 holds i)
 $03FC DEFB $03                 ; #R$300F: t, p (where p is the fractional part
                                ; of P)
 $03FD DEFB $34                 ; {#R$33C6: Stack the decimal value
 $03FE DEFB $EC,$6C,$98,$1F,$F5 ; K=0.0577622606 (which is a little below
                                ; 12*(2#power0.5)-1)}
 $0403 DEFB $04                 ; #R$30CA: t, pK
 $0404 DEFB $A1                 ; #R$341B(stk_one): t, pK, 1
 $0405 DEFB $0F                 ; #R$3014: t, pK+1
 $0406 DEFB $38                 ; #R$369B
; Now perform several tests on i, the integer part of the 'pitch'.
 $0407 LD HL,$5C92              ; This is 'mem-0-1st' (#SYSVAR(MEMBOT)).
 $040A LD A,(HL)                ; Fetch the exponent of i.
 $040B AND A                    ; {Give an error if i is not in the integral
 $040C JR NZ,$046C              ; (short) form.}
 $040E INC HL                   ; {Copy the sign byte to the #REGc register.
 $040F LD C,(HL)                ; }
 $0410 INC HL                   ; {Copy the low-byte to the #REGb register, and
 $0411 LD B,(HL)                ; to the #REGa register.
 $0412 LD A,B                   ; }
 $0413 RLA                      ; {Again give report B if i does not satisfy
 $0414 SBC A,A                  ; the test: -128<=i<=+127.
 $0415 CP C                     ;
 $0416 JR NZ,$046C              ;
 $0418 INC HL                   ;
 $0419 CP (HL)                  ;
 $041A JR NZ,$046C              ; }
 $041C LD A,B                   ; {Fetch the low-byte and test it further.
 $041D ADD A,$3C                ; }
 $041F JP P,$0425               ; Accept -60<=i<=67.
 $0422 JP PO,$046C              ; Reject -128 to -61.
; Note: the range 70 to 127 will be rejected later on.
; .
; The correct frequency for the 'pitch' i can now be found.
@label=BE_i_OK
*$0425 LD B,$FA                 ; Start '6' octaves below middle C.
@label=BE_OCTAVE
*$0427 INC B                    ; {Repeatedly reduce i in order to find the
 $0428 SUB $0C                  ; correct octave.
 $042A JR NC,$0427              ; }
 $042C ADD A,$0C                ; Add back the last subtraction.
 $042E PUSH BC                  ; Save the octave number.
 $042F LD HL,$046E              ; The base address of the '#R$046E(semitone
                                ; table)'.
 $0432 CALL $3406               ; {Consider the table and pass the 'A th.'
 $0435 CALL $33B4               ; value to the calculator stack. (Call it C.)}
; Now the fractional part of the 'pitch' can be taken into consideration.
 $0438 RST $28                  ; t, pK+1, C
 $0439 DEFB $04                 ; #R$30CA: t, C(pK+1)
 $043A DEFB $38                 ; #R$369B
; The final frequency f is found by modifying the 'last value' according to the
; octave number.
 $043B POP AF                   ; Fetch the octave number.
 $043C ADD A,(HL)               ; {Multiply the 'last value' by 2 to the power
 $043D LD (HL),A                ; of the octave number.}
 $043E RST $28                  ; t, f
 $043F DEFB $C0                 ; #R$342D(st_mem_0): Copy the frequency (f) to
                                ; mem-0
 $0440 DEFB $02                 ; #R$33A1: t
; Attention is now turned to the 'duration'.
 $0441 DEFB $31                 ; #R$33C0: t, t
 $0442 DEFB $38                 ; #R$369B
 $0443 CALL $1E94               ; {The value 'INT t' must be in the range &00
 $0446 CP $0B                   ; to &0A.
 $0448 JR NC,$046C              ; }
; The number of complete cycles in the 'beep' is given by f*t so this value is
; now found.
 $044A RST $28                  ; t
 $044B DEFB $E0                 ; #R$340F(get_mem_0): t, f
 $044C DEFB $04                 ; #R$30CA: f*t
; The result is left on the calculator stack whilst the length of the 'timing
; loop' required for the 'beep' is computed.
 $044D DEFB $E0                 ; #R$340F(get_mem_0): f*t, f
 $044E DEFB $34                 ; {#R$33C6: Stack the value
 $044F DEFB $80,$43,$55,$9F,$80 ; (3.5*10#power6)/8=437500}
 $0454 DEFB $01                 ; #R$343C: f*t, 437500, f
 $0455 DEFB $05                 ; #R$31AF: f*t, 437500/f
 $0456 DEFB $34                 ; {#R$33C6: f*t, 437500/f, 30.125
 $0457 DEFB $35,$71             ; }
 $0459 DEFB $03                 ; #R$300F: f*t, 437500/f-30.125
 $045A DEFB $38                 ; #R$369B
; Note: the value 437500/f gives the 'half-cycle' length of the note and
; reducing it by 30.125 allows for 120.5 T states in which to actually produce
; the note and adjust the counters etc.
; .
; The values can now be transferred to the required registers.
 $045B CALL $1E99               ; {The 'timing loop' value is compressed into
 $045E PUSH BC                  ; the #REGbc register pair and saved.}
; Note: if the timing loop value is too large then an error will occur
; (returning via #R$0008), thereby excluding 'pitch' values of 70 to 127.
 $045F CALL $1E99               ; The f*t value is compressed into the #REGbc
                                ; register pair.
 $0462 POP HL                   ; Move the 'timing loop' value to the #REGhl
                                ; register pair.
 $0463 LD D,B                   ; {Move the f*t value to the #REGde register
 $0464 LD E,C                   ; pair.}
; However before making the 'beep' test the value f*t.
 $0465 LD A,D                   ; {Return if f*t has given the result of 'no
 $0466 OR E                     ; cycles' required.
 $0467 RET Z                    ; }
 $0468 DEC DE                   ; {Decrease the cycle number and jump to
 $0469 JP $03B5                 ; #R$03B5 (making at least one pass).}
; Report B - integer out of range.
@label=REPORT_B
*$046C RST $08                  ; {Call the error handling routine.
 $046D DEFB $0A                 ; }

; THE 'SEMI-TONE' TABLE
;
; Used by the routine at #R$03F8.
; .
; This table holds the frequencies of the twelve semi-tones in an octave.
@label=SEMITONES
b$046E DEFB $89,$02,$D0,$12,$86 ; 261.63 Hz - C
 $0473 DEFB $89,$0A,$97,$60,$75 ; 277.18 Hz - C#
 $0478 DEFB $89,$12,$D5,$17,$1F ; 293.66 Hz - D
 $047D DEFB $89,$1B,$90,$41,$02 ; 311.13 Hz - D#
 $0482 DEFB $89,$24,$D0,$53,$CA ; 329.63 Hz - E
 $0487 DEFB $89,$2E,$9D,$36,$B1 ; 349.23 Hz - F
 $048C DEFB $89,$38,$FF,$49,$3E ; 369.99 Hz - F#
 $0491 DEFB $89,$43,$FF,$6A,$73 ; 392.00 Hz - G
 $0496 DEFB $89,$4F,$A7,$00,$54 ; 415.30 Hz - G#
 $049B DEFB $89,$5C,$00,$00,$00 ; 440.00 Hz - A
 $04A0 DEFB $89,$69,$14,$F6,$24 ; 466.16 Hz - A#
 $04A5 DEFB $89,$76,$F1,$10,$05 ; 493.88 Hz - B

; THE 'PROGRAM NAME' SUBROUTINE (ZX81)
;
; The following subroutine applies to the ZX81 and was not removed when the
; program was rewritten for the Spectrum.
@label=PROGNAME
u$04AA CALL $24FB
 $04AD LD A,($5C3B)
 $04B0 ADD A,A
 $04B1 JP M,$1C8A
 $04B4 POP HL
 $04B5 RET NC
 $04B6 PUSH HL
 $04B7 CALL $2BF1
 $04BA LD H,D
 $04BB LD L,E
 $04BC DEC C
 $04BD RET M
 $04BE ADD HL,BC
 $04BF SET 7,(HL)
 $04C1 RET

; THE 'SA-BYTES' SUBROUTINE
;
; Used by the routine at #R$0970.
; .
; This subroutine is called to save the header information and later the actual
; program/data block to tape.
;
; A &00 (header block) or &FF (data block)
; DE Block length
; IX Start address
@nowarn
@label=SA_BYTES
c$04C2 LD HL,$053F   ; {Pre-load the machine stack with the address #R$053F.
 $04C5 PUSH HL       ; }
@keep
 $04C6 LD HL,$1F80   ; This constant will give a leader of about 5 seconds for
                     ; a 'header'.
 $04C9 BIT 7,A       ; {Jump forward if saving a header.
 $04CB JR Z,$04D0    ; }
@keep
 $04CD LD HL,$0C98   ; This constant will give a leader of about 2 seconds for
                     ; a program/data block.
@label=SA_FLAG
*$04D0 EX AF,AF'     ; The flag is saved.
 $04D1 INC DE        ; {The 'length' is incremented and the 'base address'
 $04D2 DEC IX        ; reduced to allow for the flag.}
 $04D4 DI            ; The maskable interrupt is disabled during the save.
 $04D5 LD A,$02      ; Signal 'MIC on' and border to be red.
 $04D7 LD B,A        ; Give a value to #REGb.
; A loop is now entered to create the pulses of the leader. Both the 'MIC on'
; and the 'MIC off' pulses are 2,168 T states in length. The colour of the
; border changes from red to cyan with each 'edge'.
; .
; Note: an 'edge' will be a transition either from 'on' to 'off', or from 'off'
; to 'on'.
@label=SA_LEADER
*$04D8 DJNZ $04D8    ; The main timing period.
 $04DA OUT ($FE),A   ; {MIC on/off, border red/cyan, on each pass.
 $04DC XOR $0F       ; }
 $04DE LD B,$A4      ; The main timing constant.
 $04E0 DEC L         ; Decrease the low counter.
 $04E1 JR NZ,$04D8   ; Jump back for another pulse.
 $04E3 DEC B         ; Allow for the longer path (reduce by 13 T states).
 $04E4 DEC H         ; Decrease the high counter.
 $04E5 JP P,$04D8    ; Jump back for another pulse until completion of the
                     ; leader.
; A sync pulse is now sent.
 $04E8 LD B,$2F      ;
@label=SA_SYNC_1
@ignoreua
*$04EA DJNZ $04EA    ; MIC off for 667 T states from '#S/OUT/ to #S/OUT/'.
 $04EC OUT ($FE),A   ; MIC on and red.
 $04EE LD A,$0D      ; Signal 'MIC off and cyan'.
@ignoreua
 $04F0 LD B,$37      ; {MIC on for 735 T States from '#S/OUT/ to #S/OUT/'.
@label=SA_SYNC_2
*$04F2 DJNZ $04F2    ; }
 $04F4 OUT ($FE),A   ; Now MIC off and border cyan.
; The header v. program/data flag will be the first byte to be saved.
@keep
 $04F6 LD BC,$3B0E   ; &3B is a timing constant; &0E signals 'MIC off and
                     ; yellow'.
 $04F9 EX AF,AF'     ; {Fetch the flag and pass it to the #REGl register for
 $04FA LD L,A        ; 'sending'.}
 $04FB JP $0507      ; Jump forward into the saving loop.
; The byte saving loop is now entered. The first byte to be saved is the flag;
; this is followed by the actual data bytes and the final byte sent is the
; parity byte that is built up by considering the values of all the earlier
; bytes.
@label=SA_LOOP
*$04FE LD A,D        ; {The 'length' counter is tested and the jump taken when
 $04FF OR E          ; it has reached zero.
 $0500 JR Z,$050E    ; }
 $0502 LD L,(IX+$00) ; Fetch the next byte that is to be saved.
@label=SA_LOOP_P
*$0505 LD A,H        ; Fetch the current 'parity'.
 $0506 XOR L         ; Include the present byte.
@label=SA_START
*$0507 LD H,A        ; Restore the 'parity'. Note that on entry here the 'flag'
                     ; value initialises 'parity'.
 $0508 LD A,$01      ; Signal 'MIC on and blue'.
 $050A SCF           ; Set the carry flag. This will act as a 'marker' for the
                     ; 8 bits of a byte.
 $050B JP $0525      ; Jump forward.
; When it is time to send the 'parity' byte then it is transferred to the #REGl
; register for saving.
@label=SA_PARITY
*$050E LD L,H        ; Get final 'parity' value.
 $050F JR $0505      ; Jump back.
@ignoreua
; The following inner loop produces the actual pulses. The loop is entered at
; #R$0514 with the type of the bit to be saved indicated by the carry flag. Two
; passes of the loop are made for each bit thereby making an 'off pulse' and an
; 'on pulse'. The pulses for a reset bit are shorter by 855 T states.
@label=SA_BIT_2
*$0511 LD A,C        ; Come here on the second pass and fetch 'MIC off and
                     ; yellow'.
 $0512 BIT 7,B       ; Set the zero flag to show 'second pass'.
@label=SA_BIT_1
@ignoreua
*$0514 DJNZ $0514    ; The main timing loop; always 801 T states on a second
                     ; pass.
 $0516 JR NC,$051C   ; Jump, taking the shorter path, if saving a '0'.
@ignoreua
 $0518 LD B,$42      ; {However if saving a '1' then add 855 T states.
@label=SA_SET
*$051A DJNZ $051A    ; }
@label=SA_OUT
*$051C OUT ($FE),A   ; On the first pass 'MIC on and blue' and on the second
                     ; pass 'MIC off and yellow'.
 $051E LD B,$3E      ; Set the timing constant for the second pass.
 $0520 JR NZ,$0511   ; {Jump back at the end of the first pass; otherwise
 $0522 DEC B         ; reclaim 13 T states.}
 $0523 XOR A         ; {Clear the carry flag and set #REGa to hold &01 (MIC on
 $0524 INC A         ; and blue) before continuing into the '8 bit loop'.}
; The '8 bit loop' is entered initially with the whole byte in the #REGl
; register and the carry flag set. However it is re-entered after each bit has
; been saved until the point is reached when the 'marker' passes to the carry
; flag leaving the #REGl register empty.
@label=SA_8_BITS
*$0525 RL L          ; Move bit 7 to the carry and the 'marker' leftwards.
 $0527 JP NZ,$0514   ; Save the bit unless finished with the byte.
 $052A DEC DE        ; Decrease the 'counter'.
 $052B INC IX        ; Advance the 'base address'.
 $052D LD B,$31      ; Set the timing constant for the first bit of the next
                     ; byte.
 $052F LD A,$7F      ; {Return (to #R$053F) if the BREAK key is being pressed.
 $0531 IN A,($FE)    ;
 $0533 RRA           ;
 $0534 RET NC        ; }
 $0535 LD A,D        ; {Otherwise test the 'counter' and jump back even if it
 $0536 INC A         ; has reached zero (so as to send the 'parity' byte).
 $0537 JP NZ,$04FE   ; }
 $053A LD B,$3B      ; {Exit when the 'counter' reaches &FFFF. But first give a
@label=SA_DELAY
*$053C DJNZ $053C    ; short delay.
 $053E RET           ; }
@ignoreua
; Note: a reset bit will give a 'MIC off' pulse of 855 T states followed by a
; 'MIC on' pulse of 855 T states, whereas a set bit will give pulses of exactly
; twice as long. Note also that there are no gaps either between the sync pulse
; and the first bit of the flag, or between bytes.

; THE 'SA/LD-RET' SUBROUTINE
;
; Used by the routines at #R$04C2 and #R$0556.
; .
; This subroutine is common to both saving and loading.
; .
; The border is set to its original colour and the BREAK key tested for a last
; time.
;
; F Carry flag reset if there was a loading error
@refs=$04C2,$0556
@label=SA_LD_RET
c$053F PUSH AF       ; Save the carry flag. (It is reset after a loading
                     ; error.)
 $0540 LD A,($5C48)  ; {Fetch the original border colour from its system
 $0543 AND $38       ; variable (#SYSVAR(BORDCR)).}
 $0545 RRCA          ; {Move the border colour to bits 2, 1 and 0.
 $0546 RRCA          ;
 $0547 RRCA          ; }
 $0548 OUT ($FE),A   ; Set the border to its original colour.
 $054A LD A,$7F      ; {Read the BREAK key for a last time.
 $054C IN A,($FE)    ;
 $054E RRA           ; }
 $054F EI            ; Enable the maskable interrupt.
 $0550 JR C,$0554    ; Jump unless a break is to be made.
; Report D - BREAK-CONT repeats.
 $0552 RST $08       ; {Call the error handling routine.
 $0553 DEFB $0C      ; }
; Continue here.
@label=SA_LD_END
*$0554 POP AF        ; Retrieve the carry flag.
 $0555 RET           ; Return to the calling routine.

; THE 'LD-BYTES' SUBROUTINE
;
; Used by the routines at #R$0605 and #R$0802.
; .
; This subroutine is called to load the header information and later load or
; verify an actual block of data from a tape.
;
;   A &00 (header block) or &FF (data block)
;   F Carry flag set if loading, reset if verifying
;   DE Block length
;   IX Start address
; O:F Carry flag reset if there was an error
@label=LD_BYTES
c$0556 INC D         ; This resets the zero flag. (#REGd cannot hold &FF.)
 $0557 EX AF,AF'     ; The #REGa register holds &00 for a header and &FF for a
                     ; block of data. The carry flag is reset for verifying and
                     ; set for loading.
 $0558 DEC D         ; Restore #REGd to its original value.
 $0559 DI            ; The maskable interrupt is now disabled.
 $055A LD A,$0F      ; {The border is made white.
 $055C OUT ($FE),A   ; }
@nowarn
 $055E LD HL,$053F   ; {Preload the machine stack with the address #R$053F.
 $0561 PUSH HL       ; }
 $0562 IN A,($FE)    ; Make an initial read of port '254'.
 $0564 RRA           ; {Rotate the byte obtained but keep only the EAR bit.
 $0565 AND $20       ; }
 $0567 OR $02        ; Signal red border.
 $0569 LD C,A        ; Store the value in the #REGc register (&22 for 'off' and
                     ; &02 for 'on' - the present EAR state).
 $056A CP A          ; Set the zero flag.
; The first stage of reading a tape involves showing that a pulsing signal
; actually exists (i.e. 'on/off' or 'off/on' edges).
@label=LD_BREAK
*$056B RET NZ        ; Return if the BREAK key is being pressed.
@label=LD_START
*$056C CALL $05E7    ; {Return with the carry flag reset if there is no 'edge'
 $056F JR NC,$056B   ; within approx. 14,000 T states. But if an 'edge' is
                     ; found the border will go cyan.}
; The next stage involves waiting a while and then showing that the signal is
; still pulsing.
@keep
 $0571 LD HL,$0415   ; {The length of this waiting period will be almost one
@label=LD_WAIT
*$0574 DJNZ $0574    ; second in duration.
 $0576 DEC HL        ;
 $0577 LD A,H        ;
 $0578 OR L          ;
 $0579 JR NZ,$0574   ; }
 $057B CALL $05E3    ; {Continue only if two edges are found within the allowed
 $057E JR NC,$056B   ; time period.}
; Now accept only a 'leader signal'.
@label=LD_LEADER
*$0580 LD B,$9C      ; The timing constant.
 $0582 CALL $05E3    ; {Continue only if two edges are found within the allowed
 $0585 JR NC,$056B   ; time period.}
 $0587 LD A,$C6      ; {However the edges must have been found within about
 $0589 CP B          ; 3,000 T states of each other.
 $058A JR NC,$056C   ; }
 $058C INC H         ; {Count the pair of edges in the #REGh register until
 $058D JR NZ,$0580   ; '256' pairs have been found.}
; After the leader come the 'off' and 'on' parts of the sync pulse.
@label=LD_SYNC
*$058F LD B,$C9      ; The timing constant.
 $0591 CALL $05E7    ; {Every edge is considered until two edges are found
 $0594 JR NC,$056B   ; close together - these will be the start and finishing
 $0596 LD A,B        ; edges of the 'off' sync pulse.
 $0597 CP $D4        ;
 $0599 JR NC,$058F   ; }
 $059B CALL $05E7    ; {The finishing edge of the 'on' pulse must exist.
 $059E RET NC        ; (Return carry flag reset.)}
; The bytes of the header or the program/data block can now be loaded or
; verified. But the first byte is the type flag.
 $059F LD A,C        ; {The border colours from now on will be blue and yellow.
 $05A0 XOR $03       ;
 $05A2 LD C,A        ; }
 $05A3 LD H,$00      ; Initialise the 'parity matching' byte to zero.
 $05A5 LD B,$B0      ; Set the timing constant for the flag byte.
 $05A7 JR $05C8      ; Jump forward into the byte loading loop.
; The byte loading loop is used to fetch the bytes one at a time. The flag byte
; is first. This is followed by the data bytes and the last byte is the
; 'parity' byte.
@label=LD_LOOP
*$05A9 EX AF,AF'     ; Fetch the flags.
 $05AA JR NZ,$05B3   ; Jump forward only when handling the first byte.
 $05AC JR NC,$05BD   ; Jump forward if verifying a tape.
 $05AE LD (IX+$00),L ; Make the actual load when required.
 $05B1 JR $05C2      ; Jump forward to load the next byte.
@label=LD_FLAG
*$05B3 RL C          ; Keep the carry flag in a safe place temporarily.
 $05B5 XOR L         ; {Return now if the type flag does not match the first
 $05B6 RET NZ        ; byte on the tape. (Carry flag reset.)}
 $05B7 LD A,C        ; {Restore the carry flag now.
 $05B8 RRA           ;
 $05B9 LD C,A        ; }
 $05BA INC DE        ; {Increase the counter to compensate for its 'decrease'
 $05BB JR $05C4      ; after the jump.}
; If a data block is being verified then the freshly loaded byte is tested
; against the original byte.
@label=LD_VERIFY
*$05BD LD A,(IX+$00) ; Fetch the original byte.
 $05C0 XOR L         ; Match it against the new byte.
 $05C1 RET NZ        ; Return if 'no match'. (Carry flag reset.)
; A new byte can now be collected from the tape.
@label=LD_NEXT
*$05C2 INC IX        ; Increase the 'destination'.
@label=LD_DEC
*$05C4 DEC DE        ; Decrease the 'counter'.
 $05C5 EX AF,AF'     ; Save the flags.
 $05C6 LD B,$B2      ; Set the timing constant.
@label=LD_MARKER
*$05C8 LD L,$01      ; Clear the 'object' register apart from a 'marker' bit.
; The following loop is used to build up a byte in the #REGl register.
@label=LD_8_BITS
*$05CA CALL $05E3    ; Find the length of the 'off' and 'on' pulses of the next
                     ; bit.
 $05CD RET NC        ; Return if the time period is exceeded. (Carry flag
                     ; reset.)
 $05CE LD A,$CB      ; {Compare the length against approx. 2,400 T states,
 $05D0 CP B          ; resetting the carry flag for a '0' and setting it for a
                     ; '1'.}
 $05D1 RL L          ; Include the new bit in the #REGl register.
 $05D3 LD B,$B0      ; Set the timing constant for the next bit.
 $05D5 JP NC,$05CA   ; Jump back whilst there are still bits to be fetched.
; The 'parity matching' byte has to be updated with each new byte.
 $05D8 LD A,H        ; {Fetch the 'parity matching' byte and include the new
 $05D9 XOR L         ; byte.}
 $05DA LD H,A        ; Save it once again.
; Passes round the loop are made until the 'counter' reaches zero. At that
; point the 'parity matching' byte should be holding zero.
 $05DB LD A,D        ; {Make a further pass if the #REGde register pair does
 $05DC OR E          ; not hold zero.
 $05DD JR NZ,$05A9   ; }
 $05DF LD A,H        ; Fetch the 'parity matching' byte.
 $05E0 CP $01        ; {Return with the carry flag set if the value is zero.
 $05E2 RET           ; (Carry flag reset if in error.)}

; THE 'LD-EDGE-2' AND 'LD-EDGE-1' SUBROUTINES
;
; Used by the routine at #R$0556.
; .
; These two subroutines form the most important part of the LOAD/VERIFY
; operation.
; .
; The subroutines are entered with a timing constant in the #REGb register, and
; the previous border colour and 'edge-type' in the #REGc register.
; .
; The subroutines return with the carry flag set if the required number of
; 'edges' have been found in the time allowed, and the change to the value in
; the #REGb register shows just how long it took to find the 'edge(s)'.
; .
; The carry flag will be reset if there is an error. The zero flag then signals
; 'BREAK pressed' by being reset, or 'time-up' by being set.
; .
; The entry point #R$05E3 is used when the length of a complete pulse is
; required and #R$05E7 is used to find the time before the next 'edge'.
;
; B Timing constant
; C Border colour (bits 0-2) and previous edge-type (bit 5)
@label=LD_EDGE_2
c$05E3 CALL $05E7    ; {In effect call #R$05E7 twice, returning in between if
 $05E6 RET NC        ; there is an error.}
; This entry point is used by the routine at #R$0556.
@label=LD_EDGE_1
@ignoreua
*$05E7 LD A,$16      ; {Wait 358 T states before entering the sampling loop.
@label=LD_DELAY
*$05E9 DEC A         ;
 $05EA JR NZ,$05E9   ;
 $05EC AND A         ; }
; The sampling loop is now entered. The value in the #REGb register is
; incremented for each pass; 'time-up' is given when #REGb reaches zero.
@label=LD_SAMPLE
*$05ED INC B         ; Count each pass.
 $05EE RET Z         ; Return carry reset and zero set if 'time-up'.
 $05EF LD A,$7F      ; {Read from port &7FFE, i.e. BREAK and EAR.
 $05F1 IN A,($FE)    ; }
 $05F3 RRA           ; Shift the byte.
 $05F4 RET NC        ; Return carry reset and zero reset if BREAK was pressed.
 $05F5 XOR C         ; {Now test the byte against the 'last edge-type'; jump
 $05F6 AND $20       ; back unless it has changed.
 $05F8 JR Z,$05ED    ; }
; A new 'edge' has been found within the time period allowed for the search. So
; change the border colour and set the carry flag.
 $05FA LD A,C        ; {Change the 'last edge-type' and border colour.
 $05FB CPL           ;
 $05FC LD C,A        ; }
 $05FD AND $07       ; Keep only the border colour.
 $05FF OR $08        ; Signal 'MIC off'.
 $0601 OUT ($FE),A   ; Change the border colour (red/cyan or blue/yellow).
 $0603 SCF           ; {Signal the successful search before returning.
 $0604 RET           ; }
@ignoreua
; Note: the #R$05E7 subroutine takes 465 T states, plus an additional 58 T
; states for each unsuccessful pass around the sampling loop.
; .
; For example, therefore, when awaiting the sync pulse (see #R$058F) allowance
; is made for ten additional passes through the sampling loop. The search is
; thereby for the next edge to be found within, roughly, 1100 T states
; (465+10*58+overhead). This will prove successful for the sync 'off' pulse
; that comes after the long 'leader pulses'.

; THE 'SAVE, LOAD, VERIFY and MERGE' COMMAND ROUTINES
;
; Used by the routine at #R$1CDB.
; .
; This entry point is used for all four commands. The value held in
; #SYSVAR(T-ADDR), however, distinguishes between the four commands. The first
; part of the following routine is concerned with the construction of the
; 'header information' in the work space.
@label=SAVE_ETC
c$0605 POP AF          ; Drop the address - #R$1B52.
 $0606 LD A,($5C74)    ; {Reduce #SYSVAR(T-ADDR-lo) by &E0, giving &00 for
 $0609 SUB $E0         ; SAVE, &01 for LOAD, &02 for VERIFY and &03 for MERGE.
 $060B LD ($5C74),A    ; }
 $060E CALL $1C8C      ; Pass the parameters of the 'name' to the calculator
                       ; stack.
 $0611 CALL $2530      ; {Jump forward if checking syntax.
 $0614 JR Z,$0652      ; }
@keep
 $0616 LD BC,$0011     ; {Allow seventeen locations for the header of a SAVE
 $0619 LD A,($5C74)    ; (#SYSVAR(T-ADDR-lo)=&00) but thirty four for the other
 $061C AND A           ; commands.
 $061D JR Z,$0621      ;
 $061F LD C,$22        ; }
@label=SA_SPACE
*$0621 RST $30         ; The required amount of space is made in the work
                       ; space.
 $0622 PUSH DE         ; {Copy the start address to the #REGix register pair.
 $0623 POP IX          ; }
 $0625 LD B,$0B        ; {A program name can have up to ten characters but
 $0627 LD A," "        ; first enter eleven space characters into the prepared
@label=SA_BLANK
*$0629 LD (DE),A       ; area.
 $062A INC DE          ;
 $062B DJNZ $0629      ; }
 $062D LD (IX+$01),$FF ; A null name is &FF only.
 $0631 CALL $2BF1      ; The parameters of the name are fetched and its length
                       ; is tested.
 $0634 LD HL,$FFF6     ; This is '-10'.
 $0637 DEC BC          ; {In effect jump forward if the length of the name is
 $0638 ADD HL,BC       ; not too long (i.e. no more than ten characters).
 $0639 INC BC          ;
 $063A JR NC,$064B     ; }
 $063C LD A,($5C74)    ; {But allow for the LOADing, VERIFYing and MERGEing of
 $063F AND A           ; programs (#SYSVAR(T-ADDR-lo)>&00) with 'null' names or
 $0640 JR NZ,$0644     ; extra long names.}
; Report F - Invalid file name.
 $0642 RST $08         ; {Call the error handling routine.
 $0643 DEFB $0E        ; }
; Continue to handle the name of the program.
@label=SA_NULL
*$0644 LD A,B          ; {Jump forward if the name has a 'null' length.
 $0645 OR C            ;
 $0646 JR Z,$0652      ; }
@keep
 $0648 LD BC,$000A     ; But truncate longer names.
; The name is now transferred to the work space (second location onwards).
@label=SA_NAME
*$064B PUSH IX         ; {Copy the start address to the #REGhl register pair.
 $064D POP HL          ; }
 $064E INC HL          ; Step to the second location.
 $064F EX DE,HL        ; {Switch the pointers over and copy the name.
 $0650 LDIR            ; }
; The many different parameters, if any, that follow the command are now
; considered. Start by handling 'xxx "name" DATA'.
@label=SA_DATA
*$0652 RST $18         ; {Is the present code the token 'DATA'?
 $0653 CP $E4          ; }
 $0655 JR NZ,$06A0     ; Jump if not.
 $0657 LD A,($5C74)    ; {However it is not possible to have 'MERGE name DATA'
 $065A CP $03          ; (#SYSVAR(T-ADDR-lo)=&03).
 $065C JP Z,$1C8A      ; }
 $065F RST $20         ; Advance #SYSVAR(CH-ADD).
 $0660 CALL $28B2      ; Look in the variables area for the array.
 $0663 SET 7,C         ; Set bit 7 of the array's name.
 $0665 JR NC,$0672     ; Jump if handling an existing array.
@keep
 $0667 LD HL,$0000     ; Signal 'using a new array'.
 $066A LD A,($5C74)    ; {Consider the value in #SYSVAR(T-ADDR-lo) and give an
 $066D DEC A           ; error if trying to SAVE or VERIFY a new array.
 $066E JR Z,$0685      ; }
; Report 2 - Variable not found.
 $0670 RST $08         ; {Call the error handling routine.
 $0671 DEFB $01        ; }
; Continue with the handling of an existing array.
@label=SA_V_OLD
*$0672 JP NZ,$1C8A     ; Note: #BUG#savingASimpleString(this fails to exclude
                       ; simple strings).
 $0675 CALL $2530      ; {Jump forward if checking syntax.
 $0678 JR Z,$0692      ; }
 $067A INC HL          ; Point to the 'low length' of the variable.
 $067B LD A,(HL)       ; {The low length byte goes into the work space,
 $067C LD (IX+$0B),A   ; followed by the high length byte.
 $067F INC HL          ;
 $0680 LD A,(HL)       ;
 $0681 LD (IX+$0C),A   ; }
 $0684 INC HL          ; Step past the length bytes.
; The next part is common to both 'old' and 'new' arrays. Note: syntax path
; error.
@label=SA_V_NEW
*$0685 LD (IX+$0E),C   ; Copy the array's name.
 $0688 LD A,$01        ; Assume an array of numbers.
 $068A BIT 6,C         ; {Jump if it is so.
 $068C JR Z,$068F      ; }
 $068E INC A           ; It is an array of characters.
@label=SA_V_TYPE
*$068F LD (IX+$00),A   ; Save the 'type' in the first location of the header
                       ; area.
; The last part of the statement is examined before joining the other pathways.
@label=SA_DATA_1
*$0692 EX DE,HL        ; Save the pointer in #REGde.
 $0693 RST $20         ; {Is the next character a ')'?
 $0694 CP ")"          ; }
 $0696 JR NZ,$0672     ; Give report C if it is not.
 $0698 RST $20         ; Advance #SYSVAR(CH-ADD).
 $0699 CALL $1BEE      ; Move on to the next statement if checking syntax.
 $069C EX DE,HL        ; {Return the pointer to the #REGhl register pair before
 $069D JP $075A        ; jumping forward. (The pointer indicates the start of
                       ; an existing array's contents.)}
; Now consider 'SCREEN$'.
@label=SA_SCR
*$06A0 CP $AA          ; Is the present code the token SCREEN$?
 $06A2 JR NZ,$06C3     ; Jump if not.
 $06A4 LD A,($5C74)    ; {However it is not possible to have 'MERGE name
 $06A7 CP $03          ; SCREEN$' (#SYSVAR(T-ADDR-lo)=&03).
 $06A9 JP Z,$1C8A      ; }
 $06AC RST $20         ; Advance #SYSVAR(CH-ADD).
 $06AD CALL $1BEE      ; Move on to the next statement if checking syntax.
@ignoreua
 $06B0 LD (IX+$0B),$00 ; {The display area and the attribute area occupy &1B00
 $06B4 LD (IX+$0C),$1B ; locations and these locations start at &4000; these
 $06B8 LD HL,$4000     ; details are passed to the header area in the work
 $06BB LD (IX+$0D),L   ; space.
 $06BE LD (IX+$0E),H   ; }
 $06C1 JR $0710        ; Jump forward.
; Now consider 'CODE'.
@label=SA_CODE
*$06C3 CP $AF          ; Is the present code the token 'CODE'?
 $06C5 JR NZ,$0716     ; Jump if not.
 $06C7 LD A,($5C74)    ; {However it is not possible to have 'MERGE name CODE'
 $06CA CP $03          ; (#SYSVAR(T-ADDR-lo)=&03).
 $06CC JP Z,$1C8A      ; }
 $06CF RST $20         ; Advance #SYSVAR(CH-ADD).
 $06D0 CALL $2048      ; {Jump forward if the statement has not finished.
 $06D3 JR NZ,$06E1     ; }
 $06D5 LD A,($5C74)    ; {However it is not possible to have 'SAVE name CODE'
 $06D8 AND A           ; (#SYSVAR(T-ADDR-lo)=&00) by itself.
 $06D9 JP Z,$1C8A      ; }
 $06DC CALL $1CE6      ; Put a zero on the calculator stack - for the 'start'.
 $06DF JR $06F0        ; Jump forward.
; Look for a 'starting address'.
@label=SA_CODE_1
*$06E1 CALL $1C82      ; Fetch the first number.
 $06E4 RST $18         ; {Is the present character a comma?
 $06E5 CP ","          ; }
 $06E7 JR Z,$06F5      ; Jump if it is - the number was a 'starting address'.
 $06E9 LD A,($5C74)    ; {However refuse 'SAVE name CODE' that does not have a
 $06EC AND A           ; 'start' and a 'length' (#SYSVAR(T-ADDR-lo)=&00).
 $06ED JP Z,$1C8A      ; }
@label=SA_CODE_2
*$06F0 CALL $1CE6      ; Put a zero on the calculator stack - for the 'length'.
 $06F3 JR $06F9        ; Jump forward.
; Fetch the 'length' as it was specified.
@label=SA_CODE_3
*$06F5 RST $20         ; Advance #SYSVAR(CH-ADD).
 $06F6 CALL $1C82      ; Fetch the 'length'.
; The parameters are now stored in the header area of the work space.
@label=SA_CODE_4
*$06F9 CALL $1BEE      ; But move on to the next statement now if checking
                       ; syntax.
 $06FC CALL $1E99      ; {Compress the 'length' into the #REGbc register pair
 $06FF LD (IX+$0B),C   ; and store it.
 $0702 LD (IX+$0C),B   ; }
 $0705 CALL $1E99      ; {Compress the 'starting address' into the #REGbc
 $0708 LD (IX+$0D),C   ; register pair and store it.
 $070B LD (IX+$0E),B   ; }
 $070E LD H,B          ; {Transfer the 'pointer' to the #REGhl register pair as
 $070F LD L,C          ; usual.}
; 'SCREEN$' and 'CODE' are both of type 3.
@label=SA_TYPE_3
*$0710 LD (IX+$00),$03 ; Enter the 'type' number.
 $0714 JR $075A        ; Rejoin the other pathways.
; Now consider 'LINE' and 'no further parameters'.
@label=SA_LINE
*$0716 CP $CA          ; Is the present code the token 'LINE'?
 $0718 JR Z,$0723      ; Jump if it is.
 $071A CALL $1BEE      ; Move on to the next statement if checking syntax.
 $071D LD (IX+$0E),$80 ; When there are no further parameters, &80 is entered.
 $0721 JR $073A        ; Jump forward.
; Fetch the 'line number' that must follow 'LINE'.
@label=SA_LINE_1
*$0723 LD A,($5C74)    ; {However only allow 'SAVE name LINE number'
 $0726 AND A           ; (#SYSVAR(T-ADDR-lo)=&00).
 $0727 JP NZ,$1C8A     ; }
 $072A RST $20         ; Advance #SYSVAR(CH-ADD).
 $072B CALL $1C82      ; Pass the number to the calculator stack.
 $072E CALL $1BEE      ; Move on to the next statement if checking syntax.
 $0731 CALL $1E99      ; {Compress the 'line number' into the #REGbc register
 $0734 LD (IX+$0D),C   ; pair and store it.
 $0737 LD (IX+$0E),B   ; }
; 'LINE' and 'no further parameters' are both of type 0.
@label=SA_TYPE_0
*$073A LD (IX+$00),$00 ; Enter the 'type' number.
; The parameters that describe the program, and its variables, are found and
; stored in the header area of the work space.
 $073E LD HL,($5C59)   ; The pointer to the end of the variables area
                       ; (#SYSVAR(E-LINE)).
 $0741 LD DE,($5C53)   ; The pointer to the start of the BASIC program
                       ; (#SYSVAR(PROG)).
 $0745 SCF             ; {Now perform the subtraction to find the length of the
 $0746 SBC HL,DE       ; 'program + variables'; store the result.
 $0748 LD (IX+$0B),L   ;
 $074B LD (IX+$0C),H   ; }
 $074E LD HL,($5C4B)   ; {Repeat the operation but this time storing the length
 $0751 SBC HL,DE       ; of the 'program' only (#SYSVAR(VARS)-#SYSVAR(PROG)).
 $0753 LD (IX+$0F),L   ;
 $0756 LD (IX+$10),H   ; }
 $0759 EX DE,HL        ; Transfer the 'pointer' to the #REGhl register pair as
                       ; usual.
; In all cases the header information has now been prepared.
; .
; #LIST
; { The location '#ix+$00' holds the type number. }
; { Locations '#ix+$01 to #ix+$0A' hold the name (&FF in '#ix+$01' if null). }
; { Locations '#ix+$0B and #ix+$0C' hold the number of bytes that are to be
; found in the 'data block'. }
; { Locations '#ix+$0D to #ix+$10' hold a variety of parameters whose exact
; interpretation depends on the 'type'. }
; LIST#
; .
; The routine continues with the first task being to separate SAVE from LOAD,
; VERIFY and MERGE.
@label=SA_ALL
*$075A LD A,($5C74)    ; {Jump forward when handling a SAVE command
 $075D AND A           ; (#SYSVAR(T-ADDR-lo)=&00).
 $075E JP Z,$0970      ; }
; In the case of a LOAD, VERIFY or MERGE command the first seventeen bytes of
; the 'header area' in the work space hold the prepared information, as
; detailed above; and it is now time to fetch a 'header' from the tape.
 $0761 PUSH HL         ; Save the 'destination' pointer.
@keep
 $0762 LD BC,$0011     ; {Form in the #REGix register pair the base address of
 $0765 ADD IX,BC       ; the 'second header area'.}
; Now enter a loop, leaving it only when a 'header' has been LOADed.
@label=LD_LOOK_H
*$0767 PUSH IX         ; Make a copy of the base address.
@keep
 $0769 LD DE,$0011     ; LOAD seventeen bytes.
 $076C XOR A           ; Signal 'header'.
 $076D SCF             ; Signal 'LOAD'.
 $076E CALL $0556      ; Now look for a header.
 $0771 POP IX          ; Retrieve the base address.
 $0773 JR NC,$0767     ; Go round the loop until successful.
; The new 'header' is now displayed on the screen but the routine will only
; proceed if the 'new' header matches the 'old' header.
 $0775 LD A,$FE        ; {Ensure that channel 'S' is open.
 $0777 CALL $1601      ; }
 $077A LD (IY+$52),$03 ; Set the scroll counter (#SYSVAR(SCR-CT)).
 $077E LD C,$80        ; Signal 'names do not match'.
 $0780 LD A,(IX+$00)   ; {Compare the 'new' type against the 'old' type.
 $0783 CP (IX-$11)     ; }
 $0786 JR NZ,$078A     ; Jump if the 'types' do not match.
 $0788 LD C,$F6        ; But if they do, signal 'ten characters are to match'.
@label=LD_TYPE
*$078A CP $04          ; {Clearly the 'header' is nonsense if 'type 4 or more'.
 $078C JR NC,$0767     ; }
; The appropriate message - 'Program: ', 'Number array: ', 'Character array: '
; or 'Bytes: ' is printed.
@keep=$01
@ssub=LD DE,$09C1-$01
 $078E LD DE,$09C0     ; The base address of the #R$09C1(message block).
 $0791 PUSH BC         ; {Save the #REGc register whilst the appropriate
 $0792 CALL $0C0A      ; message is printed.
 $0795 POP BC          ; }
; The 'new name' is printed and as this is done the 'old' and the 'new' names
; are compared.
 $0796 PUSH IX         ; {Make the #REGde register pair point to the 'new name'
 $0798 POP DE          ; and the #REGhl register pair to the 'old name'.
 $0799 LD HL,$FFF0     ;
 $079C ADD HL,DE       ; }
 $079D LD B,$0A        ; Ten characters are to be considered.
 $079F LD A,(HL)       ; {Jump forward if the match is to be against an actual
 $07A0 INC A           ; name.
 $07A1 JR NZ,$07A6     ; }
 $07A3 LD A,C          ; {But if the 'old name' is 'null' then signal 'ten
 $07A4 ADD A,B         ; characters already match'.
 $07A5 LD C,A          ; }
; A loop is entered to print the characters of the 'new name'. The name will be
; accepted if the 'counter' reaches zero, at least.
@label=LD_NAME
*$07A6 INC DE          ; {Consider each character of the 'new name' in turn.
 $07A7 LD A,(DE)       ; }
 $07A8 CP (HL)         ; {Match it against the appropriate character of the
 $07A9 INC HL          ; 'old name'.}
 $07AA JR NZ,$07AD     ; {Do not count it if it does not does not match.
 $07AC INC C           ; }
@label=LD_CH_PR
*$07AD RST $10         ; Print the 'new' character.
 $07AE DJNZ $07A6      ; Loop for ten characters.
 $07B0 BIT 7,C         ; {Accept the name only if the counter has reached zero.
 $07B2 JR NZ,$0767     ; }
 $07B4 LD A,$0D        ; {Follow the 'new name' with a 'carriage return'.
 $07B6 RST $10         ; }
; The correct header has been found and the time has come to consider the three
; commands LOAD, VERIFY, and MERGE separately.
 $07B7 POP HL          ; Fetch the pointer.
 $07B8 LD A,(IX+$00)   ; {'SCREEN$' and 'CODE' are handled with VERIFY.
 $07BB CP $03          ;
 $07BD JR Z,$07CB      ; }
 $07BF LD A,($5C74)    ; {Jump forward if using a LOAD command
 $07C2 DEC A           ; (#SYSVAR(T-ADDR-lo)=&01).
 $07C3 JP Z,$0808      ; }
 $07C6 CP $02          ; {Jump forward if using a MERGE command; continue into
 $07C8 JP Z,$08B6      ; #R$07CB with a VERIFY command.}

; THE 'VERIFY' CONTROL ROUTINE
;
; Used by the routine at #R$0605.
; .
; The verification process involves the loading of a block of data, a byte at a
; time, but the bytes are not stored - only checked. This routine is also used
; to load blocks of data that have been described with 'SCREEN$' or 'CODE'.
;
; HL Block start address
@label=VR_CONTRL
c$07CB PUSH HL       ; Save the 'pointer'.
 $07CC LD L,(IX-$06) ; {Fetch the 'number of bytes' as described in the 'old'
 $07CF LD H,(IX-$05) ; header.}
 $07D2 LD E,(IX+$0B) ; {Fetch also the number from the 'new' header.
 $07D5 LD D,(IX+$0C) ; }
 $07D8 LD A,H        ; {Jump forward if the 'length' is unspecified, e.g. 'LOAD
 $07D9 OR L          ; name CODE' only.
 $07DA JR Z,$07E9    ; }
 $07DC SBC HL,DE     ; {Give report R if attempting to load a larger block than
 $07DE JR C,$0806    ; has been requested.}
 $07E0 JR Z,$07E9    ; Accept equal 'lengths'.
 $07E2 LD A,(IX+$00) ; {Also give report R if trying to verify blocks that are
 $07E5 CP $03        ; of unequal size. ('Old length' greater than 'new
 $07E7 JR NZ,$0806   ; length'.)}
; The routine continues by considering the 'destination pointer'.
@label=VR_CONT_1
*$07E9 POP HL        ; Fetch the 'pointer', i.e. the 'start'.
 $07EA LD A,H        ; {This 'pointer' will be used unless it is zero, in which
 $07EB OR L          ; case the 'start' found in the 'new' header will be used
 $07EC JR NZ,$07F4   ; instead.
 $07EE LD L,(IX+$0D) ;
 $07F1 LD H,(IX+$0E) ; }
; The verify/load flag is now considered and the actual load made.
@label=VR_CONT_2
*$07F4 PUSH HL       ; {Move the 'pointer' to the #REGix register pair.
 $07F5 POP IX        ; }
 $07F7 LD A,($5C74)  ; {Jump forward unless using the VERIFY command
 $07FA CP $02        ; (#SYSVAR(T-ADDR-lo)=&02), with the carry flag signalling
 $07FC SCF           ; 'LOAD'.
 $07FD JR NZ,$0800   ; }
 $07FF AND A         ; Signal 'VERIFY'.
@label=VR_CONT_3
*$0800 LD A,$FF      ; Signal 'accept data block only' before loading the
                     ; block.
; This routine continues into #R$0802.

; THE 'LOAD A DATA BLOCK' SUBROUTINE
;
; Used by the routines at #R$0808 and #R$08B6.
; .
; The routine at #R$07CB continues here.
; .
; This subroutine is common to all the tape loading routines. In the case of
; LOAD and VERIFY it acts as a full return from the cassette handling routines
; but in the case of MERGE the data block has yet to be merged.
;
; A &FF
; F Carry flag set if loading, reset if verifying
; DE Block length
; IX Start address
@label=LD_BLOCK
c$0802 CALL $0556    ; Load/verify a data block.
 $0805 RET C         ; Return unless an error.
; This entry point is used by the routine at #R$07CB.
; .
; Report R - Tape loading error.
@label=REPORT_R
*$0806 RST $08       ; {Call the error handling routine.
 $0807 DEFB $1A      ; }

; THE 'LOAD' CONTROL ROUTINE
;
; Used by the routine at #R$0605.
; .
; This routine controls the LOADing of a BASIC program, and its variables, or
; an array.
;
; HL Destination address (#SYSVAR(PROG), or the address of the array, or &0000
; .  for a new array)
; IX Address of the header loaded from tape
@label=LD_CONTRL
c$0808 LD E,(IX+$0B)   ; {Fetch the 'number of bytes' as given in the 'new
 $080B LD D,(IX+$0C)   ; header'.}
 $080E PUSH HL         ; Save the 'destination pointer'.
 $080F LD A,H          ; {Jump forward unless trying to LOAD a previously
 $0810 OR L            ; undeclared array.
 $0811 JR NZ,$0819     ; }
 $0813 INC DE          ; {Add three bytes to the length - for the name, the low
 $0814 INC DE          ; length and the high length of a new variable.
 $0815 INC DE          ;
 $0816 EX DE,HL        ; }
 $0817 JR $0825        ; Jump forward.
; Consider now if there is enough room in memory for the new data block.
@label=LD_CONT_1
*$0819 LD L,(IX-$06)   ; {Fetch the size of the existing 'program+variables or
 $081C LD H,(IX-$05)   ; array'.
 $081F EX DE,HL        ; }
 $0820 SCF             ; {Jump forward if no extra room will be required
 $0821 SBC HL,DE       ; (taking into account the reclaiming of the presently
 $0823 JR C,$082E      ; used memory).}
; Make the actual test for room.
@keep
@label=LD_CONT_2
*$0825 LD DE,$0005     ; {Allow an overhead of five bytes.
 $0828 ADD HL,DE       ; }
 $0829 LD B,H          ; {Move the result to the #REGbc register pair and make
 $082A LD C,L          ; the test.
 $082B CALL $1F05      ; }
; Now deal with the LOADing of arrays.
@label=LD_DATA
*$082E POP HL          ; Fetch the 'pointer' anew.
 $082F LD A,(IX+$00)   ; {Jump forward if LOADing a BASIC program.
 $0832 AND A           ;
 $0833 JR Z,$0873      ; }
 $0835 LD A,H          ; {Jump forward if LOADing a new array.
 $0836 OR L            ;
 $0837 JR Z,$084C      ; }
 $0839 DEC HL          ; {Fetch the 'length' of the existing array by
 $083A LD B,(HL)       ; collecting the length bytes from the variables area.
 $083B DEC HL          ;
 $083C LD C,(HL)       ; }
 $083D DEC HL          ; Point to its old name.
 $083E INC BC          ; {Add three bytes to the length - one for the name and
 $083F INC BC          ; two for the 'length'.
 $0840 INC BC          ; }
 $0841 LD ($5C5F),IX   ; {Save the #REGix register pair temporarily (in
 $0845 CALL $19E8      ; #SYSVAR(X-PTR)) whilst the old array is reclaimed.
 $0848 LD IX,($5C5F)   ; }
; Space is now made available for the new array - at the end of the present
; variables area.
@label=LD_DATA_1
*$084C LD HL,($5C59)   ; {Find the pointer to the end-marker of the variables
 $084F DEC HL          ; area - the '&80-byte' (#SYSVAR(E-LINE)).}
 $0850 LD C,(IX+$0B)   ; {Fetch the 'length' of the new array.
 $0853 LD B,(IX+$0C)   ; }
 $0856 PUSH BC         ; Save this 'length'.
 $0857 INC BC          ; {Add three bytes - one for the name and two for the
 $0858 INC BC          ; 'length'.
 $0859 INC BC          ; }
 $085A LD A,(IX-$03)   ; '#REGix+0E' of the old header gives the name of the
                       ; array.
 $085D PUSH AF         ; {The name is saved whilst the appropriate amount of
 $085E CALL $1655      ; room is made available. In effect #REGbc spaces before
 $0861 INC HL          ; the 'new &80-byte'.
 $0862 POP AF          ; }
 $0863 LD (HL),A       ; The name is entered.
 $0864 POP DE          ; {The 'length' is fetched and its two bytes are also
 $0865 INC HL          ; entered.
 $0866 LD (HL),E       ;
 $0867 INC HL          ;
 $0868 LD (HL),D       ; }
 $0869 INC HL          ; #REGhl now points to the first location that is to be
                       ; filled with data from the tape.
 $086A PUSH HL         ; {This address is moved to the #REGix register pair;
 $086B POP IX          ; the carry flag set; 'data block' is signalled; and the
 $086D SCF             ; block LOADed.
 $086E LD A,$FF        ;
 $0870 JP $0802        ; }
; Now deal with the LOADing of a BASIC program and its variables.
@label=LD_PROG
*$0873 EX DE,HL        ; Save the 'destination pointer'.
 $0874 LD HL,($5C59)   ; {Find the address of the end marker of the current
 $0877 DEC HL          ; variables area - the '&80-byte' (#SYSVAR(E-LINE)).}
 $0878 LD ($5C5F),IX   ; Save #REGix temporarily (in #SYSVAR(X-PTR)).
 $087C LD C,(IX+$0B)   ; {Fetch the 'length' of the new data block.
 $087F LD B,(IX+$0C)   ; }
 $0882 PUSH BC         ; {Keep a copy of the 'length' whilst the present
 $0883 CALL $19E5      ; program and variables areas are reclaimed.
 $0886 POP BC          ; }
 $0887 PUSH HL         ; {Save the pointer to the program area and the length
 $0888 PUSH BC         ; of the new data block.}
 $0889 CALL $1655      ; Make sufficient room available for the new program and
                       ; its variables.
 $088C LD IX,($5C5F)   ; Restore the #REGix register pair from #SYSVAR(X-PTR).
 $0890 INC HL          ; {The system variable #SYSVAR(VARS) has also to be set
 $0891 LD C,(IX+$0F)   ; for the new program.
 $0894 LD B,(IX+$10)   ;
 $0897 ADD HL,BC       ;
 $0898 LD ($5C4B),HL   ; }
 $089B LD H,(IX+$0E)   ; {If a line number was specified then it too has to be
 $089E LD A,H          ; considered.
 $089F AND $C0         ; }
 $08A1 JR NZ,$08AD     ; {Jump if 'no number'; otherwise set #SYSVAR(NEWPPC)
 $08A3 LD L,(IX+$0D)   ; and #SYSVAR(NSPPC).
 $08A6 LD ($5C42),HL   ;
 $08A9 LD (IY+$0A),$00 ; }
; The data block can now be LOADed.
@label=LD_PROG_1
*$08AD POP DE          ; Fetch the 'length'.
 $08AE POP IX          ; Fetch the 'start'.
 $08B0 SCF             ; Signal 'LOAD'.
 $08B1 LD A,$FF        ; Signal 'data block' only.
 $08B3 JP $0802        ; Now LOAD it.

; THE 'MERGE' CONTROL ROUTINE
;
; Used by the routine at #R$0605.
; .
; There are three main parts to this routine.
; .
; #LIST
; { Load the data block into the work space. }
; { Merge the lines of the new program into the old program. }
; { Merge the new variables into the old variables. }
; LIST#
; .
; Start therefore with the loading of the data block.
;
; IX Address of the header loaded from tape
@label=ME_CONTRL
c$08B6 LD C,(IX+$0B) ; {Fetch the 'length' of the data block.
 $08B9 LD B,(IX+$0C) ; }
 $08BC PUSH BC       ; Save a copy of the 'length'.
 $08BD INC BC        ; {Now make 'length+1' locations available in the work
 $08BE RST $30       ; space.}
 $08BF LD (HL),$80   ; Place an end marker in the extra location.
 $08C1 EX DE,HL      ; Move the 'start' pointer to the #REGhl register pair.
 $08C2 POP DE        ; Fetch the original 'length'.
 $08C3 PUSH HL       ; Save a copy of the 'start'.
 $08C4 PUSH HL       ; {Now set the #REGix register pair for the actual load.
 $08C5 POP IX        ; }
 $08C7 SCF           ; Signal 'LOAD'.
 $08C8 LD A,$FF      ; Signal 'data block only'.
 $08CA CALL $0802    ; Load the data block.
; The lines of the new program are merged with the lines of the old program.
 $08CD POP HL        ; Fetch the 'start' of the new program.
 $08CE LD DE,($5C53) ; Initialise #REGde to the 'start' of the old program
                     ; (#SYSVAR(PROG)).
; Enter a loop to deal with the lines of the new program.
@label=ME_NEW_LP
*$08D2 LD A,(HL)     ; {Fetch a line number and test it.
 $08D3 AND $C0       ; }
 $08D5 JR NZ,$08F0   ; Jump when finished with all the lines.
; Now enter an inner loop to deal with the lines of the old program.
@label=ME_OLD_LP
*$08D7 LD A,(DE)     ; {Fetch the high line number byte and compare it. Jump
 $08D8 INC DE        ; forward if it does not match but in any case advance
 $08D9 CP (HL)       ; both pointers.
 $08DA INC HL        ;
 $08DB JR NZ,$08DF   ; }
 $08DD LD A,(DE)     ; {Repeat the comparison for the low line number bytes.
 $08DE CP (HL)       ; }
@label=ME_OLD_L1
*$08DF DEC DE        ; {Now retreat the pointers.
 $08E0 DEC HL        ; }
 $08E1 JR NC,$08EB   ; Jump forward if the correct place has been found for a
                     ; line of the new program.
 $08E3 PUSH HL       ; {Otherwise find the address of the start of the next old
 $08E4 EX DE,HL      ; line.
 $08E5 CALL $19B8    ;
 $08E8 POP HL        ; }
 $08E9 JR $08D7      ; Go round the loop for each of the 'old lines'.
@label=ME_NEW_L2
*$08EB CALL $092C    ; {Enter the 'new line' and go round the outer loop again.
 $08EE JR $08D2      ; }
; In a similar manner the variables of the new program are merged with the
; variables of the old program.
@label=ME_VAR_LP
*$08F0 LD A,(HL)     ; {Fetch each variable name in turn and test it.
 $08F1 LD C,A        ; }
 $08F2 CP $80        ; {Return when all the variables have been considered.
 $08F4 RET Z         ; }
 $08F5 PUSH HL       ; Save the current new pointer.
 $08F6 LD HL,($5C4B) ; Fetch #SYSVAR(VARS) (for the old program).
; Now enter an inner loop to search the existing variables area.
@label=ME_OLD_VP
*$08F9 LD A,(HL)     ; {Fetch each variable name and test it.
 $08FA CP $80        ; }
 $08FC JR Z,$0923    ; Jump forward once the end marker is found. (Make an
                     ; 'addition'.)
 $08FE CP C          ; Compare the names (first bytes).
 $08FF JR Z,$0909    ; Jump forward to consider it further, returning here if
                     ; it proves not to match fully.
@label=ME_OLD_V1
*$0901 PUSH BC       ; {Save the new variable's name whilst the next 'old
 $0902 CALL $19B8    ; variable' is located.
 $0905 POP BC        ; }
 $0906 EX DE,HL      ; {Restore the pointer to the #REGde register pair and go
 $0907 JR $08F9      ; round the loop again.}
; The old and new variables match with respect to their first bytes but
; variables with long names will need to be matched fully.
@label=ME_OLD_V2
*$0909 AND $E0       ; Consider bits 7, 6 and 5 only.
 $090B CP $A0        ; {Accept all the variable types except 'long named
 $090D JR NZ,$0921   ; variables'.}
 $090F POP DE        ; {Make #REGde point to the first character of the 'new
 $0910 PUSH DE       ; name'.}
 $0911 PUSH HL       ; Save the pointer to the 'old name'.
; Enter a loop to compare the letters of the long names.
@label=ME_OLD_V3
*$0912 INC HL        ; {Update both the 'old' and the 'new' pointers.
 $0913 INC DE        ; }
 $0914 LD A,(DE)     ; {Compare the two letters.
 $0915 CP (HL)       ; }
 $0916 JR NZ,$091E   ; Jump forward if the match fails.
 $0918 RLA           ; {Go round the loop until the 'last character' is found.
 $0919 JR NC,$0912   ; }
 $091B POP HL        ; {Fetch the pointer to the start of the 'old' name and
 $091C JR $0921      ; jump forward - successful.}
@label=ME_OLD_V4
*$091E POP HL        ; {Fetch the pointer and jump back - unsuccessful.
 $091F JR $0901      ; }
; Come here if the match was found.
@label=ME_VAR_L1
*$0921 LD A,$FF      ; Signal 'replace' variable.
; And here if not. (#REGa holds &80 - variable to be 'added'.)
@label=ME_VAR_L2
*$0923 POP DE        ; Fetch pointer to 'new' name.
 $0924 EX DE,HL      ; Switch over the registers.
 $0925 INC A         ; The zero flag is to be set if there is to be a
                     ; 'replacement', reset for an 'addition'.
 $0926 SCF           ; Signal 'handling variables'.
 $0927 CALL $092C    ; Now make the entry.
 $092A JR $08F0      ; Go round the loop to consider the next new variable.

; THE 'MERGE A LINE OR A VARIABLE' SUBROUTINE
;
; Used by the routine at #R$08B6.
;
;   DE Destination address of the new line/variable
;   HL Address of the new line/variable to MERGE
;   F Carry flag: MERGE a BASIC line (reset) or a variable (set)
;   F Zero flag: add (reset) or replace (set) the line/variable
; O:DE Address of the next line/variable in the existing program
; O:HL Address of the next new line/variable to MERGE
@label=ME_ENTER
c$092C JR NZ,$093E   ; Jump if handling an 'addition'.
 $092E EX AF,AF'     ; Save the flags.
 $092F LD ($5C5F),HL ; {Save the 'new' pointer (in #SYSVAR(X-PTR)) whilst the
 $0932 EX DE,HL      ; 'old' line or variable is reclaimed.
 $0933 CALL $19B8    ;
 $0936 CALL $19E8    ;
 $0939 EX DE,HL      ;
 $093A LD HL,($5C5F) ; }
 $093D EX AF,AF'     ; Restore the flags.
; The new entry can now be made.
@label=ME_ENT_1
*$093E EX AF,AF'     ; Save the flags.
 $093F PUSH DE       ; Make a copy of the 'destination' pointer.
 $0940 CALL $19B8    ; Find the length of the 'new' variable/line.
 $0943 LD ($5C5F),HL ; Save the pointer to the 'new' variable/line (in
                     ; #SYSVAR(X-PTR)).
 $0946 LD HL,($5C53) ; Fetch #SYSVAR(PROG) - to avoid corruption.
 $0949 EX (SP),HL    ; Save #SYSVAR(PROG) on the stack and fetch the 'new'
                     ; pointer.
 $094A PUSH BC       ; Save the length.
 $094B EX AF,AF'     ; Retrieve the flags.
 $094C JR C,$0955    ; Jump forward if adding a new variable.
 $094E DEC HL        ; A new line is added before the 'destination' location.
 $094F CALL $1655    ; Make the room for the new line.
 $0952 INC HL        ;
 $0953 JR $0958      ; Jump forward.
@label=ME_ENT_2
*$0955 CALL $1655    ; Make the room for the new variable.
@label=ME_ENT_3
*$0958 INC HL        ; Point to the first new location.
 $0959 POP BC        ; Retrieve the length.
 $095A POP DE        ; {Retrieve #SYSVAR(PROG) and store it in its correct
 $095B LD ($5C53),DE ; place.}
 $095F LD DE,($5C5F) ; Also fetch the 'new' pointer (from #SYSVAR(X-PTR)).
 $0963 PUSH BC       ; {Again save the length and the 'new' pointer.
 $0964 PUSH DE       ; }
 $0965 EX DE,HL      ; {Switch the pointers and copy the 'new' variable/line
 $0966 LDIR          ; into the room made for it.}
; The 'new' variable/line has now to be removed from the work space.
 $0968 POP HL        ; Fetch the 'new' pointer.
 $0969 POP BC        ; Fetch the length.
 $096A PUSH DE       ; Save the 'old' pointer. (Points to the location after
                     ; the 'added' variable/line.)
 $096B CALL $19E8    ; Remove the variable/line from the work space.
 $096E POP DE        ; {Return with the 'old' pointer in the #REGde register
 $096F RET           ; pair.}

; THE 'SAVE' CONTROL ROUTINE
;
; Used by the routine at #R$0605.
; .
; The operation of saving a program or a block of data is very straightforward.
;
; HL Data block start address
; IX Header start address
@label=SA_CONTRL
c$0970 PUSH HL        ; Save the 'pointer'.
 $0971 LD A,$FD       ; {Ensure that channel 'K' is open.
 $0973 CALL $1601     ; }
 $0976 XOR A          ; Signal 'first message'.
 $0977 LD DE,$09A1    ; {Print the message 'Start tape, then press any key.'
 $097A CALL $0C0A     ; (see #R$09A1).}
 $097D SET 5,(IY+$02) ; Signal 'screen will require to be cleared' (set bit 5
                      ; of #SYSVAR(TV-FLAG)).
 $0981 CALL $15D4     ; Wait for a key to be pressed.
; Upon receipt of a keystroke the 'header' is saved.
 $0984 PUSH IX        ; Save the base address of the 'header' on the machine
                      ; stack.
@keep
 $0986 LD DE,$0011    ; Seventeen bytes are to be saved.
 $0989 XOR A          ; Signal 'it is a header'.
 $098A CALL $04C2     ; Send the 'header', with a leading 'type' byte and a
                      ; trailing 'parity' byte.
; There follows a short delay before the program/data block is saved.
 $098D POP IX         ; Retrieve the pointer to the 'header'.
 $098F LD B,$32       ; {The delay is for fifty interrupts, i.e. one second.
@label=SA_1_SEC
*$0991 HALT           ;
 $0992 DJNZ $0991     ; }
 $0994 LD E,(IX+$0B)  ; {Fetch the length of the data block that is to be
 $0997 LD D,(IX+$0C)  ; saved.}
 $099A LD A,$FF       ; Signal 'data block'.
 $099C POP IX         ; {Fetch the 'start of block pointer' and save the block.
 $099E JP $04C2       ; }

; THE CASSETTE MESSAGES
;
; Used by the routines at #R$0605 and #R$0970.
; .
; Each message is given with the last character inverted (plus &80).
@label=CASSETTE
t$09A1 DEFB $80                                      ; Initial byte is stepped
                                                     ; over.
 $09A2 DEFM "Start tape, then press any key","."+$80 ; 'Start tape, then press
                                                     ; any key.'
@label=BLOCK_HDR
 $09C1 DEFM $0D,"Program:"," "+$80                   ; Carriage return +
                                                     ; 'Program: '
 $09CB DEFM $0D,"Number array:"," "+$80              ; Carriage return +
                                                     ; 'Number array: '
 $09DA DEFM $0D,"Character array:"," "+$80           ; Carriage return +
                                                     ; 'Character array: '
 $09EC DEFM $0D,"Bytes:"," "+$80                     ; Carriage return +
                                                     ; 'Bytes: '

; THE 'PRINT-OUT' ROUTINES
;
; Used by the routines at #R$111D and #R$18C1.
; .
; The address of this routine is found in the #R$15AF(initial channel
; information table).
; .
; All of the printing to the main part of the screen, the lower part of the
; screen and the printer is handled by this set of routines.
; .
; This routine is entered with the #REGa register holding the code for a
; control character, a printable character or a token.
;
; A Character code
@refs=$15EF
@label=PRINT_OUT
c$09F4 CALL $0B03    ; The current print position.
 $09F7 CP " "        ; {If the code represents a printable character then jump.
 $09F9 JP NC,$0AD9   ; }
 $09FC CP $06        ; {Print a question mark for codes in the range &00 to
 $09FE JR C,$0A69    ; &05.}
 $0A00 CP $18        ; {And also for codes &18 to &1F.
 $0A02 JR NC,$0A69   ; }
@nowarn
@ssub=LD HL,$0A11-$06
 $0A04 LD HL,$0A0B   ; Base of the #R$0A11(control character table).
 $0A07 LD E,A        ; {Move the code to the #REGde register pair.
 $0A08 LD D,$00      ; }
 $0A0A ADD HL,DE     ; {Index into the table and fetch the offset.
 $0A0B LD E,(HL)     ; }
 $0A0C ADD HL,DE     ; {Add the offset and make an indirect jump to the
 $0A0D PUSH HL       ; appropriate subroutine.
 $0A0E JP $0B03      ; }

; THE 'CONTROL CHARACTER' TABLE
;
; Used by the routine at #R$09F4.
@label=CTRL_CHARS
b$0A11 DEFB $4E      ; &06: PRINT comma (#R$0A5F)
 $0A12 DEFB $57      ; &07: EDIT (#R$0A69)
 $0A13 DEFB $10      ; &08: Cursor left (#R$0A23)
 $0A14 DEFB $29      ; &09: Cursor right (#R$0A3D)
 $0A15 DEFB $54      ; &0A: Cursor down (#R$0A69)
 $0A16 DEFB $53      ; &0B: Cursor up (#R$0A69)
 $0A17 DEFB $52      ; &0C: DELETE (#R$0A69)
 $0A18 DEFB $37      ; &0D: ENTER (#R$0A4F)
 $0A19 DEFB $50      ; &0E: Not used (#R$0A69)
 $0A1A DEFB $4F      ; &0F: Not used (#R$0A69)
 $0A1B DEFB $5F      ; &10: INK control (#R$0A7A)
 $0A1C DEFB $5E      ; &11: PAPER control (#R$0A7A)
 $0A1D DEFB $5D      ; &12: FLASH control (#R$0A7A)
 $0A1E DEFB $5C      ; &13: BRIGHT control (#R$0A7A)
 $0A1F DEFB $5B      ; &14: INVERSE control (#R$0A7A)
 $0A20 DEFB $5A      ; &15: OVER control (#R$0A7A)
 $0A21 DEFB $54      ; &16: AT control (#R$0A75)
 $0A22 DEFB $53      ; &17: TAB control (#R$0A75)

; THE 'CURSOR LEFT' SUBROUTINE
;
; The address of this routine is derived from an offset found in the
; #R$0A11(control character table).
;
; B Current line number
; C Current column number
@refs=$09F4
@label=PO_BACK_1
c$0A23 INC C          ; Move leftwards by one column.
 $0A24 LD A,$22       ; {Accept the change unless up against the lefthand side.
 $0A26 CP C           ;
 $0A27 JR NZ,$0A3A    ; }
 $0A29 BIT 1,(IY+$01) ; {If dealing with the printer (bit 1 of #SYSVAR(FLAGS)
 $0A2D JR NZ,$0A38    ; set) jump forward.}
 $0A2F INC B          ; Go up one line.
 $0A30 LD C,$02       ; Set column value.
@bfix=LD A,$19        ; {Test against top line.
 $0A32 LD A,$18       ; {Test against top line. Note: #BUG#noStepBack(this
@bfix=CP B            ; }
 $0A34 CP B           ; ought to be &19).}
 $0A35 JR NZ,$0A3A    ; Accept the change unless at the top of the screen.
 $0A37 DEC B          ; Unacceptable so down a line.
@label=PO_BACK_2
*$0A38 LD C,$21       ; Set to lefthand column.
@label=PO_BACK_3
*$0A3A JP $0DD9       ; Make an indirect return via #R$0DD9 and #R$0ADC.

; THE 'CURSOR RIGHT' SUBROUTINE
;
; The address of this routine is derived from an offset found in the
; #R$0A11(control character table).
; .
; This subroutine performs an operation identical to the BASIC statement 'PRINT
; OVER 1;CHR$ 32;'.
;
; B Current line number
; C Current column number
; HL Display file address or printer buffer address
@refs=$09F4
@label=PO_RIGHT
c$0A3D LD A,($5C91)    ; {Fetch #SYSVAR(P-FLAG) and save it on the machine
 $0A40 PUSH AF         ; stack.}
 $0A41 LD (IY+$57),$01 ; Set #SYSVAR(P-FLAG) to OVER 1.
 $0A45 LD A," "        ; A 'space'.
 $0A47 CALL $0B65      ; Print the character.
 $0A4A POP AF          ; {Fetch the old value of #SYSVAR(P-FLAG).
 $0A4B LD ($5C91),A    ; }
 $0A4E RET             ; Finished. Note: the programmer has forgotten to exit
                       ; via #R$0ADC, which is a #BUG#noStepForward(bug).

; THE 'CARRIAGE RETURN' SUBROUTINE
;
; The address of this routine is derived from an offset found in the
; #R$0A11(control character table).
; .
; If the printing being handled is going to the printer then a carriage return
; character leads to the printer buffer being emptied. If the printing is to
; the screen then a test for 'scroll?' is made before decreasing the line
; number.
;
; B Current line number
@refs=$09F4
@label=PO_ENTER
c$0A4F BIT 1,(IY+$01) ; {Jump if handling the printer (bit 1 of #SYSVAR(FLAGS)
 $0A53 JP NZ,$0ECD    ; set).}
 $0A56 LD C,$21       ; Set to lefthand column.
 $0A58 CALL $0C55     ; Scroll if necessary.
 $0A5B DEC B          ; Now down a line.
 $0A5C JP $0DD9       ; Make an indirect return via #R$0DD9 and #R$0ADC.

; THE 'PRINT COMMA' SUBROUTINE
;
; The address of this routine is derived from an offset found in the
; #R$0A11(control character table).
; .
; The current column value is manipulated and the #REGa register set to hold
; &00 (for TAB 0) or &10 (for TAB 16).
@refs=$09F4
@label=PO_COMMA
c$0A5F CALL $0B03    ; Why again?
 $0A62 LD A,C        ; Current column number.
 $0A63 DEC A         ; {Move rightwards by two columns and then test.
 $0A64 DEC A         ; }
 $0A65 AND $10       ; The #REGa register will be &00 or &10.
 $0A67 JR $0AC3      ; Exit via #R$0AC3.

; THE 'PRINT A QUESTION MARK' SUBROUTINE
;
; Used by the routine at #R$09F4.
; .
; The address of this routine is derived from an offset found in the
; #R$0A11(control character table).
; .
; A question mark is printed whenever an attempt is made to print an
; unprintable code.
@refs=$09F4
@label=PO_QUEST
c$0A69 LD A,"?"      ; The character '?'.
 $0A6B JR $0AD9      ; Now print this character instead.

; THE 'CONTROL CHARACTERS WITH OPERANDS' ROUTINE
;
; The control characters from INK to OVER require a single operand whereas the
; control characters AT and TAB are required to be followed by two operands.
; .
; The present routine leads to the control character code being saved in
; #SYSVAR(TVDATA-lo), the first operand in #SYSVAR(TVDATA-hi) or the #REGa
; register if there is only a single operand required, and the second operand
; in the #REGa register.
;
; A Control character code (&10 to &17)
@refs=$15EF
@nowarn
@label=PO_TV_2
c$0A6D LD DE,$0A87    ; {Save the first operand in #SYSVAR(TVDATA-hi) and
@keep=$01
@ssub=LD ($5C0E+$01),A
 $0A70 LD ($5C0F),A   ; change the address of the 'output' routine to #R$0A87.
 $0A73 JR $0A80       ; }
; The address of this entry point is derived from an offset found in the
; #R$0A11(control character table).
; .
; Enter here when handling the characters AT and TAB.
@refs=$09F4
@nowarn
@label=PO_2_OPER
*$0A75 LD DE,$0A6D    ; {The character code will be saved in #SYSVAR(TVDATA-lo)
 $0A78 JR $0A7D       ; and the address of the 'output' routine changed to
                      ; #R$0A6D.}
; The address of this entry point is derived from an offset found in the
; #R$0A11(control character table).
; .
; Enter here when handling the colour items - INK to OVER.
@refs=$09F4
@nowarn
@label=PO_1_OPER
*$0A7A LD DE,$0A87    ; The 'output' routine is to be changed to #R$0A87.
@label=PO_TV_1
*$0A7D LD ($5C0E),A   ; Save the control character code in #SYSVAR(TVDATA-hi).
; The current 'output' routine address is changed temporarily.
@label=PO_CHANGE
*$0A80 LD HL,($5C51)  ; #REGhl will point to the 'output' routine address
                      ; (#SYSVAR(CURCHL)).
 $0A83 LD (HL),E      ; {Enter the new 'output' routine address and thereby
 $0A84 INC HL         ; force the next character code to be considered as an
 $0A85 LD (HL),D      ; operand.
 $0A86 RET            ; }
; Once the operands have been collected the routine continues.
@nowarn
@label=PO_CONT
 $0A87 LD DE,$09F4    ; {Restore the original address for #R$09F4.
 $0A8A CALL $0A80     ; }
 $0A8D LD HL,($5C0E)  ; Fetch the control code and the first operand from
                      ; #SYSVAR(TVDATA) if there are indeed two operands.
 $0A90 LD D,A         ; {The 'last' operand and the control code are moved.
 $0A91 LD A,L         ; }
 $0A92 CP $16         ; {Jump forward if handling INK to OVER.
 $0A94 JP C,$2211     ; }
 $0A97 JR NZ,$0AC2    ; Jump forward if handling TAB.
; Now deal with the AT control character.
 $0A99 LD B,H         ; The line number.
 $0A9A LD C,D         ; The column number.
 $0A9B LD A,$1F       ; {Reverse the column number, i.e. &00 to &1F becomes &1F
 $0A9D SUB C          ; to &00.}
 $0A9E JR C,$0AAC     ; Must be in range.
 $0AA0 ADD A,$02      ; {Add in the offset to give #REGc holding &21 to &02.
 $0AA2 LD C,A         ; }
 $0AA3 BIT 1,(IY+$01) ; {Jump forward if handling the printer (bit 1 of
 $0AA7 JR NZ,$0ABF    ; #SYSVAR(FLAGS) set).}
 $0AA9 LD A,$16       ; {Reverse the line number, i.e. &00 to &15 becomes &16
 $0AAB SUB B          ; to &01.}
@label=PO_AT_ERR
*$0AAC JP C,$1E9F     ; If appropriate jump forward.
 $0AAF INC A          ; {The range &16 to &01 becomes &17 to &02.
 $0AB0 LD B,A         ; }
 $0AB1 INC B          ; And now &18 to &03.
 $0AB2 BIT 0,(IY+$02) ; {If printing in the lower part of the screen (bit 0 of
 $0AB6 JP NZ,$0C55    ; #SYSVAR(TV-FLAG) set) then consider whether scrolling
                      ; is needed.}
 $0AB9 CP (IY+$31)    ; {Give report 5 - Out of screen, if required
 $0ABC JP C,$0C86     ; (#SYSVAR(DF-SZ)>#REGa).}
@label=PO_AT_SET
*$0ABF JP $0DD9       ; Return via #R$0DD9 and #R$0ADC.
; And the TAB control character.
@label=PO_TAB
*$0AC2 LD A,H         ; Fetch the first operand.
; This entry point is used by the routine at #R$0A5F.
@label=PO_FILL
*$0AC3 CALL $0B03     ; The current print position.
 $0AC6 ADD A,C        ; Add the current column value.
 $0AC7 DEC A          ; {Find how many spaces, modulo 32, are required and
 $0AC8 AND $1F        ; return if the result is zero.
 $0ACA RET Z          ; }
 $0ACB LD D,A         ; Use #REGd as the counter.
 $0ACC SET 0,(IY+$01) ; Suppress 'leading space' (set bit 0 of #SYSVAR(FLAGS)).
@label=PO_SPACE
*$0AD0 LD A," "       ; {Print #REGd number of spaces.
 $0AD2 CALL $0C3B     ;
 $0AD5 DEC D          ;
 $0AD6 JR NZ,$0AD0    ; }
 $0AD8 RET            ; Now finished.

; PRINTABLE CHARACTER CODES
;
; Used by the routines at #R$09F4 and #R$0A69.
; .
; The required character (or characters) is printed by calling #R$0B24 followed
; by #R$0ADC.
;
; A Character code
@label=PO_ABLE
c$0AD9 CALL $0B24    ; Print the character(s) and continue into #R$0ADC.

; THE 'POSITION STORE' SUBROUTINE
;
; Used by the routine at #R$0DD9.
; .
; The routine at #R$0AD9 continues here.
; .
; The new position's 'line and column' values and the 'pixel' address are
; stored in the appropriate system variables.
;
; B Line number
; C Column number
; HL Display file address or printer buffer address
@label=PO_STORE
c$0ADC BIT 1,(IY+$01) ; {Jump forward if handling the printer (bit 1 of
 $0AE0 JR NZ,$0AFC    ; #SYSVAR(FLAGS) set).}
 $0AE2 BIT 0,(IY+$02) ; {Jump forward if handling the lower part of the screen
 $0AE6 JR NZ,$0AF0    ; (bit 0 of #SYSVAR(TV-FLAG) set).}
 $0AE8 LD ($5C88),BC  ; {Save the values that relate to the main part of the
 $0AEC LD ($5C84),HL  ; screen at #SYSVAR(S-POSN) and #SYSVAR(DF-CC).}
 $0AEF RET            ; Then return.
@label=PO_ST_E
*$0AF0 LD ($5C8A),BC  ; {Save the values that relate to the lower part of the
 $0AF4 LD ($5C82),BC  ; screen at #SYSVAR(S-POSNL), #SYSVAR(ECHO-E) and
 $0AF8 LD ($5C86),HL  ; #SYSVAR(DF-CCL).}
 $0AFB RET            ; Then return.
@label=PO_ST_PR
*$0AFC LD (IY+$45),C  ; {Save the values that relate to the printer buffer at
 $0AFF LD ($5C80),HL  ; #SYSVAR(P-POSN) and #SYSVAR(PR-CC).}
 $0B02 RET            ; Then return.

; THE 'POSITION FETCH' SUBROUTINE
;
; Used by the routines at #R$09F4, #R$0A5F, #R$0A6D and #R$0B24.
; .
; The current position's parameters are fetched from the appropriate system
; variables.
;
; O:B Line number
; O:C Column number
; O:HL Display file address or printer buffer address
@label=PO_FETCH
c$0B03 BIT 1,(IY+$01) ; {Jump forward if handling the printer (bit 1 of
 $0B07 JR NZ,$0B1D    ; #SYSVAR(FLAGS) set).}
 $0B09 LD BC,($5C88)  ; {Fetch the values relating to the main part of the
 $0B0D LD HL,($5C84)  ; screen from #SYSVAR(S-POSN) and #SYSVAR(DF-CC) and
 $0B10 BIT 0,(IY+$02) ; return if this was the intention (bit 0 of
 $0B14 RET Z          ; #SYSVAR(TV-FLAG) set).}
 $0B15 LD BC,($5C8A)  ; {Otherwise fetch the values relating to the lower part
 $0B19 LD HL,($5C86)  ; of the screen from #SYSVAR(S-POSNL) and
                      ; #SYSVAR(DF-CCL).}
 $0B1C RET            ;
@label=PO_F_PR
*$0B1D LD C,(IY+$45)  ; {Fetch the values relating to the printer buffer from
 $0B20 LD HL,($5C80)  ; #SYSVAR(P-POSN) and #SYSVAR(PR-CC).}
 $0B23 RET            ;

; THE 'PRINT ANY CHARACTER(S)' SUBROUTINE
;
; Used by the routine at #R$0AD9.
; .
; Ordinary character codes, token codes and user-defined graphic codes, and
; graphic codes are dealt with separately.
;
; A Character code
; B Line number
; C Column number
; HL Display file address or printer buffer address
@label=PO_ANY
c$0B24 CP $80         ; {Jump forward with ordinary character codes.
 $0B26 JR C,$0B65     ; }
 $0B28 CP $90         ; {Jump forward with token codes and UDG codes.
 $0B2A JR NC,$0B52    ; }
 $0B2C LD B,A         ; Move the graphic code.
 $0B2D CALL $0B38     ; Construct the graphic form.
 $0B30 CALL $0B03     ; #REGhl has been disturbed so 'fetch' again.
 $0B33 LD DE,$5C92    ; Make #REGde point to the start of the graphic form,
                      ; i.e. #SYSVAR(MEMBOT).
 $0B36 JR $0B7F       ; Jump forward to print the graphic character.
; Graphic characters are constructed in an ad hoc manner in the calculator's
; memory area, i.e. mem-0 and mem-1.
@label=PO_GR_1
*$0B38 LD HL,$5C92    ; This is #SYSVAR(MEMBOT).
 $0B3B CALL $0B3E     ; In effect call the following subroutine twice.
@label=PO_GR_2
*$0B3E RR B           ; {Determine bit 0 (and later bit 2) of the graphic code.
 $0B40 SBC A,A        ; }
 $0B41 AND $0F        ; The #REGa register will hold &00 or &0F depending on
                      ; the value of the bit in the code.
 $0B43 LD C,A         ; Save the result in #REGc.
 $0B44 RR B           ; {Determine bit 1 (and later bit 3) of the graphic code.
 $0B46 SBC A,A        ; }
 $0B47 AND $F0        ; The #REGa register will hold &00 or &F0.
 $0B49 OR C           ; The two results are combined.
 $0B4A LD C,$04       ; {The #REGa register holds half the character form and
@label=PO_GR_3
*$0B4C LD (HL),A      ; has to be used four times. This is done for the upper
 $0B4D INC HL         ; half of the character form and then the lower.
 $0B4E DEC C          ;
 $0B4F JR NZ,$0B4C    ;
 $0B51 RET            ; }
; Token codes and user-defined graphic codes are now separated.
@label=PO_T_UDG
*$0B52 SUB $A5        ; {Jump forward with token codes.
 $0B54 JR NC,$0B5F    ; }
 $0B56 ADD A,$15      ; UDG codes are now &00 to &0F.
 $0B58 PUSH BC        ; Save the current position values on the machine stack.
 $0B59 LD BC,($5C7B)  ; {Fetch the base address of the UDG area (from
 $0B5D JR $0B6A       ; #SYSVAR(UDG)) and jump forward.}
@label=PO_T
*$0B5F CALL $0C10     ; {Now print the token and return via #R$0B03.
 $0B62 JP $0B03       ; }
; This entry point is used by the routine at #R$0A3D.
; .
; The required character form is identified.
@label=PO_CHAR
*$0B65 PUSH BC        ; The current position is saved.
 $0B66 LD BC,($5C36)  ; The base address of the character area is fetched
                      ; (#SYSVAR(CHARS)).
@label=PO_CHAR_2
*$0B6A EX DE,HL       ; The print address is saved.
 $0B6B LD HL,$5C3B    ; This is #SYSVAR(FLAGS).
 $0B6E RES 0,(HL)     ; Allow for a leading space.
 $0B70 CP " "         ; {Jump forward if the character is not a 'space'.
 $0B72 JR NZ,$0B76    ; }
 $0B74 SET 0,(HL)     ; But 'suppress' if it is.
@label=PO_CHAR_3
*$0B76 LD H,$00       ; {Now pass the character code to the #REGhl register
 $0B78 LD L,A         ; pair.}
 $0B79 ADD HL,HL      ; {The character code is in effect multiplied by 8.
 $0B7A ADD HL,HL      ;
 $0B7B ADD HL,HL      ; }
 $0B7C ADD HL,BC      ; The base address of the character form is found.
 $0B7D POP BC         ; {The current position is fetched and the base address
 $0B7E EX DE,HL       ; passed to the #REGde register pair.}
; The following subroutine is used to print all '8*8' bit characters. On entry
; the #REGde register pair holds the base address of the character form, the
; #REGhl register the destination address and the #REGbc register pair the
; current 'line and column' values.
@label=PR_ALL
*$0B7F LD A,C         ; Fetch the column number.
 $0B80 DEC A          ; Move one column rightwards.
 $0B81 LD A,$21       ; {Jump forward unless a new line is indicated.
 $0B83 JR NZ,$0B93    ; }
 $0B85 DEC B          ; Move down one line.
 $0B86 LD C,A         ; Column number is &21.
 $0B87 BIT 1,(IY+$01) ; {Jump forward if handling the screen (bit 1 of
 $0B8B JR Z,$0B93     ; #SYSVAR(FLAGS) reset).}
 $0B8D PUSH DE        ; {Save the base address whilst the printer buffer is
 $0B8E CALL $0ECD     ; emptied.
 $0B91 POP DE         ; }
 $0B92 LD A,C         ; Copy the new column number.
@label=PR_ALL_1
*$0B93 CP C           ; {Test whether a new line is being used. If it is see if
 $0B94 PUSH DE        ; the display requires to be scrolled.
 $0B95 CALL Z,$0C55   ;
 $0B98 POP DE         ; }
; Now consider the present state of INVERSE and OVER.
 $0B99 PUSH BC        ; {Save the position values and the destination address
 $0B9A PUSH HL        ; on the machine stack.}
 $0B9B LD A,($5C91)   ; Fetch #SYSVAR(P-FLAG) and read bit 0.
 $0B9E LD B,$FF       ; {Prepare the 'OVER mask' in the #REGb register, i.e.
 $0BA0 RRA            ; OVER 0=&00 and OVER 1=&FF.
 $0BA1 JR C,$0BA4     ;
 $0BA3 INC B          ; }
@label=PR_ALL_2
*$0BA4 RRA            ; {Read bit 2 of #SYSVAR(P-FLAG) and prepare the 'INVERSE
 $0BA5 RRA            ; mask' in the #REGc register, i.e. INVERSE 0=&00 and
 $0BA6 SBC A,A        ; INVERSE 1=&FF.
 $0BA7 LD C,A         ; }
 $0BA8 LD A,$08       ; {Set the #REGa register to hold the 'pixel-line'
 $0BAA AND A          ; counter and clear the carry flag.}
 $0BAB BIT 1,(IY+$01) ; {Jump forward if handling the screen (bit 1 of
 $0BAF JR Z,$0BB6     ; #SYSVAR(FLAGS) reset).}
 $0BB1 SET 1,(IY+$30) ; Signal 'printer buffer no longer empty' (set bit 1 of
                      ; #R$5C6A(FLAGS2)).
 $0BB5 SCF            ; Set the carry flag to show that the printer is being
                      ; used.
@label=PR_ALL_3
*$0BB6 EX DE,HL       ; Exchange the destination address with the base address
                      ; before entering the loop.
; The character can now be printed. Eight passes of the loop are made - one for
; each 'pixel-line'.
@label=PR_ALL_4
*$0BB7 EX AF,AF'      ; The carry flag is set when using the printer. Save this
                      ; flag in #REGf'.
 $0BB8 LD A,(DE)      ; Fetch the existing 'pixel-line'.
 $0BB9 AND B          ; {Use the 'OVER mask' and then '#S/XOR/' the result with
 $0BBA XOR (HL)       ; the 'pixel-line' of the character form.}
 $0BBB XOR C          ; Finally consider the 'INVERSE mask'.
 $0BBC LD (DE),A      ; Enter the result.
 $0BBD EX AF,AF'      ; {Fetch the printer flag and jump forward if required.
 $0BBE JR C,$0BD3     ; }
 $0BC0 INC D          ; Update the destination address.
@label=PR_ALL_5
*$0BC1 INC HL         ; Update the 'pixel-line' address of the character form.
 $0BC2 DEC A          ; {Decrease the counter and loop back unless it is zero.
 $0BC3 JR NZ,$0BB7    ; }
; Once the character has been printed the attribute byte is to be set as
; required.
 $0BC5 EX DE,HL       ; {Make the #REGh register hold a correct high-address
 $0BC6 DEC H          ; for the character area.}
 $0BC7 BIT 1,(IY+$01) ; {Set the attribute byte only if handling the screen
 $0BCB CALL Z,$0BDB   ; (bit 1 of #SYSVAR(FLAGS) reset).}
 $0BCE POP HL         ; {Restore the original destination address and the
 $0BCF POP BC         ; position values.}
 $0BD0 DEC C          ; {Decrease the column number and increase the
 $0BD1 INC HL         ; destination address before returning.
 $0BD2 RET            ; }
; When the printer is being used the destination address has to be updated in
; increments of &20.
@label=PR_ALL_6
*$0BD3 EX AF,AF'      ; Save the printer flag again.
 $0BD4 LD A,$20       ; The required increment value.
 $0BD6 ADD A,E        ; {Add the value and pass the result back to the #REGe
 $0BD7 LD E,A         ; register.}
 $0BD8 EX AF,AF'      ; Fetch the flag.
 $0BD9 JR $0BC1       ; Jump back into the loop.

; THE 'SET ATTRIBUTE BYTE' SUBROUTINE
;
; Used by the routines at #R$0B24 and #R$22DC.
; .
; The appropriate attribute byte is identified and fetched. The new value is
; formed by manipulating the old value, #SYSVAR(ATTR-T), #SYSVAR(MASK-T) and
; #SYSVAR(P-FLAG). Finally this new value is copied to the attribute area.
;
; HL Display file address
@label=PO_ATTR
c$0BDB LD A,H         ; {The high byte of the destination address is divided by
 $0BDC RRCA           ; eight and #S/AND/ed with &03 to determine which third
 $0BDD RRCA           ; of the screen is being addressed, i.e. &00, &01 or &02.
 $0BDE RRCA           ;
 $0BDF AND $03        ; }
 $0BE1 OR $58         ; {The high byte for the attribute area is then formed.
 $0BE3 LD H,A         ; }
 $0BE4 LD DE,($5C8F)  ; #REGe holds #SYSVAR(ATTR-T), and #REGd holds
                      ; #SYSVAR(MASK-T).
 $0BE8 LD A,(HL)      ; The old attribute value.
 $0BE9 XOR E          ; {The values of #SYSVAR(MASK-T) and #SYSVAR(ATTR-T) are
 $0BEA AND D          ; taken into account.
 $0BEB XOR E          ; }
 $0BEC BIT 6,(IY+$57) ; {Jump forward unless dealing with PAPER 9 (bit 6 of
 $0BF0 JR Z,$0BFA     ; #SYSVAR(P-FLAG) set).}
 $0BF2 AND $C7        ; {The old paper colour is ignored and depending on
 $0BF4 BIT 2,A        ; whether the ink colour is light or dark the new paper
 $0BF6 JR NZ,$0BFA    ; colour will be black (000) or white (111).
 $0BF8 XOR $38        ; }
@label=PO_ATTR_1
@label=PO_ATTR_1
*$0BFA BIT 4,(IY+$57) ; {Jump forward unless dealing with INK 9 (bit 4 of
 $0BFE JR Z,$0C08     ; #SYSVAR(P-FLAG) set).}
 $0C00 AND $F8        ; {The old ink colour is ignored and depending on whether
 $0C02 BIT 5,A        ; the paper colour is light or dark the new ink colour
 $0C04 JR NZ,$0C08    ; will be black (000) or white (111).
 $0C06 XOR $07        ; }
@label=PO_ATTR_2
@label=PO_ATTR_2
*$0C08 LD (HL),A      ; {Enter the new attribute value and return.
 $0C09 RET            ; }

; THE 'MESSAGE PRINTING' SUBROUTINE
;
; Used by the routines at #R$0605, #R$0970, #R$0C55, #R$11B7 and #R$12A2.
; .
; This subroutine is used to print messages and tokens.
;
; A Message table entry number
; DE Message table address (#R$09A1, #R$09C1-1, #R$0CF8, #R$1391, #R$1537-1 or
; .  #R$1539-1)
@label=PO_MSG
c$0C0A PUSH HL        ; {The high byte of the last entry on the machine stack
 $0C0B LD H,$00       ; is made zero so as to suppress trailing spaces (see
 $0C0D EX (SP),HL     ; below).}
 $0C0E JR $0C14       ; Jump forward.
; This entry point is used by the routine at #R$0B24.
; .
; Enter here when expanding token codes.
@label=PO_TOKENS
*$0C10 LD DE,$0095    ; The base address of the #R$0095(token table).
 $0C13 PUSH AF        ; Save the code on the stack. (Range &00 to &5A, RND to
                      ; COPY).
; The table is searched and the correct entry printed.
@label=PO_TABLE
*$0C14 CALL $0C41     ; Locate the required entry.
 $0C17 JR C,$0C22     ; Print the message/token.
 $0C19 LD A," "       ; {A 'space' will be printed before the message/token if
 $0C1B BIT 0,(IY+$01) ; required (bit 0 of #SYSVAR(FLAGS) reset).
 $0C1F CALL Z,$0C3B   ; }
; The characters of the message/token are printed in turn.
@label=PO_EACH
*$0C22 LD A,(DE)      ; Collect a code.
 $0C23 AND $7F        ; Cancel any 'inverted bit'.
 $0C25 CALL $0C3B     ; Print the character.
 $0C28 LD A,(DE)      ; Collect the code again.
 $0C29 INC DE         ; Advance the pointer.
 $0C2A ADD A,A        ; {The 'inverted bit' goes to the carry flag and signals
 $0C2B JR NC,$0C22    ; the end of the message/token; otherwise jump back.}
; Now consider whether a 'trailing space' is required.
 $0C2D POP DE         ; For messages, #REGd holds &00; for tokens, #REGd holds
                      ; &00 to &5A.
 $0C2E CP $48         ; {Jump forward if the last character was a '$'.
 $0C30 JR Z,$0C35     ; }
 $0C32 CP $82         ; {Return if the last character was any other before 'A'.
 $0C34 RET C          ; }
@label=PO_TR_SP
*$0C35 LD A,D         ; {Examine the value in #REGd and return if it indicates
 $0C36 CP $03         ; a message, RND, INKEY$ or PI.
 $0C38 RET C          ; }
 $0C39 LD A," "       ; All other cases will require a 'trailing space'.
; This routine continues into #R$0C3B.

; THE 'PO-SAVE' SUBROUTINE
;
; Used by the routines at #R$0A6D and #R$0C0A.
; .
; The routine at #R$0C0A continues here.
; .
; This subroutine allows for characters to be printed 'recursively'. The
; appropriate registers are saved whilst #R$0010 is called.
;
; A Character code
@label=PO_SAVE
c$0C3B PUSH DE       ; Save the #REGde register pair.
 $0C3C EXX           ; Save #REGhl and #REGbc.
 $0C3D RST $10       ; Print the single character.
 $0C3E EXX           ; Restore #REGhl and #REGbc.
 $0C3F POP DE        ; Restore #REGde.
 $0C40 RET           ; Finished.

; THE 'TABLE SEARCH' SUBROUTINE
;
; Used by the routine at #R$0C0A.
;
;   A Message table entry number
;   DE Message table start address
; O:DE Address of the first character of message number #REGa
; O:F Carry flag: suppress (set) or allow (reset) a leading space
@label=PO_SEARCH
c$0C41 PUSH AF       ; Save the 'entry number'.
 $0C42 EX DE,HL      ; #REGhl now holds the base address.
 $0C43 INC A         ; Compensate for the '#S/DEC A/' below.
@label=PO_STEP
*$0C44 BIT 7,(HL)    ; {Wait for an 'inverted character'.
 $0C46 INC HL        ;
 $0C47 JR Z,$0C44    ; }
 $0C49 DEC A         ; {Count through the entries until the correct one is
 $0C4A JR NZ,$0C44   ; found.}
 $0C4C EX DE,HL      ; #REGde points to the initial character.
 $0C4D POP AF        ; {Fetch the 'entry number' and return with carry set for
 $0C4E CP $20        ; the first thirty two entries.
 $0C50 RET C         ; }
 $0C51 LD A,(DE)     ; {However if the initial character is a letter then a
 $0C52 SUB "A"       ; leading space may be needed.
 $0C54 RET           ; }

; THE 'TEST FOR SCROLL' SUBROUTINE
;
; Used by the routines at #R$0A4F, #R$0A6D and #R$0B24.
; .
; This subroutine is called whenever there might be the need to scroll the
; display. This occurs on three occasions:
; .
; #LIST
; { when handling a 'carriage return' character }
; { when using AT in an INPUT line }
; { when the current line is full and the next line has to be used }
; LIST#
;
; B Current line number
@label=PO_SCR
c$0C55 BIT 1,(IY+$01) ; {Return immediately if the printer is being used (bit 1
 $0C59 RET NZ         ; of #SYSVAR(FLAGS) set).}
@nowarn
 $0C5A LD DE,$0DD9    ; {Pre-load the machine stack with the address of
 $0C5D PUSH DE        ; #R$0DD9.}
 $0C5E LD A,B         ; Transfer the line number.
 $0C5F BIT 0,(IY+$02) ; {Jump forward if considering 'INPUT ... AT ...' (bit 0
 $0C63 JP NZ,$0D02    ; of #SYSVAR(TV-FLAG) set).}
 $0C66 CP (IY+$31)    ; {Return, via #R$0DD9, if the line number is greater
 $0C69 JR C,$0C86     ; than the value of #SYSVAR(DF-SZ); give report 5 if it
 $0C6B RET NZ         ; is less; otherwise continue.}
 $0C6C BIT 4,(IY+$02) ; {Jump forward unless dealing with an 'automatic
 $0C70 JR Z,$0C88     ; listing' (bit 4 of #SYSVAR(TV-FLAG) set).}
 $0C72 LD E,(IY+$2D)  ; Fetch the line counter from #SYSVAR(BREG).
 $0C75 DEC E          ; Decrease this counter.
 $0C76 JR Z,$0CD2     ; Jump forward if the listing is to be scrolled.
 $0C78 LD A,$00       ; {Otherwise open channel 'K', restore the stack pointer,
 $0C7A CALL $1601     ; flag that the automatic listing has finished (reset bit
 $0C7D LD SP,($5C3F)  ; 4 of #SYSVAR(TV-FLAG)) and return via #R$0DD9.
 $0C81 RES 4,(IY+$02) ;
 $0C85 RET            ; }
; This entry point is used by the routine at #R$0A6D.
; .
; Report 5 - Out of screen.
@label=REPORT_5
*$0C86 RST $08        ; {Call the error handling routine.
 $0C87 DEFB $04       ; }
; Now consider if the prompt 'scroll?' is required.
@label=PO_SCR_2
*$0C88 DEC (IY+$52)   ; {Decrease the scroll counter (#SYSVAR(SCR-CT)) and
 $0C8B JR NZ,$0CD2    ; proceed to give the prompt only if it becomes zero.}
; Proceed to give the prompt message.
 $0C8D LD A,$18       ; {The scroll counter (#SYSVAR(SCR-CT)) is reset.
 $0C8F SUB B          ;
 $0C90 LD ($5C8C),A   ; }
 $0C93 LD HL,($5C8F)  ; {The current values of #SYSVAR(ATTR-T) and
 $0C96 PUSH HL        ; #SYSVAR(MASK-T) are saved.}
 $0C97 LD A,($5C91)   ; {The current value of #SYSVAR(P-FLAG) is saved.
 $0C9A PUSH AF        ; }
 $0C9B LD A,$FD       ; {Channel 'K' is opened.
 $0C9D CALL $1601     ; }
 $0CA0 XOR A          ; {The message 'scroll?' is message '0'. This message is
@nowarn
 $0CA1 LD DE,$0CF8    ; now printed.
 $0CA4 CALL $0C0A     ; }
 $0CA7 SET 5,(IY+$02) ; Signal 'clear the lower screen after a keystroke' (set
                      ; bit 5 of #SYSVAR(TV-FLAG)).
 $0CAB LD HL,$5C3B    ; This is #SYSVAR(FLAGS).
 $0CAE SET 3,(HL)     ; Signal 'L mode'.
 $0CB0 RES 5,(HL)     ; Signal 'no key yet'.
 $0CB2 EXX            ; Note: #REGde #BUG#scrollingTokens(should be pushed
                      ; also).
 $0CB3 CALL $15D4     ; Fetch a single key code.
 $0CB6 EXX            ; Restore the registers.
 $0CB7 CP " "         ; {There is a jump forward to #R$0D00 - 'BREAK - CONT
 $0CB9 JR Z,$0D00     ; repeats' - if the keystroke was 'BREAK', 'STOP', 'N' or
 $0CBB CP $E2         ; 'n'; otherwise accept the keystroke as indicating the
 $0CBD JR Z,$0D00     ; need to scroll the display.
 $0CBF OR $20         ;
 $0CC1 CP "n"         ;
 $0CC3 JR Z,$0D00     ; }
 $0CC5 LD A,$FE       ; {Open channel 'S'.
 $0CC7 CALL $1601     ; }
 $0CCA POP AF         ; {Restore the value of #SYSVAR(P-FLAG).
 $0CCB LD ($5C91),A   ; }
 $0CCE POP HL         ; {Restore the values of #SYSVAR(ATTR-T) and
 $0CCF LD ($5C8F),HL  ; #SYSVAR(MASK-T).}
; The display is now scrolled.
@label=PO_SCR_3
*$0CD2 CALL $0DFE     ; The whole display is scrolled.
 $0CD5 LD B,(IY+$31)  ; {The line (#SYSVAR(DF-SZ)) and column numbers for the
 $0CD8 INC B          ; start of the line above the lower part of the display
 $0CD9 LD C,$21       ; are found and saved.
 $0CDB PUSH BC        ; }
 $0CDC CALL $0E9B     ; {The corresponding attribute byte for this character
 $0CDF LD A,H         ; area is then found. The #REGhl register pair holds the
 $0CE0 RRCA           ; address of the byte.
 $0CE1 RRCA           ;
 $0CE2 RRCA           ;
 $0CE3 AND $03        ;
 $0CE5 OR $58         ;
 $0CE7 LD H,A         ; }
; The line in question will have 'lower part' attribute values and the new line
; at the bottom of the display may have '#SYSVAR(ATTR-P)' values so the
; attribute values are exchanged.
 $0CE8 LD DE,$5AE0    ; #REGde points to the first attribute byte of the bottom
                      ; line.
 $0CEB LD A,(DE)      ; The value is fetched.
 $0CEC LD C,(HL)      ; The 'lower part' value.
 $0CED LD B,$20       ; There are thirty two bytes.
 $0CEF EX DE,HL       ; Exchange the pointers.
@label=PO_SCR_3A
*$0CF0 LD (DE),A      ; {Make the first exchange and then proceed to use the
 $0CF1 LD (HL),C      ; same values for the thirty two attribute bytes of the
 $0CF2 INC DE         ; two lines being handled.
 $0CF3 INC HL         ;
 $0CF4 DJNZ $0CF0     ; }
 $0CF6 POP BC         ; {The line and column numbers of the bottom line of the
 $0CF7 RET            ; 'upper part' are fetched before returning.}
; The 'scroll?' message.
@label=SCROLL
 $0CF8 DEFB $80       ; Initial marker - stepped over.
 $0CF9 DEFM "scroll"  ;
 $0CFF DEFM "?"+$80   ; The '?' is inverted.
; Report D - BREAK - CONT repeats.
@label=REPORT_D
*$0D00 RST $08        ; {Call the error handling routine.
 $0D01 DEFB $0C       ; }
; The lower part of the display is handled as follows:
@label=PO_SCR_4
*$0D02 CP $02         ; {The 'out of screen' error is given if the lower part
 $0D04 JR C,$0C86     ; is going to be 'too large' (see #SYSVAR(DF-SZ)) and a
 $0D06 ADD A,(IY+$31) ; return made if scrolling is unnecessary.
 $0D09 SUB $19        ;
 $0D0B RET NC         ; }
 $0D0C NEG            ; The #REGa register will now hold 'the number of scrolls
                      ; to be made'.
 $0D0E PUSH BC        ; The line and column numbers are now saved.
 $0D0F LD B,A         ; {The 'scroll number', #SYSVAR(ATTR-T), #SYSVAR(MASK-T)
 $0D10 LD HL,($5C8F)  ; and #SYSVAR(P-FLAG) are all saved.
 $0D13 PUSH HL        ;
 $0D14 LD HL,($5C91)  ;
 $0D17 PUSH HL        ; }
 $0D18 CALL $0D4D     ; The 'permanent' colour items are to be used.
 $0D1B LD A,B         ; The 'scroll number' is fetched.
; The lower part of the screen is now scrolled #REGa number of times.
@label=PO_SCR_4A
*$0D1C PUSH AF        ; Save the 'number'.
 $0D1D LD HL,$5C6B    ; This is #SYSVAR(DF-SZ).
 $0D20 LD B,(HL)      ; {The value in #SYSVAR(DF-SZ) is incremented; the #REGb
 $0D21 LD A,B         ; register set to hold the former value and the #REGa
 $0D22 INC A          ; register the new value.
 $0D23 LD (HL),A      ; }
@keep=$01
@ssub=LD HL,$5C88+$01
 $0D24 LD HL,$5C89    ; This is #SYSVAR(S-POSN-hi).
 $0D27 CP (HL)        ; {The jump is taken if only the lower part of the
 $0D28 JR C,$0D2D     ; display is to be scrolled (#REGb=old #SYSVAR(DF-SZ)).}
 $0D2A INC (HL)       ; {Otherwise #SYSVAR(S-POSN-hi) is incremented and the
 $0D2B LD B,$18       ; whole display scrolled (#REGb=&18).}
@label=PO_SCR_4B
*$0D2D CALL $0E00     ; Scroll #REGb lines.
 $0D30 POP AF         ; {Fetch and decrement the 'scroll number'.
 $0D31 DEC A          ; }
 $0D32 JR NZ,$0D1C    ; Jump back until finished.
 $0D34 POP HL         ; {Restore the value of #SYSVAR(P-FLAG).
 $0D35 LD (IY+$57),L  ; }
 $0D38 POP HL         ; {Restore the values of #SYSVAR(ATTR-T) and
 $0D39 LD ($5C8F),HL  ; #SYSVAR(MASK-T).}
 $0D3C LD BC,($5C88)  ; {In case #SYSVAR(S-POSN) has been changed #R$0DD9 is
 $0D40 RES 0,(IY+$02) ; called to give a matching value to #SYSVAR(DF-CC)
 $0D44 CALL $0DD9     ; (after resetting bit 0 of #SYSVAR(TV-FLAG)).}
 $0D47 SET 0,(IY+$02) ; {Set bit 0 of #SYSVAR(TV-FLAG) to indicate that the
 $0D4B POP BC         ; lower screen is being handled, fetch the line and
 $0D4C RET            ; column numbers, and then return.}

; THE 'TEMPORARY COLOUR ITEMS' SUBROUTINE
;
; Used by the routines at #R$0C55, #R$0D6B, #R$0DAF, #R$111D, #R$1642, #R$1C96,
; #R$1CBE, #R$1FC9, #R$22DC and #R$2382.
; .
; This is a most important subroutine. It is used whenever the 'permanent'
; details are required to be copied to the 'temporary' system variables. First
; #SYSVAR(ATTR-T) and #SYSVAR(MASK-T) are considered.
@label=TEMPS
c$0D4D XOR A          ; #REGa is set to hold &00.
 $0D4E LD HL,($5C8D)  ; The current values of #SYSVAR(ATTR-P) and
                      ; #SYSVAR(MASK-P) are fetched.
 $0D51 BIT 0,(IY+$02) ; {Jump forward if handing the main part of the screen
 $0D55 JR Z,$0D5B     ; (bit 0 of #SYSVAR(TV-FLAG) reset).}
 $0D57 LD H,A         ; {Otherwise use &00 and the value in #SYSVAR(BORDCR)
 $0D58 LD L,(IY+$0E)  ; instead.}
@label=TEMPS_1
*$0D5B LD ($5C8F),HL  ; Now set #SYSVAR(ATTR-T) and #SYSVAR(MASK-T).
; Next #SYSVAR(P-FLAG) is considered.
 $0D5E LD HL,$5C91    ; This is #SYSVAR(P-FLAG).
 $0D61 JR NZ,$0D65    ; Jump forward if dealing with the lower part of the
                      ; screen (#REGa=&00).
 $0D63 LD A,(HL)      ; {Otherwise fetch the value of #SYSVAR(P-FLAG) and move
 $0D64 RRCA           ; the odd bits to the even bits.}
@label=TEMPS_2
*$0D65 XOR (HL)       ; {Proceed to copy the even bits of #REGa to
 $0D66 AND %01010101  ; #SYSVAR(P-FLAG).
 $0D68 XOR (HL)       ;
 $0D69 LD (HL),A      ; }
 $0D6A RET            ;

; THE 'CLS' COMMAND ROUTINE
;
; Used by the routines at #R$11B7 and #R$1EAC.
; .
; The address of this routine is found in the #R$1ABE(parameter table).
; .
; In the first instance the whole of the display is 'cleared' - the 'pixels'
; are all reset and the attribute bytes are set to equal the value in
; #SYSVAR(ATTR-P) - then the lower part of the display is reformed.
@refs=$1C0D
@label=CLS
c$0D6B CALL $0DAF      ; The whole of the display is 'cleared'.
; This entry point is used by the routines at #R$10A8, #R$12A2 and #R$2089.
@label=CLS_LOWER
*$0D6E LD HL,$5C3C     ; This is #SYSVAR(TV-FLAG).
 $0D71 RES 5,(HL)      ; Signal 'do not clear the lower screen after
                       ; keystroke'.
 $0D73 SET 0,(HL)      ; Signal 'lower part'.
 $0D75 CALL $0D4D      ; Use the permanent values, i.e. #SYSVAR(ATTR-T) is
                       ; copied from #SYSVAR(BORDCR).
 $0D78 LD B,(IY+$31)   ; {The lower part of the screen is now 'cleared' with
 $0D7B CALL $0E44      ; these values (#REGb=#SYSVAR(DF-SZ)).}
; With the exception of the attribute bytes for lines 22 and 23 the attribute
; bytes for the lines in the lower part of the display will need to be made
; equal to #SYSVAR(ATTR-P).
 $0D7E LD HL,$5AC0     ; Attribute byte at start of line 22.
 $0D81 LD A,($5C8D)    ; Fetch #SYSVAR(ATTR-P).
 $0D84 DEC B           ; The line counter.
 $0D85 JR $0D8E        ; Jump forward into the loop.
@label=CLS_1
*$0D87 LD C,$20        ; &20 characters per line.
@label=CLS_2
*$0D89 DEC HL          ; {Go back along the line setting the attribute bytes.
 $0D8A LD (HL),A       ;
 $0D8B DEC C           ;
 $0D8C JR NZ,$0D89     ; }
@label=CLS_3
*$0D8E DJNZ $0D87      ; Loop back until finished.
; The size of the lower part of the display can now be fixed.
 $0D90 LD (IY+$31),$02 ; It will be two lines in size (#SYSVAR(DF-SZ)).
; This entry point is used by the routine at #R$0DAF.
; .
; It now remains for the following 'house keeping' tasks to be performed.
@label=CL_CHAN
*$0D94 LD A,$FD        ; {Open channel 'K'.
 $0D96 CALL $1601      ; }
 $0D99 LD HL,($5C51)   ; {Fetch the address of the current channel
@nowarn
 $0D9C LD DE,$09F4     ; (#SYSVAR(CURCHL)) and make the output address #R$09F4
 $0D9F AND A           ; and the input address #R$10A8.
@label=CL_CHAN_A
*$0DA0 LD (HL),E       ;
 $0DA1 INC HL          ;
 $0DA2 LD (HL),D       ;
 $0DA3 INC HL          ;
@nowarn
 $0DA4 LD DE,$10A8     ; }
 $0DA7 CCF             ; {First the output address then the input address.
 $0DA8 JR C,$0DA0      ; }
@keep
 $0DAA LD BC,$1721     ; As the lower part of the display is being handled the
                       ; 'lower print line' will be line 23.
 $0DAD JR $0DD9        ; Return via #R$0DD9.

; THE 'CLEARING THE WHOLE DISPLAY AREA' SUBROUTINE
;
; Used by the routines at #R$0D6B, #R$12A2 and #R$1795.
@label=CL_ALL
@keep
c$0DAF LD HL,$0000     ; {The system variable #SYSVAR(COORDS) is reset to zero.
 $0DB2 LD ($5C7D),HL   ; }
 $0DB5 RES 0,(IY+$30)  ; Signal 'the screen is clear' (reset bit 0 of
                       ; #R$5C6A(FLAGS2)).
 $0DB9 CALL $0D94      ; Perform the 'house keeping' tasks.
 $0DBC LD A,$FE        ; {Open channel 'S'.
 $0DBE CALL $1601      ; }
 $0DC1 CALL $0D4D      ; Use the 'permanent' values.
 $0DC4 LD B,$18        ; {Now 'clear' the 24 lines of the display.
 $0DC6 CALL $0E44      ; }
 $0DC9 LD HL,($5C51)   ; {Ensure that the current output address (at
@nowarn
 $0DCC LD DE,$09F4     ; (#SYSVAR(CURCHL))) is #R$09F4.
 $0DCF LD (HL),E       ;
 $0DD0 INC HL          ;
 $0DD1 LD (HL),D       ; }
 $0DD2 LD (IY+$52),$01 ; Reset the scroll counter (#SYSVAR(SCR-CT)).
@keep
 $0DD6 LD BC,$1821     ; As the upper part of the display is being handled the
                       ; 'upper print line' will be line 0.
; This routine continues into #R$0DD9.

; THE 'CL-SET' SUBROUTINE
;
; Used by the routines at #R$0A23, #R$0A4F, #R$0A6D, #R$0C55, #R$0D6B, #R$0EDF,
; #R$111D and #R$2089.
; .
; The routine at #R$0DAF continues here.
; .
; This subroutine is entered with the #REGbc register pair holding the line and
; column numbers of a character area, or the #REGc register holding the column
; number within the printer buffer. The appropriate address of the first
; character bit is then found. The subroutine returns via #R$0ADC so as to
; store all the values in the required system variables.
;
; B Line number
; C Column number
@label=CL_SET
c$0DD9 LD HL,$5B00    ; The start of the printer buffer.
 $0DDC BIT 1,(IY+$01) ; {Jump forward if handling the printer buffer (bit 1 of
 $0DE0 JR NZ,$0DF4    ; #SYSVAR(FLAGS) set).}
 $0DE2 LD A,B         ; Transfer the line number.
 $0DE3 BIT 0,(IY+$02) ; {Jump forward if handling the main part of the display
 $0DE7 JR Z,$0DEE     ; (bit 0 of #SYSVAR(TV-FLAG) reset).}
 $0DE9 ADD A,(IY+$31) ; {The top line of the lower part of the display is
 $0DEC SUB $18        ; called 'line &18' and this has to be converted (see
                      ; #SYSVAR(DF-SZ)).}
@label=CL_SET_1
*$0DEE PUSH BC        ; The line and column numbers are saved.
 $0DEF LD B,A         ; The line number is moved.
 $0DF0 CALL $0E9B     ; The address for the start of the line is formed in
                      ; #REGhl.
 $0DF3 POP BC         ; The line and column numbers are fetched back.
@label=CL_SET_2
*$0DF4 LD A,$21       ; {The column number is now reversed and transferred to
 $0DF6 SUB C          ; the #REGde register pair.
 $0DF7 LD E,A         ;
 $0DF8 LD D,$00       ; }
 $0DFA ADD HL,DE      ; {The required address is now formed, and the address
 $0DFB JP $0ADC       ; and the line and column numbers are stored by jumping
                      ; to #R$0ADC.}

; THE 'SCROLLING' SUBROUTINE
;
; Used by the routine at #R$0C55.
; .
; The number of lines of the display that are to be scrolled has to be held on
; entry to the main subroutine in the #REGb register.
@label=CL_SC_ALL
c$0DFE LD B,$17      ; The entry point after 'scroll?'
; This entry point is used by the routine at #R$0C55.
; .
; The main entry point - from above and when scrolling for INPUT...AT.
@label=CL_SCROLL
*$0E00 CALL $0E9B    ; Find the starting address of the line.
 $0E03 LD C,$08      ; There are eight pixel lines to a complete line.
; Now enter the main scrolling loop. The #REGb register holds the number of the
; top line to be scrolled, the #REGhl register pair the starting address in the
; display area of this line and the #REGc register the pixel line counter.
@label=CL_SCR_1
*$0E05 PUSH BC       ; Save both counters.
 $0E06 PUSH HL       ; Save the starting address.
 $0E07 LD A,B        ; {Jump forward unless dealing at the present moment with
 $0E08 AND $07       ; a 'third' of the display.
 $0E0A LD A,B        ;
 $0E0B JR NZ,$0E19   ; }
; The pixel lines of the top lines of the 'thirds' of the display have to be
; moved across the 2K boundaries. (Each 'third' is 2K.)
@label=CL_SCR_2
*$0E0D EX DE,HL      ; {The result of this manipulation is to leave #REGhl
 $0E0E LD HL,$F8E0   ; unchanged and #REGde pointing to the required
 $0E11 ADD HL,DE     ; destination.
 $0E12 EX DE,HL      ; }
@keep
 $0E13 LD BC,$0020   ; There are &20 characters.
 $0E16 DEC A         ; Decrease the counter as one line is being dealt with.
 $0E17 LDIR          ; Now move the thirty two bytes.
; The pixel lines within the 'thirds' can now be scrolled. The #REGa register
; holds, on the first pass, &01 to &07, &09 to &0F, or &11 to &17.
@label=CL_SCR_3
*$0E19 EX DE,HL      ; {Again #REGde is made to point to the required
 $0E1A LD HL,$FFE0   ; destination, this time only thirty two locations away.
 $0E1D ADD HL,DE     ;
 $0E1E EX DE,HL      ; }
 $0E1F LD B,A        ; Save the line number in #REGb.
 $0E20 AND $07       ; {Now find how many characters there are remaining in the
 $0E22 RRCA          ; 'third'.
 $0E23 RRCA          ;
 $0E24 RRCA          ; }
 $0E25 LD C,A        ; Pass the 'character total' to the #REGc register.
 $0E26 LD A,B        ; Fetch the line number.
 $0E27 LD B,$00      ; {#REGbc holds the 'character total' and a pixel line
 $0E29 LDIR          ; from each of the characters is 'scrolled'.}
 $0E2B LD B,$07      ; Now prepare to increment the address to jump across a
                     ; 'third' boundary.
@ignoreua
 $0E2D ADD HL,BC     ; Increase #REGhl by &0700.
 $0E2E AND $F8       ; {Jump back if there are any 'thirds' left to consider.
 $0E30 JR NZ,$0E0D   ; }
; Now find if the loop has been used eight times - once for each pixel line.
 $0E32 POP HL        ; Fetch the original address.
 $0E33 INC H         ; Address the next pixel line.
 $0E34 POP BC        ; Fetch the counters.
 $0E35 DEC C         ; {Decrease the pixel line counter and jump back unless
 $0E36 JR NZ,$0E05   ; eight lines have been moved.}
; Next the attribute bytes are scrolled. Note that the #REGb register still
; holds the number of lines to be scrolled and the #REGc register holds zero.
 $0E38 CALL $0E88    ; The required address in the attribute area and the
                     ; number of characters in #REGb lines are found.
 $0E3B LD HL,$FFE0   ; {The displacement for all the attribute bytes is thirty
 $0E3E ADD HL,DE     ; two locations away.
 $0E3F EX DE,HL      ; }
 $0E40 LDIR          ; The attribute bytes are 'scrolled'.
; It remains now to clear the bottom line of the display.
 $0E42 LD B,$01      ; The #REGb register is loaded with &01 and #R$0E44 is
                     ; entered.

; THE 'CLEAR LINES' SUBROUTINE
;
; Used by the routines at #R$0D6B, #R$0DAF and #R$1795.
; .
; The routine at #R$0DFE continues here.
; .
; This subroutine will clear the bottom #REGb lines of the display.
;
; B Number of lines to clear
@label=CL_LINE
c$0E44 PUSH BC        ; The line number is saved for the duration of the
                      ; subroutine.
 $0E45 CALL $0E9B     ; The starting address for the line is formed in #REGhl.
 $0E48 LD C,$08       ; Again there are eight pixel lines to be considered.
; Now enter a loop to clear all the pixel lines.
@label=CL_LINE_1
*$0E4A PUSH BC        ; Save the line number and the pixel line counter.
 $0E4B PUSH HL        ; Save the address.
 $0E4C LD A,B         ; Save the line number in #REGa.
@label=CL_LINE_2
*$0E4D AND $07        ; {Find how many characters are involved in '#REGb mod 8'
 $0E4F RRCA           ; lines. Pass the result to the #REGc register. (#REGc
 $0E50 RRCA           ; will hold &00, i.e. 256, for a 'third'.)
 $0E51 RRCA           ;
 $0E52 LD C,A         ; }
 $0E53 LD A,B         ; Fetch the line number.
 $0E54 LD B,$00       ; {Make the #REGbc register pair hold one less than the
 $0E56 DEC C          ; number of characters.}
 $0E57 LD D,H         ; {Make #REGde point to the first character.
 $0E58 LD E,L         ; }
 $0E59 LD (HL),$00    ; Clear the pixel-byte of the first character.
 $0E5B INC DE         ; {Make #REGde point to the second character and then
 $0E5C LDIR           ; clear the pixel-bytes of all the other characters.}
@keep
@ignoreua
 $0E5E LD DE,$0701    ; {For each 'third' of the display #REGhl has to be
 $0E61 ADD HL,DE      ; increased by &0701.}
 $0E62 DEC A          ; Now decrease the line number.
 $0E63 AND $F8        ; {Discard any extra lines and pass the 'third' count to
 $0E65 LD B,A         ; #REGb.}
 $0E66 JR NZ,$0E4D    ; Jump back if there are still 'thirds' to be dealt with.
; Now find if the loop has been used eight times.
 $0E68 POP HL         ; {Update the address for each pixel line.
 $0E69 INC H          ; }
 $0E6A POP BC         ; Fetch the counters.
 $0E6B DEC C          ; {Decrease the pixel line counter and jump back unless
 $0E6C JR NZ,$0E4A    ; finished.}
; Next the attribute bytes are set as required. The value in #SYSVAR(ATTR-P)
; will be used when handling the main part of the display and the value in
; #SYSVAR(BORDCR) when handling the lower part.
 $0E6E CALL $0E88     ; The address of the first attribute byte and the number
                      ; of bytes are found.
 $0E71 LD H,D         ; {#REGhl will point to the first attribute byte and
 $0E72 LD L,E         ; #REGde the second.
 $0E73 INC DE         ; }
 $0E74 LD A,($5C8D)   ; Fetch the value in #SYSVAR(ATTR-P).
 $0E77 BIT 0,(IY+$02) ; {Jump forward if handling the main part of the screen
 $0E7B JR Z,$0E80     ; (bit 0 of #SYSVAR(TV-FLAG) reset).}
 $0E7D LD A,($5C48)   ; Otherwise use #SYSVAR(BORDCR) instead.
@label=CL_LINE_3
*$0E80 LD (HL),A      ; Set the attribute byte.
 $0E81 DEC BC         ; One byte has been done.
 $0E82 LDIR           ; Now copy the value to all the attribute bytes.
 $0E84 POP BC         ; Restore the line number.
 $0E85 LD C,$21       ; {Set the column number to the lefthand column and
 $0E87 RET            ; return.}

; THE 'CL-ATTR' SUBROUTINE
;
; Used by the routines at #R$0DFE and #R$0E44.
; .
; This subroutine has two separate functions.
; .
; #LIST
; { For a given display area address the appropriate attribute address is
; returned in the #REGde register pair. Note that the value on entry points to
; the 'ninth' line of a character. }
; { For a given line number, in the #REGb register, the number of character
; areas in the display from the start of that line onwards is returned in the
; #REGbc register pair. }
; LIST#
;
;   B Line number
;   C &00
;   HL Display file address
; O:BC Number of spaces from the given line number (#REGb) downwards
; O:DE Corresponding attribute file address
@label=CL_ATTR
c$0E88 LD A,H        ; Fetch the high byte.
 $0E89 RRCA          ; {Multiply this value by thirty two.
 $0E8A RRCA          ;
 $0E8B RRCA          ; }
 $0E8C DEC A         ; Go back to the 'eight' line.
 $0E8D OR $50        ; Address the attribute area.
 $0E8F LD H,A        ; {Restore to the high byte and transfer the address to
 $0E90 EX DE,HL      ; #REGde.}
 $0E91 LD H,C        ; This is always zero.
 $0E92 LD L,B        ; The line number.
 $0E93 ADD HL,HL     ; {Multiply by thirty two.
 $0E94 ADD HL,HL     ;
 $0E95 ADD HL,HL     ;
 $0E96 ADD HL,HL     ;
 $0E97 ADD HL,HL     ; }
 $0E98 LD B,H        ; {Move the result to the #REGbc register pair before
 $0E99 LD C,L        ; returning.
 $0E9A RET           ; }

; THE 'CL-ADDR' SUBROUTINE
;
; Used by the routines at #R$0C55, #R$0DD9, #R$0DFE and #R$0E44.
; .
; For a given line number, in the #REGb register, the appropriate display file
; address is formed in the #REGhl register pair.
;
;   B Line number
; O:HL Display file address
@label=CL_ADDR
c$0E9B LD A,$18      ; {The line number has to be reversed.
 $0E9D SUB B         ; }
 $0E9E LD D,A        ; The result is saved in #REGd.
 $0E9F RRCA          ; {In effect '(#REGa mod 8)*32'. In a 'third' of the
 $0EA0 RRCA          ; display the low byte for the first line is &00, for the
 $0EA1 RRCA          ; second line &20, etc.
 $0EA2 AND $E0       ; }
 $0EA4 LD L,A        ; The low byte goes into #REGl.
 $0EA5 LD A,D        ; The true line number is fetched.
 $0EA6 AND $18       ; {In effect '64+8*INT (#REGa/8)'. For the upper 'third'
 $0EA8 OR $40        ; of the display the high byte is &40, for the middle
                     ; 'third' &48, and for the lower 'third' &50.}
 $0EAA LD H,A        ; The high byte goes to #REGh.
 $0EAB RET           ; Finished.

; THE 'COPY' COMMAND ROUTINE
;
; The address of this routine is found in the #R$1AD6(parameter table).
; .
; The one hundred and seventy six pixel lines of the display are dealt with one
; by one.
@refs=$1C0D
@label=COPY
c$0EAC DI            ; The maskable interrupt is disabled during COPY.
 $0EAD LD B,$B0      ; The 176 lines.
 $0EAF LD HL,$4000   ; The base address of the display.
; The following loop is now entered.
@label=COPY_1
*$0EB2 PUSH HL       ; {Save the base address and the number of the line.
 $0EB3 PUSH BC       ; }
 $0EB4 CALL $0EF4    ; It is called 176 times.
 $0EB7 POP BC        ; {Fetch the line number and the base address.
 $0EB8 POP HL        ; }
 $0EB9 INC H         ; The base address is updated by 256 locations for each
                     ; line of pixels.
 $0EBA LD A,H        ; {Jump forward and hence round the loop again directly
 $0EBB AND $07       ; for the eight pixel lines of a character line.
 $0EBD JR NZ,$0EC9   ; }
; For each new line of characters the base address has to be updated.
 $0EBF LD A,L        ; Fetch the low byte.
 $0EC0 ADD A,$20     ; Update it by &20 bytes.
 $0EC2 LD L,A        ; The carry flag will be reset when 'within thirds' of the
                     ; display.
 $0EC3 CCF           ; Change the carry flag.
 $0EC4 SBC A,A       ; {The #REGa register will hold &F8 when within a 'third'
 $0EC5 AND $F8       ; but &00 when a new 'third' is reached.}
 $0EC7 ADD A,H       ; {The high byte of the address is now updated.
 $0EC8 LD H,A        ; }
@label=COPY_2
*$0EC9 DJNZ $0EB2    ; Jump back until 176 lines have been printed.
 $0ECB JR $0EDA      ; Jump forward to the end routine.

; THE 'COPY-BUFF' SUBROUTINE
;
; Used by the routines at #R$0A4F, #R$0B24 and #R$12A2.
; .
; This subroutine is called whenever the printer buffer is to have its contents
; passed to the printer.
@label=COPY_BUFF
c$0ECD DI            ; Disable the maskable interrupt.
 $0ECE LD HL,$5B00   ; The base address of the printer buffer.
 $0ED1 LD B,$08      ; There are eight pixel lines.
@label=COPY_3
*$0ED3 PUSH BC       ; Save the line number.
 $0ED4 CALL $0EF4    ; Print the line.
 $0ED7 POP BC        ; Fetch the line number.
 $0ED8 DJNZ $0ED3    ; Jump back until 8 lines have been printed.
; This entry point is used by the routine at #R$0EAC.
@label=COPY_END
*$0EDA LD A,$04      ; {Stop the printer motor.
 $0EDC OUT ($FB),A   ; }
 $0EDE EI            ; Enable the maskable interrupt and continue into #R$0EDF.

; THE 'CLEAR PRINTER BUFFER' SUBROUTINE
;
; Used by the routines at #R$0EF4 and #R$11B7.
; .
; The printer buffer is cleared by calling this subroutine.
@label=CLEAR_PRB
c$0EDF LD HL,$5B00    ; The base address of the printer buffer.
 $0EE2 LD (IY+$46),L  ; Reset the printer 'column' at #SYSVAR(PR-CC).
 $0EE5 XOR A          ; Clear the #REGa register.
 $0EE6 LD B,A         ; Also clear the #REGb register (in effect #REGb holds
                      ; 256).
@label=PRB_BYTES
*$0EE7 LD (HL),A      ; {The 256 bytes of the printer buffer are all cleared in
 $0EE8 INC HL         ; turn.
 $0EE9 DJNZ $0EE7     ; }
 $0EEB RES 1,(IY+$30) ; Signal 'the buffer is empty' (reset bit 1 of
                      ; #R$5C6A(FLAGS2)).
 $0EEF LD C,$21       ; {Set the printer position and return via #R$0DD9 and
 $0EF1 JP $0DD9       ; #R$0ADC.}

; THE 'COPY-LINE' SUBROUTINE
;
; Used by the routines at #R$0EAC and #R$0ECD.
; .
; The subroutine is entered with the #REGhl register pair holding the base
; address of the thirty two bytes that form the pixel-line and the #REGb
; register holding the pixel-line number.
;
; B Pixel line number (&01 to &B0)
; HL Display file address or printer buffer address
@label=COPY_LINE
c$0EF4 LD A,B        ; Copy the pixel-line number.
 $0EF5 CP $03        ; {The #REGa register will hold &00 until the last two
 $0EF7 SBC A,A       ; lines are being handled.
 $0EF8 AND $02       ; }
 $0EFA OUT ($FB),A   ; Slow the motor for the last two pixel lines only.
 $0EFC LD D,A        ; The #REGd register will hold either &00 or &02.
; There are three tests to be made before doing any 'printing'.
@label=COPY_L_1
*$0EFD CALL $1F54    ; {Jump forward unless the BREAK key is being pressed.
 $0F00 JR C,$0F0C    ; }
 $0F02 LD A,$04      ; {But if it is then stop the motor, enable the maskable
 $0F04 OUT ($FB),A   ; interrupt, clear the printer buffer and exit via the
 $0F06 EI            ; error handling routine - 'BREAK-CONT repeats'.
 $0F07 CALL $0EDF    ;
 $0F0A RST $08       ;
 $0F0B DEFB $0C      ; }
@label=COPY_L_2
*$0F0C IN A,($FB)    ; {Fetch the status of the printer.
 $0F0E ADD A,A       ; }
 $0F0F RET M         ; Make an immediate return if the printer is not present.
 $0F10 JR NC,$0EFD   ; Wait for the stylus.
 $0F12 LD C,$20      ; There are thirty two bytes.
; Now enter a loop to handle these bytes.
@label=COPY_L_3
*$0F14 LD E,(HL)     ; Fetch a byte.
 $0F15 INC HL        ; Update the pointer.
 $0F16 LD B,$08      ; Eight bits per byte.
@label=COPY_L_4
*$0F18 RL D          ; Move #REGd left.
 $0F1A RL E          ; Move each bit into the carry.
 $0F1C RR D          ; Move #REGd back again, picking up the carry from #REGe.
@label=COPY_L_5
*$0F1E IN A,($FB)    ; {Again fetch the status of the printer and wait for the
 $0F20 RRA           ; signal from the encoder.
 $0F21 JR NC,$0F1E   ; }
 $0F23 LD A,D        ; {Now go ahead and pass the 'bit' to the printer. Note:
 $0F24 OUT ($FB),A   ; bit 2 low starts the motor, bit 1 high slows the motor,
                     ; and bit 7 is high for the actual 'printing'.}
 $0F26 DJNZ $0F18    ; 'Print' each bit.
 $0F28 DEC C         ; Decrease the byte counter.
 $0F29 JR NZ,$0F14   ; {Jump back whilst there are still bytes; otherwise
 $0F2B RET           ; return.}

; THE 'EDITOR' ROUTINES
;
; Used by the routines at #R$12A2 and #R$2089.
; .
; The editor is called on two occasions:
; .
; #LIST
; { From the #R$12A2(main execution routine) so that the user can enter a BASIC
; line into the system. }
; { From the #R$2089(INPUT command routine). }
; LIST#
; .
; First the 'error stack pointer' is saved and an alternative address provided.
@label=EDITOR
c$0F2C LD HL,($5C3D)  ; {The current value of #SYSVAR(ERR-SP) is saved on the
 $0F2F PUSH HL        ; machine stack.}
; This entry point is used by the routine at #R$107F.
@nowarn
@label=ED_AGAIN
*$0F30 LD HL,$107F    ; This is #R$107F.
 $0F33 PUSH HL        ; {Any event that leads to the error handling routine
 $0F34 LD ($5C3D),SP  ; (see #SYSVAR(ERR-SP)) being used will come back to
                      ; #R$107F.}
; A loop is now entered to handle each keystroke.
@label=ED_LOOP
 $0F38 CALL $15D4     ; Return once a key has been pressed.
 $0F3B PUSH AF        ; Save the code temporarily.
 $0F3C LD D,$00       ; {Fetch the duration of the keyboard click
 $0F3E LD E,(IY-$01)  ; (#SYSVAR(PIP)).}
@keep
 $0F41 LD HL,$00C8    ; And the pitch.
 $0F44 CALL $03B5     ; Now make the 'pip'.
 $0F47 POP AF         ; Restore the code.
@nowarn
 $0F48 LD HL,$0F38    ; {Pre-load the machine stack with the address of
 $0F4B PUSH HL        ; #R$0F38.}
; Now analyse the code obtained.
 $0F4C CP $18         ; {Accept all character codes, graphic codes and tokens.
 $0F4E JR NC,$0F81    ; }
 $0F50 CP $07         ; {Also accept ','.
 $0F52 JR C,$0F81     ; }
 $0F54 CP $10         ; {Jump forward if the code represents an editing key.
 $0F56 JR C,$0F92     ; }
; The control keys - INK to TAB - are now considered.
@keep
 $0F58 LD BC,$0002    ; INK and PAPER will require two locations.
 $0F5B LD D,A         ; Copy the code to #REGd.
 $0F5C CP $16         ; {Jump forward with INK and PAPER.
 $0F5E JR C,$0F6C     ; }
; AT and TAB would be handled as follows:
 $0F60 INC BC         ; Three locations required.
 $0F61 BIT 7,(IY+$37) ; {Jump forward unless dealing with 'INPUT LINE...' (bit
 $0F65 JP Z,$101E     ; 7 of #SYSVAR(FLAGX) set).}
 $0F68 CALL $15D4     ; {Get the second code and put it in #REGe.
 $0F6B LD E,A         ; }
; The other bytes for the control characters are now fetched.
@label=ED_CONTR
*$0F6C CALL $15D4     ; Get another code.
 $0F6F PUSH DE        ; Save the previous codes.
 $0F70 LD HL,($5C5B)  ; Fetch #SYSVAR(K-CUR).
 $0F73 RES 0,(IY+$07) ; Signal 'K mode' (reset bit 0 of #SYSVAR(MODE)).
 $0F77 CALL $1655     ; Make two or three spaces.
 $0F7A POP BC         ; Restore the previous codes.
 $0F7B INC HL         ; Point to the first location.
 $0F7C LD (HL),B      ; Enter first code.
 $0F7D INC HL         ; {Then enter the second code which will be overwritten
 $0F7E LD (HL),C      ; if there are only two codes - i.e. with INK and PAPER.}
 $0F7F JR $0F8B       ; Jump forward.
; This entry point is used by the routine at #R$1076.
; .
; The address of this entry point is found in the #R$15AF(initial channel
; information table).
; .
; The following subroutine actually adds a code to the current EDIT or INPUT
; line.
@refs=$15EF
@label=ADD_CHAR
*$0F81 RES 0,(IY+$07) ; Signal 'K mode' (reset bit 0 of #SYSVAR(MODE)).
 $0F85 LD HL,($5C5B)  ; Fetch the cursor position (#SYSVAR(K-CUR)).
 $0F88 CALL $1652     ; Make a single space.
@label=ADD_CH_1
*$0F8B LD (DE),A      ; {Enter the code into the space and set #SYSVAR(K-CUR)
 $0F8C INC DE         ; to signal that the cursor is to occur at the location
 $0F8D LD ($5C5B),DE  ; after. Then return indirectly to #R$0F38.
 $0F91 RET            ; }
; The editing keys are dealt with as follows:
@label=ED_KEYS
*$0F92 LD E,A         ; {The code is transferred to the #REGde register pair.
 $0F93 LD D,$00       ; }
@nowarn
@ssub=LD HL,$0FA0-$07
 $0F95 LD HL,$0F99    ; The base address of the #R$0FA0(editing keys table).
 $0F98 ADD HL,DE      ; {The entry is addressed and then fetched into #REGe.
 $0F99 LD E,(HL)      ; }
 $0F9A ADD HL,DE      ; {The address of the handling routine is saved on the
 $0F9B PUSH HL        ; machine stack.}
 $0F9C LD HL,($5C5B)  ; {The #REGhl register pair is set to #SYSVAR(K-CUR) and
 $0F9F RET            ; an indirect jump made to the required routine.}

; THE 'EDITING KEYS' TABLE
;
; Used by the routine at #R$0F2C.
@label=EDITKEYS
b$0FA0 DEFB $09      ; EDIT (#R$0FA9)
 $0FA1 DEFB $66      ; Cursor left (#R$1007)
 $0FA2 DEFB $6A      ; Cursor right (#R$100C)
 $0FA3 DEFB $50      ; Cursor down (#R$0FF3)
 $0FA4 DEFB $B5      ; Cursor up (#R$1059)
 $0FA5 DEFB $70      ; DELETE (#R$1015)
 $0FA6 DEFB $7E      ; ENTER (#R$1024)
 $0FA7 DEFB $CF      ; SYMBOL SHIFT (#R$1076)
 $0FA8 DEFB $D4      ; GRAPHICS (#R$107C)

; THE 'EDIT KEY' SUBROUTINE
;
; The address of this routine is derived from an offset found in the
; #R$0FA0(editing keys table).
; .
; When in 'editing mode' pressing the EDIT key will bring down the 'current
; BASIC line'. However in 'INPUT mode' the action of the EDIT key is to clear
; the current reply and allow a fresh one.
@refs=$0F2C
@label=ED_EDIT
c$0FA9 LD HL,($5C49)  ; Fetch the current line number (#SYSVAR(E-PPC)).
 $0FAC BIT 5,(IY+$37) ; {But jump forward if in 'INPUT mode' (bit 5 of
 $0FB0 JP NZ,$1097    ; #SYSVAR(FLAGX) set).}
 $0FB3 CALL $196E     ; {Find the address of the start of the current line and
 $0FB6 CALL $1695     ; hence its number.}
 $0FB9 LD A,D         ; {If the line number returned is zero then simply clear
 $0FBA OR E           ; the editing area.
 $0FBB JP Z,$1097     ; }
 $0FBE PUSH HL        ; Save the address of the line.
 $0FBF INC HL         ; {Move on to collect the length of the line.
 $0FC0 LD C,(HL)      ;
 $0FC1 INC HL         ;
 $0FC2 LD B,(HL)      ; }
@keep
 $0FC3 LD HL,$000A    ; {Add &0A to the length and test that there is
 $0FC6 ADD HL,BC      ; sufficient room for a copy of the line.
 $0FC7 LD B,H         ;
 $0FC8 LD C,L         ;
 $0FC9 CALL $1F05     ; }
 $0FCC CALL $1097     ; Now clear the editing area.
 $0FCF LD HL,($5C51)  ; {Fetch the current channel address (#SYSVAR(CURCHL))
 $0FD2 EX (SP),HL     ; and exchange it for the address of the line.}
 $0FD3 PUSH HL        ; Save it temporarily.
 $0FD4 LD A,$FF       ; {Open channel 'R' so that the line will be copied to
 $0FD6 CALL $1601     ; the editing area.}
 $0FD9 POP HL         ; Fetch the address of the line.
 $0FDA DEC HL         ; Go to before the line.
 $0FDB DEC (IY+$0F)   ; Decrement the current line number (#SYSVAR(E-PPC)) so
                      ; as to avoid printing the cursor.
 $0FDE CALL $1855     ; Print the BASIC line.
 $0FE1 INC (IY+$0F)   ; Increment the current line number (#SYSVAR(E-PPC)).
                      ; Note: the decrementing of the line number
                      ; #BUG#curseTheCursor(does not always stop the cursor
                      ; from being printed).
 $0FE4 LD HL,($5C59)  ; {Fetch the start of the line in the editing area
 $0FE7 INC HL         ; (#SYSVAR(E-LINE)) and step past the line number and the
 $0FE8 INC HL         ; length to find the address for #SYSVAR(K-CUR).
 $0FE9 INC HL         ;
 $0FEA INC HL         ;
 $0FEB LD ($5C5B),HL  ; }
 $0FEE POP HL         ; {Fetch the former channel address and set the
 $0FEF CALL $1615     ; appropriate flags before returning to #R$0F38.
 $0FF2 RET            ; }

; THE 'CURSOR DOWN EDITING' SUBROUTINE
;
; The address of this routine is derived from an offset found in the
; #R$0FA0(editing keys table).
@refs=$0F2C
@label=ED_DOWN
c$0FF3 BIT 5,(IY+$37)  ; {Jump forward if in 'INPUT mode' (bit 5 of
 $0FF7 JR NZ,$1001     ; #SYSVAR(FLAGX) set).}
 $0FF9 LD HL,$5C49     ; This is #SYSVAR(E-PPC).
 $0FFC CALL $190F      ; {The next line number is found and a new automatic
 $0FFF JR $106E        ; listing produced.}
@label=ED_STOP
*$1001 LD (IY+$00),$10 ; 'STOP in INPUT' report (#SYSVAR(ERR-NR)).
 $1005 JR $1024        ; Jump forward.

; THE 'CURSOR LEFT EDITING' SUBROUTINE
;
; The address of this routine is derived from an offset found in the
; #R$0FA0(editing keys table).
;
; HL Address of the cursor (#SYSVAR(K-CUR))
@refs=$0F2C
@label=ED_LEFT
c$1007 CALL $1031    ; The cursor is moved.
 $100A JR $1011      ; Jump forward.

; THE 'CURSOR RIGHT EDITING' SUBROUTINE
;
; The address of this routine is derived from an offset found in the
; #R$0FA0(editing keys table).
;
; HL Address of the cursor (#SYSVAR(K-CUR))
@refs=$0F2C
@label=ED_RIGHT
c$100C LD A,(HL)     ; {The current character is tested and if it is 'carriage
 $100D CP $0D        ; return' then return.
 $100F RET Z         ; }
 $1010 INC HL        ; Otherwise make the cursor come after the character.
; This entry point is used by the routine at #R$1007.
@label=ED_CUR
*$1011 LD ($5C5B),HL ; Set the system variable #SYSVAR(K-CUR).
 $1014 RET           ;

; THE 'DELETE EDITING' SUBROUTINE
;
; The address of this routine is derived from an offset found in the
; #R$0FA0(editing keys table).
;
; HL Address of the cursor (#SYSVAR(K-CUR))
@refs=$0F2C
@label=ED_DELETE
c$1015 CALL $1031    ; Move the cursor leftwards.
@keep
 $1018 LD BC,$0001   ; {Reclaim the current character.
 $101B JP $19E8      ; }

; THE 'ED-IGNORE' SUBROUTINE
;
; Used by the routine at #R$0F2C.
@label=ED_IGNORE
c$101E CALL $15D4    ; {The next two codes from the key-input routine are
 $1021 CALL $15D4    ; ignored.}
; This routine continues into #R$1024.

; THE 'ENTER EDITING' SUBROUTINE
;
; Used by the routines at #R$0FF3 and #R$1076.
; .
; The routine at #R$101E continues here.
; .
; The address of this routine is derived from an offset found in the
; #R$0FA0(editing keys table).
@refs=$0F2C
@label=ED_ENTER
c$1024 POP HL         ; {The addresses of #R$0F38 and #R$107F are discarded.
 $1025 POP HL         ; }
; This entry point is used by the routine at #R$107F.
@label=ED_END
*$1026 POP HL         ; {The old value of #SYSVAR(ERR-SP) is restored.
 $1027 LD ($5C3D),HL  ; }
 $102A BIT 7,(IY+$00) ; {Now return if there were no errors (#SYSVAR(ERR-NR) is
 $102E RET NZ         ; &FF).}
 $102F LD SP,HL       ; {Otherwise make an indirect jump to the error routine.
 $1030 RET            ; }

; THE 'ED-EDGE' SUBROUTINE
;
; Used by the routines at #R$1007 and #R$1015.
; .
; The address of the cursor is in the #REGhl register pair and will be
; decremented unless the cursor is already at the start of the line. Care is
; taken not to put the cursor between control characters and their parameters.
;
;   HL Address of the cursor (#SYSVAR(K-CUR))
; O:HL New address of the cursor
@label=ED_EDGE
c$1031 SCF           ; {#REGde will hold either #SYSVAR(E-LINE) (for editing)
 $1032 CALL $1195    ; or #SYSVAR(WORKSP) (for INPUTing).}
 $1035 SBC HL,DE     ; {The carry flag will become set if the cursor is already
 $1037 ADD HL,DE     ; to be at the start of the line.}
 $1038 INC HL        ; Correct for the subtraction.
 $1039 POP BC        ; Drop the return address.
 $103A RET C         ; Return via #R$0F38 if the carry flag is set.
 $103B PUSH BC       ; Restore the return address.
 $103C LD B,H        ; {Move the current address of the cursor to #REGbc.
 $103D LD C,L        ; }
; Now enter a loop to check that control characters are not split from their
; parameters.
@label=ED_EDGE_1
*$103E LD H,D        ; {#REGhl will point to the character in the line after
 $103F LD L,E        ; that addressed by #REGde.
 $1040 INC HL        ; }
 $1041 LD A,(DE)     ; Fetch a character code.
 $1042 AND $F0       ; {Jump forward if the code does not represent INK to TAB.
 $1044 CP $10        ;
 $1046 JR NZ,$1051   ; }
 $1048 INC HL        ; Allow for one parameter.
 $1049 LD A,(DE)     ; Fetch the code anew.
 $104A SUB $17       ; Carry is reset for TAB.
 $104C ADC A,$00     ; Note: this splits off AT and TAB but AT and TAB in this
                     ; form are not implemented anyway so it makes no
                     ; difference.
 $104E JR NZ,$1051   ; {Jump forward unless dealing with AT and TAB which would
 $1050 INC HL        ; have two parameters, if used.}
@label=ED_EDGE_2
*$1051 AND A         ; Prepare for true subtraction.
 $1052 SBC HL,BC     ; {The carry flag will be reset when the 'updated pointer'
 $1054 ADD HL,BC     ; reaches #SYSVAR(K-CUR).}
 $1055 EX DE,HL      ; {For the next loop use the 'updated pointer', but if
 $1056 JR C,$103E    ; exiting use the 'present pointer' for #SYSVAR(K-CUR).
 $1058 RET           ; Note: it is the control character that is deleted when
                     ; using DELETE.}

; THE 'CURSOR UP EDITING' SUBROUTINE
;
; The address of this routine is derived from an offset found in the
; #R$0FA0(editing keys table).
@refs=$0F2C
@label=ED_UP
c$1059 BIT 5,(IY+$37) ; {Return if in 'INPUT mode' (bit 5 of #SYSVAR(FLAGX)
 $105D RET NZ         ; set).}
 $105E LD HL,($5C49)  ; {Fetch the current line number (#SYSVAR(E-PPC)) and its
 $1061 CALL $196E     ; start address.}
 $1064 EX DE,HL       ; #REGhl now points to the previous line.
 $1065 CALL $1695     ; This line's number is fetched.
@keep=$01
@ssub=LD HL,$5C49+$01
 $1068 LD HL,$5C4A    ; This is #SYSVAR(E-PPC-hi).
 $106B CALL $191C     ; The line number is stored.
; This entry point is used by the routine at #R$0FF3.
@label=ED_LIST
*$106E CALL $1795     ; {A new automatic listing is now produced and channel
 $1071 LD A,$00       ; 'K' re-opened before returning to #R$0F38.
 $1073 JP $1601       ; }

; THE 'ED-SYMBOL' SUBROUTINE
;
; The address of this routine is derived from an offset found in the
; #R$0FA0(editing keys table).
;
; A Code of the last key pressed
;
; If SYMBOL and GRAPHICS codes were used they would be handled as follows:
@refs=$0F2C
@label=ED_SYMBOL
c$1076 BIT 7,(IY+$37) ; {Jump back unless dealing with INPUT LINE (bit 7 of
 $107A JR Z,$1024     ; #SYSVAR(FLAGX) set).}
; The address of this entry point is derived from an offset found in the
; #R$0FA0(editing keys table).
@label=ED_GRAPH
 $107C JP $0F81       ; Jump back.

; THE 'ED-ERROR' SUBROUTINE
;
; Used by the routine at #R$0F2C.
; .
; Come here when there has been some kind of error.
@refs=$0F2C
@label=ED_ERROR
c$107F BIT 4,(IY+$30)  ; {Jump back if using other than channel 'K' (bit 4 of
 $1083 JR Z,$1026      ; #R$5C6A(FLAGS2) reset).}
 $1085 LD (IY+$00),$FF ; {Cancel the error number (#SYSVAR(ERR-NR)) and give a
 $1089 LD D,$00        ; 'rasp' (see #SYSVAR(RASP)) before going around the
 $108B LD E,(IY-$02)   ; editor again.
 $108E LD HL,$1A90     ;
 $1091 CALL $03B5      ;
 $1094 JP $0F30        ; }

; THE 'CLEAR-SP' SUBROUTINE
;
; Used by the routines at #R$0FA9 and #R$12A2.
; .
; The editing area or the work space is cleared as directed.
@label=CLEAR_SP
c$1097 PUSH HL         ; Save the pointer to the space.
 $1098 CALL $1190      ; {#REGde will point to the first character and #REGhl
 $109B DEC HL          ; the last.}
 $109C CALL $19E5      ; The correct amount is now reclaimed.
 $109F LD ($5C5B),HL   ; {The system variables #SYSVAR(K-CUR) and #SYSVAR(MODE)
 $10A2 LD (IY+$07),$00 ; ('K mode') are initialised before fetching the pointer
 $10A6 POP HL          ; and returning.
 $10A7 RET             ; }

; THE 'KEYBOARD INPUT' SUBROUTINE
;
; The address of this routine is found in the #R$15AF(initial channel
; information table).
; .
; This important subroutine returns the code of the last key to have been
; pressed, but note that CAPS LOCK, the changing of the mode and the colour
; control parameters are handled within the subroutine.
;
; O:A Code of the last key pressed
; O:F Carry flag set if a key was pressed
@refs=$15E6
@label=KEY_INPUT
c$10A8 BIT 3,(IY+$02) ; {Copy the edit-line or the INPUT-line to the screen if
 $10AC CALL NZ,$111D  ; the mode has changed (bit 3 of #SYSVAR(TV-FLAG) set).}
 $10AF AND A          ; {Return with both carry and zero flags reset if no new
 $10B0 BIT 5,(IY+$01) ; key has been pressed (bit 5 of #SYSVAR(FLAGS) reset).
 $10B4 RET Z          ; }
 $10B5 LD A,($5C08)   ; {Otherwise fetch the code (#SYSVAR(LAST-K)) and signal
 $10B8 RES 5,(IY+$01) ; that it has been taken (reset bit 5 of #SYSVAR(FLAGS)).
                      ; }
 $10BC PUSH AF        ; Save the code temporarily.
 $10BD BIT 5,(IY+$02) ; {Clear the lower part of the display if necessary (bit
 $10C1 CALL NZ,$0D6E  ; 5 of #SYSVAR(TV-FLAG) set), e.g. after 'scroll?'.}
 $10C4 POP AF         ; Fetch the code.
 $10C5 CP " "         ; {Accept all characters and token codes.
 $10C7 JR NC,$111B    ; }
 $10C9 CP $10         ; {Jump forward with most of the control character codes.
 $10CB JR NC,$10FA    ; }
 $10CD CP $06         ; {Jump forward with the 'mode' codes and the CAPS LOCK
 $10CF JR NC,$10DB    ; code.}
; Now deal with the FLASH, BRIGHT and INVERSE codes.
 $10D1 LD B,A         ; Save the code.
 $10D2 AND $01        ; Keep only bit 0.
 $10D4 LD C,A         ; #REGc holds &00 (=OFF) or &01 (=ON).
 $10D5 LD A,B         ; Fetch the code.
 $10D6 RRA            ; Rotate it once (losing bit 0).
 $10D7 ADD A,$12      ; {Increase it by &12 giving &12 for FLASH, &13 for
 $10D9 JR $1105       ; BRIGHT, and &14 for INVERSE.}
; The CAPS LOCK code and the mode codes are dealt with 'locally'.
@label=KEY_M_CL
*$10DB JR NZ,$10E6    ; Jump forward with 'mode' codes.
 $10DD LD HL,$5C6A    ; This is #R$5C6A(FLAGS2).
 $10E0 LD A,$08       ; {Flip bit 3 of #R$5C6A(FLAGS2). This is the CAPS LOCK
 $10E2 XOR (HL)       ; flag.
 $10E3 LD (HL),A      ; }
 $10E4 JR $10F4       ; Jump forward.
@label=KEY_MODE
*$10E6 CP $0E         ; {Check the lower limit.
 $10E8 RET C          ; }
 $10E9 SUB $0D        ; Reduce the range.
 $10EB LD HL,$5C41    ; This is #SYSVAR(MODE).
 $10EE CP (HL)        ; Has it been changed?
 $10EF LD (HL),A      ; Enter the new 'mode' code.
 $10F0 JR NZ,$10F4    ; {Jump if it has changed; otherwise make it 'L mode'.
 $10F2 LD (HL),$00    ; }
@label=KEY_FLAG
*$10F4 SET 3,(IY+$02) ; Signal 'the mode might have changed' (set bit 3 of
                      ; #SYSVAR(TV-FLAG)).
 $10F8 CP A           ; {Reset the carry flag and return.
 $10F9 RET            ; }
; The control key codes (apart from FLASH, BRIGHT and INVERSE) are manipulated.
@label=KEY_CONTR
*$10FA LD B,A         ; Save the code.
 $10FB AND $07        ; {Make the #REGc register hold the parameter (&00 to
 $10FD LD C,A         ; &07).}
 $10FE LD A,$10       ; #REGa now holds the INK code.
 $1100 BIT 3,B        ; {But if the code was an 'unshifted' code then make
 $1102 JR NZ,$1105    ; #REGa hold the PAPER code.
 $1104 INC A          ; }
; The parameter is saved in #SYSVAR(K-DATA) and the channel address changed
; from #R$10A8 to #R$110D.
@label=KEY_DATA
*$1105 LD (IY-$2D),C  ; Save the parameter at #SYSVAR(K-DATA).
@nowarn
 $1108 LD DE,$110D    ; This is #R$110D.
 $110B JR $1113       ; Jump forward.
; Note: on the first pass entering at #R$10A8 the #REGa register is returned
; holding a 'control code' and then on the next pass, entering at #R$110D, it
; is the parameter that is returned.
@label=KEY_NEXT
 $110D LD A,($5C0D)   ; Fetch the parameter (#SYSVAR(K-DATA)).
@nowarn
 $1110 LD DE,$10A8    ; This is #R$10A8.
; Now set the input address in the first channel area.
@label=KEY_CHAN
*$1113 LD HL,($5C4F)  ; {Fetch the channel address (#SYSVAR(CHANS)).
 $1116 INC HL         ;
 $1117 INC HL         ; }
 $1118 LD (HL),E      ; {Now set the input address.
 $1119 INC HL         ;
 $111A LD (HL),D      ; }
; Finally exit with the required code in the #REGa register.
@label=KEY_DONE_2
*$111B SCF            ; {Show a code has been found and return.
 $111C RET            ; }

; THE 'LOWER SCREEN COPYING' SUBROUTINE
;
; Used by the routines at #R$10A8 and #R$2089.
; .
; This subroutine is called whenever the line in the editing area or the INPUT
; area is to be printed in the lower part of the screen.
@label=ED_COPY
c$111D CALL $0D4D      ; Use the permanent colours.
 $1120 RES 3,(IY+$02)  ; {Signal that the 'mode is to be considered unchanged'
 $1124 RES 5,(IY+$02)  ; (reset bit 3 of #SYSVAR(TV-FLAG)) and the 'lower
                       ; screen does not need clearing' (reset bit 5).}
 $1128 LD HL,($5C8A)   ; {Save the current value of #SYSVAR(S-POSNL).
 $112B PUSH HL         ; }
 $112C LD HL,($5C3D)   ; {Keep the current value of #SYSVAR(ERR-SP).
 $112F PUSH HL         ; }
@nowarn
 $1130 LD HL,$1167     ; This is #R$1167.
 $1133 PUSH HL         ; {Push this address on to the machine stack to make
 $1134 LD ($5C3D),SP   ; #R$1167 the entry point following an error (see
                       ; #SYSVAR(ERR-SP)).}
 $1138 LD HL,($5C82)   ; {Push the value of #SYSVAR(ECHO-E) on to the stack.
 $113B PUSH HL         ; }
 $113C SCF             ; {Make #REGhl point to the start of the space and
 $113D CALL $1195      ; #REGde the end.
 $1140 EX DE,HL        ; }
 $1141 CALL $187D      ; Now print the line.
 $1144 EX DE,HL        ; {Exchange the pointers and print the cursor.
 $1145 CALL $18E1      ; }
 $1148 LD HL,($5C8A)   ; {Next fetch the current value of #SYSVAR(S-POSNL) and
 $114B EX (SP),HL      ; exchange it with #SYSVAR(ECHO-E).}
 $114C EX DE,HL        ; Pass #SYSVAR(ECHO-E) to #REGde.
 $114D CALL $0D4D      ; Again fetch the permanent colours.
; The remainder of any line that has been started is now completed with spaces
; printed with the 'permanent' PAPER colour.
@label=ED_BLANK
@keep=$01
@ssub=LD A,($5C8A+$01)
*$1150 LD A,($5C8B)    ; {Fetch the current line number from #SYSVAR(S-POSNL)
 $1153 SUB D           ; and subtract the old line number.}
 $1154 JR C,$117C      ; Jump forward if no 'blanking' of lines required.
 $1156 JR NZ,$115E     ; Jump forward if not on the same line.
 $1158 LD A,E          ; {Fetch the old column number and subtract the new
 $1159 SUB (IY+$50)    ; column number (at #SYSVAR(S-POSNL)).}
 $115C JR NC,$117C     ; Jump if no spaces required.
@label=ED_SPACES
*$115E LD A," "        ; A 'space'.
 $1160 PUSH DE         ; Save the old values.
 $1161 CALL $09F4      ; Print it.
 $1164 POP DE          ; Fetch the old values.
 $1165 JR $1150        ; Back again.
; New deal with any errors.
@label=ED_FULL
 $1167 LD D,$00        ; {Give out a 'rasp' (see #SYSVAR(RASP)).
 $1169 LD E,(IY-$02)   ;
 $116C LD HL,$1A90     ;
 $116F CALL $03B5      ; }
 $1172 LD (IY+$00),$FF ; Cancel the error number (#SYSVAR(ERR-NR)).
 $1176 LD DE,($5C8A)   ; {Fetch the current value of #SYSVAR(S-POSNL) and jump
 $117A JR $117E        ; forward.}
; The normal exit upon completion of the copying over of the edit or the INPUT
; line.
@label=ED_C_DONE
*$117C POP DE          ; The new position value.
 $117D POP HL          ; The 'error address'.
; But come here after an error.
@label=ED_C_END
*$117E POP HL          ; {The old value of #SYSVAR(ERR-SP) is restored.
 $117F LD ($5C3D),HL   ; }
 $1182 POP BC          ; Fetch the old value of #SYSVAR(S-POSNL).
 $1183 PUSH DE         ; Save the new position values.
 $1184 CALL $0DD9      ; Set the system variables.
 $1187 POP HL          ; {The old value of #SYSVAR(S-POSNL) goes into
 $1188 LD ($5C82),HL   ; #SYSVAR(ECHO-E).}
 $118B LD (IY+$26),$00 ; {#SYSVAR(X-PTR) is cleared in a suitable manner and
 $118F RET             ; the return made.}

; THE 'SET-HL' AND 'SET-DE' SUBROUTINES
;
; Used by the routine at #R$1097.
; .
; These subroutines return with #REGde pointing to the first location and
; #REGhl to the last location of either the editing area or the work space.
;
; O:DE Address of the first byte of the editing area or work space
; O:HL Address of the last byte of the editing area or work space
@label=SET_HL
c$1190 LD HL,($5C61)  ; {Point to the last location of the editing area
 $1193 DEC HL         ; (#SYSVAR(WORKSP)-1).}
 $1194 AND A          ; Clear the carry flag.
; This entry point is used by the routines at #R$1031 and #R$111D with the
; carry flag set.
@label=SET_DE
*$1195 LD DE,($5C59)  ; {Point to the start of the editing area
 $1199 BIT 5,(IY+$37) ; (#SYSVAR(E-LINE)) and return if in 'editing mode' (bit
 $119D RET Z          ; 5 of #SYSVAR(FLAGX) reset).}
 $119E LD DE,($5C61)  ; Otherwise point #REGde at the start of the work space
                      ; (#SYSVAR(WORKSP)).
 $11A2 RET C          ; Return if now intended.
 $11A3 LD HL,($5C63)  ; {Fetch #SYSVAR(STKBOT) and then return.
 $11A6 RET            ; }

; THE 'REMOVE-FP' SUBROUTINE
;
; Used by the routines at #R$12A2 and #R$2089.
; .
; This subroutine removes the hidden floating-point forms in a BASIC line.
;
; HL #SYSVAR(E-LINE) or #SYSVAR(WORKSP)
@label=REMOVE_FP
c$11A7 LD A,(HL)     ; Each character in turn is examined.
 $11A8 CP $0E        ; Is it a number marker?
@keep
 $11AA LD BC,$0006   ; It will occupy six locations.
 $11AD CALL Z,$19E8  ; Reclaim the floating point number.
 $11B0 LD A,(HL)     ; Fetch the code again.
 $11B1 INC HL        ; Update the pointer.
 $11B2 CP $0D        ; Is it a carriage return?
 $11B4 JR NZ,$11A7   ; {Back if not. But make a simple return if it is.
 $11B6 RET           ; }

; THE 'NEW' COMMAND ROUTINE
;
; The address of this routine is found in the #R$1AA8(parameter table).
@refs=$1C0D
@label=NEW
c$11B7 DI              ; Disable the maskable interrupt.
 $11B8 LD A,$FF        ; The NEW flag.
 $11BA LD DE,($5CB2)   ; The existing value of #SYSVAR(RAMTOP) is preserved.
 $11BE EXX             ; {Load the alternate registers with the following
 $11BF LD BC,($5CB4)   ; system variables (#SYSVAR(P-RAMT), #SYSVAR(RASP),
 $11C3 LD DE,($5C38)   ; #SYSVAR(PIP), #SYSVAR(UDG)). All of which will also be
 $11C7 LD HL,($5C7B)   ; preserved.
 $11CA EXX             ; }
; This entry point is used by the routine at #R$0000.
; .
; The main entry point.
@label=START_NEW
*$11CB LD B,A          ; Save the flag for later.
 $11CC LD A,$07        ; {Make the border white in colour.
 $11CE OUT ($FE),A     ; }
 $11D0 LD A,$3F        ; {Set the I register to hold the value of &3F.
 $11D2 LD I,A          ; }
 $11D4 NOP             ; {Wait 24 T states.
 $11D5 NOP             ;
 $11D6 NOP             ;
 $11D7 NOP             ;
 $11D8 NOP             ;
 $11D9 NOP             ; }
; Now the memory is checked.
 $11DA LD H,D          ; {Transfer the value in #REGde (#R$0000=&FFFF,
 $11DB LD L,E          ; #R$11B7=#SYSVAR(RAMTOP)).}
@label=RAM_FILL
@ignoreua
*$11DC LD (HL),$02     ; {Enter the value of &02 into every location above
 $11DE DEC HL          ; &3FFF.
 $11DF CP H            ;
 $11E0 JR NZ,$11DC     ; }
@label=RAM_READ
*$11E2 AND A           ; Prepare for true subtraction.
 $11E3 SBC HL,DE       ; {The carry flag will become reset when the top is
 $11E5 ADD HL,DE       ; reached.}
 $11E6 INC HL          ; Update the pointer.
 $11E7 JR NC,$11EF     ; Jump when at top.
 $11E9 DEC (HL)        ; &02 goes to &01.
 $11EA JR Z,$11EF      ; But if zero then RAM is faulty. Use current #REGhl as
                       ; top.
 $11EC DEC (HL)        ; &01 goes to &00.
 $11ED JR Z,$11E2      ; Step to the next test unless it fails.
@label=RAM_DONE
*$11EF DEC HL          ; #REGhl points to the last actual location in working
                       ; order.
; Next restore the 'preserved' system variables. (Meaningless when coming from
; #R$0000.)
 $11F0 EXX             ; {Restore #SYSVAR(P-RAMT), #SYSVAR(RASP), #SYSVAR(PIP)
 $11F1 LD ($5CB4),BC   ; and #SYSVAR(UDG).
 $11F5 LD ($5C38),DE   ;
 $11F9 LD ($5C7B),HL   ;
 $11FC EXX             ; }
 $11FD INC B           ; Test the #R$0000/#R$11B7 flag.
 $11FE JR Z,$1219      ; Jump forward if coming from the #R$11B7 command
                       ; routine.
; Overwrite the system variables when coming from #R$0000 and initialise the
; user-defined graphics area.
 $1200 LD ($5CB4),HL   ; Top of physical RAM (#SYSVAR(P-RAMT)).
@nowarn
@ssub=LD DE,$3D00+$01AF
 $1203 LD DE,$3EAF     ; Last byte of 'U' in character set.
@keep
 $1206 LD BC,$00A8     ; There are this number of bytes in twenty one letters.
 $1209 EX DE,HL        ; Switch the pointers.
 $120A LDDR            ; Now copy the character forms of the letters 'A' to
                       ; 'U'.
 $120C EX DE,HL        ; Switch the pointers back.
 $120D INC HL          ; Point to the first byte.
 $120E LD ($5C7B),HL   ; Now set #SYSVAR(UDG).
 $1211 DEC HL          ; Down one location.
@keep
 $1212 LD BC,$0040     ; {Set the system variables #SYSVAR(RASP) and
 $1215 LD ($5C38),BC   ; #SYSVAR(PIP).}
; The remainder of the routine is common to both the #R$0000 and the #R$11B7
; operations.
@label=RAM_SET
*$1219 LD ($5CB2),HL   ; Set #SYSVAR(RAMTOP).
@keep=$100
@ssub=LD HL,$3D00-$100
 $121C LD HL,$3C00     ; {Initialise the system variable #SYSVAR(CHARS).
 $121F LD ($5C36),HL   ; }
; Next the machine stack is set up.
 $1222 LD HL,($5CB2)   ; {The top location (#SYSVAR(RAMTOP)) is made to hold
 $1225 LD (HL),$3E     ; &3E.}
 $1227 DEC HL          ; The next location is left holding zero.
 $1228 LD SP,HL        ; These two locations represent the 'last entry'.
 $1229 DEC HL          ; {Step down two locations to find the correct value for
 $122A DEC HL          ; #SYSVAR(ERR-SP).
 $122B LD ($5C3D),HL   ; }
; The initialisation routine continues with:
 $122E IM 1            ; Interrupt mode 1 is used.
 $1230 LD IY,$5C3A     ; #REGiy holds +#SYSVAR(ERR-NR) always.
 $1234 EI              ; The maskable interrupt can now be enabled. The
                       ; real-time clock will be updated and the keyboard
                       ; scanned every 1/50th of a second.
 $1235 LD HL,$5CB6     ; {The system variable #SYSVAR(CHANS) is set to the base
 $1238 LD ($5C4F),HL   ; address of the #R$5CB6(channel information area).}
 $123B LD DE,$15AF     ; {The initial channel data is moved from the table
@keep
 $123E LD BC,$0015     ; (#R$15AF) to the channel information area.
 $1241 EX DE,HL        ;
 $1242 LDIR            ; }
 $1244 EX DE,HL        ; {The system variable #SYSVAR(DATADD) is made to point
 $1245 DEC HL          ; to the last location of the channel data.
 $1246 LD ($5C57),HL   ; }
 $1249 INC HL          ; {And #SYSVAR(PROG) and #SYSVAR(VARS) to the the
 $124A LD ($5C53),HL   ; location after that.
 $124D LD ($5C4B),HL   ; }
 $1250 LD (HL),$80     ; The end-marker of the variables area.
 $1252 INC HL          ; {Move on one location to find the value for
 $1253 LD ($5C59),HL   ; #SYSVAR(E-LINE).}
 $1256 LD (HL),$0D     ; {Make the edit-line be a single 'carriage return'
 $1258 INC HL          ; character.}
 $1259 LD (HL),$80     ; Now enter an end marker.
 $125B INC HL          ; {Move on one location to find the value for
 $125C LD ($5C61),HL   ; #SYSVAR(WORKSP), #SYSVAR(STKBOT) and #SYSVAR(STKEND).
 $125F LD ($5C63),HL   ;
 $1262 LD ($5C65),HL   ; }
 $1265 LD A,$38        ; {Initialise the colour system variables
 $1267 LD ($5C8D),A    ; (#SYSVAR(ATTR-P), #SYSVAR(ATTR-T), #SYSVAR(BORDCR)) to
 $126A LD ($5C8F),A    ; FLASH 0, BRIGHT 0, PAPER 7, INK 0, BORDER 7.
 $126D LD ($5C48),A    ; }
@keep
 $1270 LD HL,$0523     ; {Initialise the system variables #SYSVAR(REPDEL) and
 $1273 LD ($5C09),HL   ; #SYSVAR(REPPER).}
 $1276 DEC (IY-$3A)    ; Make #R$5C00(KSTATE0) hold &FF.
 $1279 DEC (IY-$36)    ; Make #R$5C04(KSTATE4) hold &FF.
 $127C LD HL,$15C6     ; {Next move the #R$15C6(initial stream data) from its
 $127F LD DE,$5C10     ; table to the #R$5C10(streams area).
@keep
 $1282 LD BC,$000E     ;
 $1285 LDIR            ; }
 $1287 SET 1,(IY+$01)  ; {Signal 'printer in use' (set bit 1 of #SYSVAR(FLAGS))
 $128B CALL $0EDF      ; and clear the printer buffer.}
 $128E LD (IY+$31),$02 ; {Set the size of the lower part of the display
 $1292 CALL $0D6B      ; (#SYSVAR(DF-SZ)) and clear the whole display.}
@ignoreua
 $1295 XOR A           ; {Now print the message '#CHR169 1982 Sinclair Research
@keep=$01
@ssub=LD DE,$1539-$01
 $1296 LD DE,$1538     ; Ltd' on the bottom line.
 $1299 CALL $0C0A      ; }
 $129C SET 5,(IY+$02)  ; Signal 'the lower part will required to be cleared'
                       ; (set bit 5 of #SYSVAR(TV-FLAG)).
 $12A0 JR $12A9        ; Jump forward into the main execution loop.

; THE 'MAIN EXECUTION' LOOP
;
; Used by the routine at #R$155D.
; .
; The main loop controls the 'editing mode', the execution of direct commands
; and the production of reports.
@label=MAIN_EXEC
c$12A2 LD (IY+$31),$02 ; The lower part of the screen is to be two lines in
                       ; size (see #SYSVAR(DF-SZ)).
 $12A6 CALL $1795      ; Produce an automatic listing.
; This entry point is used by the routine at #R$11B7.
@label=MAIN_1
*$12A9 CALL $16B0      ; All the areas from #SYSVAR(E-LINE) onwards are given
                       ; their minimum configurations.
@label=MAIN_2
*$12AC LD A,$00        ; {Channel 'K' is opened before calling the #R$0F2C.
 $12AE CALL $1601      ; }
 $12B1 CALL $0F2C      ; The #R$0F2C is called to allow the user to build up a
                       ; BASIC line.
 $12B4 CALL $1B17      ; The current line is scanned for correct syntax.
 $12B7 BIT 7,(IY+$00)  ; {Jump forward if the syntax is correct
 $12BB JR NZ,$12CF     ; (#SYSVAR(ERR-NR) is &FF).}
 $12BD BIT 4,(IY+$30)  ; {Jump forward if other than channel 'K' is being used
 $12C1 JR Z,$1303      ; (bit 4 of #R$5C6A(FLAGS2) is set).}
 $12C3 LD HL,($5C59)   ; Point to the start of the line with the error
                       ; (#SYSVAR(E-LINE)).
 $12C6 CALL $11A7      ; Remove the floating-point forms from this line.
 $12C9 LD (IY+$00),$FF ; {Reset #SYSVAR(ERR-NR) and jump back to #R$12AC
 $12CD JR $12AC        ; leaving the listing unchanged.}
; The 'edit-line' has passed syntax and the three types of line that are
; possible have to be distinguished from each other.
@label=MAIN_3
*$12CF LD HL,($5C59)   ; Point to the start of the line (#SYSVAR(E-LINE)).
 $12D2 LD ($5C5D),HL   ; Set #SYSVAR(CH-ADD) to the start also.
 $12D5 CALL $19FB      ; Fetch any line number into #REGbc.
 $12D8 LD A,B          ; {Is the line number a valid one?
 $12D9 OR C            ; }
 $12DA JP NZ,$155D     ; Jump if it is so, and add the new line to the existing
                       ; program.
 $12DD RST $18         ; {Fetch the first character of the line and see if the
 $12DE CP $0D          ; line is 'carriage return only'.}
 $12E0 JR Z,$12A2      ; If it is then jump back.
; The 'edit-line' must start with a direct BASIC command so this line becomes
; the first line to be interpreted.
 $12E2 BIT 0,(IY+$30)  ; {Clear the whole display unless the flag (bit 0 of
 $12E6 CALL NZ,$0DAF   ; #R$5C6A(FLAGS2)) says it is unnecessary.}
 $12E9 CALL $0D6E      ; Clear the lower part anyway.
 $12EC LD A,$19        ; {Set the appropriate value for the scroll counter
 $12EE SUB (IY+$4F)    ; (#SYSVAR(SCR-CT)) by subtracting the second byte of
 $12F1 LD ($5C8C),A    ; #SYSVAR(S-POSN) from &19).}
 $12F4 SET 7,(IY+$01)  ; Signal 'line execution' (set bit 7 of #SYSVAR(FLAGS)).
 $12F8 LD (IY+$00),$FF ; Ensure #SYSVAR(ERR-NR) is correct.
 $12FC LD (IY+$0A),$01 ; Deal with the first statement in the line (set
                       ; #SYSVAR(NSPPC) to &01).
 $1300 CALL $1B8A      ; Now the line is interpreted. Note: the address #R$1303
                       ; goes on to the machine stack and is addressed by
                       ; #SYSVAR(ERR-SP).
; After the line has been interpreted and all the actions consequential to it
; have been completed a return is made to #R$1303, so that a report can be
; made.
@label=MAIN_4
*$1303 HALT            ; The maskable interrupt must be enabled.
 $1304 RES 5,(IY+$01)  ; Signal 'ready for a new key' (reset bit 5 of
                       ; #SYSVAR(FLAGS)).
 $1308 BIT 1,(IY+$30)  ; {Empty the printer buffer if it has been used (bit 1
 $130C CALL NZ,$0ECD   ; of #R$5C6A(FLAGS2) set).}
 $130F LD A,($5C3A)    ; {Fetch the error number (#SYSVAR(ERR-NR)) and
 $1312 INC A           ; increment it.}
; This entry point is used by the routine at #R$1555.
@label=MAIN_G
*$1313 PUSH AF         ; Save the new value.
@keep
 $1314 LD HL,$0000     ; {The system variables #SYSVAR(FLAGX),
 $1317 LD (IY+$37),H   ; #SYSVAR(X-PTR-hi) and #SYSVAR(DEFADD) are all set to
 $131A LD (IY+$26),H   ; zero.
 $131D LD ($5C0B),HL   ; }
@keep
 $1320 LD HL,$0001     ; {Ensure that stream &00 points to channel 'K' (see
@ssub=LD ($5C10+$06),HL
 $1323 LD ($5C16),HL   ; #SYSVAR(STRMS)).}
 $1326 CALL $16B0      ; Clear all the work areas and the calculator stack.
 $1329 RES 5,(IY+$37)  ; Signal 'editing mode' (reset bit 5 of #SYSVAR(FLAGX)).
 $132D CALL $0D6E      ; Clear the lower screen.
 $1330 SET 5,(IY+$02)  ; Signal 'the lower screen will require clearing' (set
                       ; bit 5 of #SYSVAR(TV-FLAG)).
 $1334 POP AF          ; Fetch the report value.
 $1335 LD B,A          ; Make a copy in #REGb.
 $1336 CP $0A          ; {Jump forward with report numbers '0 to 9'.
 $1338 JR C,$133C      ; }
 $133A ADD A,$07       ; Add the ASCII letter offset value.
@label=MAIN_5
*$133C CALL $15EF      ; {Print the report code and follow it with a 'space'.
 $133F LD A," "        ;
 $1341 RST $10         ; }
 $1342 LD A,B          ; Fetch the report value (used to identify the required
                       ; report message).
 $1343 LD DE,$1391     ; {Print the message.
 $1346 CALL $0C0A      ; }
 $1349 XOR A           ; {Follow it by a 'comma' and a 'space'.
@keep=$01
@ssub=LD DE,$1537-$01
 $134A LD DE,$1536     ;
 $134D CALL $0C0A      ; }
 $1350 LD BC,($5C45)   ; {Now fetch the current line number (#SYSVAR(PPC)) and
 $1354 CALL $1A1B      ; print it as well.}
 $1357 LD A,":"        ; {Follow it by a ':'.
 $1359 RST $10         ; }
 $135A LD C,(IY+$0D)   ; {Fetch the current statement number (#SYSVAR(SUBPPC))
 $135D LD B,$00        ; into the #REGbc register pair and print it.
 $135F CALL $1A1B      ; }
 $1362 CALL $1097      ; Clear the editing area.
 $1365 LD A,($5C3A)    ; Fetch the error number (#SYSVAR(ERR-NR)) again.
 $1368 INC A           ; Increment it as usual.
 $1369 JR Z,$1386      ; If the program was completed successfully there cannot
                       ; be any 'CONTinuing' so jump.
 $136B CP $09          ; {If the program halted with 'STOP statement' or 'BREAK
 $136D JR Z,$1373      ; into program' CONTinuing will be from the next
 $136F CP $15          ; statement; otherwise #SYSVAR(SUBPPC) is unchanged.
 $1371 JR NZ,$1376     ;
@label=MAIN_6
*$1373 INC (IY+$0D)    ; }
@keep
@label=MAIN_7
*$1376 LD BC,$0003     ; {The system variables #SYSVAR(OLDPPC) and
 $1379 LD DE,$5C70     ; #SYSVAR(OSPCC) have now to be made to hold the
                       ; CONTinuing line and statement numbers.}
 $137C LD HL,$5C44     ; {The values used will be those in #SYSVAR(PPC) and
 $137F BIT 7,(HL)      ; #SYSVAR(SUBPPC) unless #SYSVAR(NSPPC) indicates that
 $1381 JR Z,$1384      ; the 'break' occurred before a 'jump' (i.e. after a GO
 $1383 ADD HL,BC       ; TO statement etc.).
@label=MAIN_8
*$1384 LDDR            ; }
@label=MAIN_9
*$1386 LD (IY+$0A),$FF ; #SYSVAR(NSPPC) is reset to indicate 'no jump'.
 $138A RES 3,(IY+$01)  ; 'K mode' is selected (reset bit 3 of #SYSVAR(FLAGS)).
 $138E JP $12AC        ; And finally the jump back is made but no program
                       ; listing will appear until requested.

; THE REPORT MESSAGES
;
; Used by the routine at #R$12A2.
; .
; Each message is given with the last character inverted (plus &80).
@label=REPORTS
t$1391 DEFB $80                           ; Initial byte is stepped over.
 $1392 DEFM "O","K"+$80                   ; 0 OK
 $1394 DEFM "NEXT without FO","R"+$80     ; 1 NEXT without FOR
 $13A4 DEFM "Variable not foun","d"+$80   ; 2 Variable not found
 $13B6 DEFM "Subscript wron","g"+$80      ; 3 Subscript wrong
 $13C5 DEFM "Out of memor","y"+$80        ; 4 Out of memory
 $13D2 DEFM "Out of scree","n"+$80        ; 5 Out of screen
 $13DF DEFM "Number too bi","g"+$80       ; 6 Number too big
 $13ED DEFM "RETURN without GOSU","B"+$80 ; 7 RETURN without GOSUB
 $1401 DEFM "End of fil","e"+$80          ; 8 End of file
 $140C DEFM "STOP statemen","t"+$80       ; 9 STOP statement
 $141A DEFM "Invalid argumen","t"+$80     ; A Invalid argument
 $142A DEFM "Integer out of rang","e"+$80 ; B Integer out of range
 $143E DEFM "Nonsense in BASI","C"+$80    ; C Nonsense in BASIC
 $144F DEFM "BREAK - CONT repeat","s"+$80 ; D BREAK - CONT repeats
 $1463 DEFM "Out of DAT","A"+$80          ; E Out of DATA
 $146E DEFM "Invalid file nam","e"+$80    ; F Invalid file name
 $147F DEFM "No room for lin","e"+$80     ; G No room for line
 $148F DEFM "STOP in INPU","T"+$80        ; H STOP in INPUT
 $149C DEFM "FOR without NEX","T"+$80     ; I FOR without NEXT
 $14AC DEFM "Invalid I/O devic","e"+$80   ; J Invalid I/O device
 $14BE DEFM "Invalid colou","r"+$80       ; K Invalid colour
 $14CC DEFM "BREAK into progra","m"+$80   ; L BREAK into program
 $14DE DEFM "RAMTOP no goo","d"+$80       ; M RAMTOP no good
 $14EC DEFM "Statement los","t"+$80       ; N Statement lost
 $14FA DEFM "Invalid strea","m"+$80       ; O Invalid stream
 $1508 DEFM "FN without DE","F"+$80       ; P FN without DEF
 $1516 DEFM "Parameter erro","r"+$80      ; Q Parameter error
 $1525 DEFM "Tape loading erro","r"+$80   ; R Tape loading error
@label=COMMA_SPC
 $1537 DEFM ","," "+$80                   ; ', '

; THE COPYRIGHT MESSAGE
;
; Used by the routine at #R$11B7.
@label=COPYRIGHT
@ignoreua
t$1539 DEFM $7F," 1982 Sinclair Research Lt","d"+$80 ; #CHR169 1982 Sinclair
                                                     ; Research Ltd

; Report G - No room for line
;
; Used by the routine at #R$155D.
@refs=$155D
@label=REPORT_G
c$1555 LD A,$10      ; 'G' has the code &10 plus &37.
@keep
 $1557 LD BC,$0000   ; Clear #REGbc.
 $155A JP $1313      ; Jump back to give the report.

; THE 'MAIN-ADD' SUBROUTINE
;
; Used by the routine at #R$12A2.
; .
; This subroutine allows for a new BASIC line to be added to the existing BASIC
; program in the program area. If a line has both an old and a new version then
; the old one is 'reclaimed'. A new line that consists of only a line number
; does not go into the program area.
;
; BC BASIC line number
@label=MAIN_ADD
c$155D LD ($5C49),BC ; Make the new line number the 'current line'
                     ; (#SYSVAR(E-PPC)).
 $1561 LD HL,($5C5D) ; {Fetch #SYSVAR(CH-ADD) and save the address in #REGde.
 $1564 EX DE,HL      ; }
@nowarn
 $1565 LD HL,$1555   ; {Push the address of #R$1555 on to the machine stack.
 $1568 PUSH HL       ; #SYSVAR(ERR-SP) will now point to #R$1555.}
 $1569 LD HL,($5C61) ; Fetch #SYSVAR(WORKSP).
 $156C SCF           ; {Find the length of the line from after the line number
 $156D SBC HL,DE     ; to the 'carriage return' character inclusively.}
 $156F PUSH HL       ; Save the length.
 $1570 LD H,B        ; {Move the line number to the #REGhl register pair.
 $1571 LD L,C        ; }
 $1572 CALL $196E    ; Is there an existing line with this number?
 $1575 JR NZ,$157D   ; Jump if there was not.
 $1577 CALL $19B8    ; {Find the length of the 'old' line and reclaim it.
 $157A CALL $19E8    ; }
@label=MAIN_ADD1
*$157D POP BC        ; {Fetch the length of the 'new' line and jump forward if
 $157E LD A,C        ; it is only a 'line number and a carriage return'.
 $157F DEC A         ;
 $1580 OR B          ;
 $1581 JR Z,$15AB    ; }
 $1583 PUSH BC       ; Save the length.
 $1584 INC BC        ; {Four extra locations will be needed, i.e. two for the
 $1585 INC BC        ; number and two for the length.
 $1586 INC BC        ;
 $1587 INC BC        ; }
 $1588 DEC HL        ; Make #REGhl point to the location before the
                     ; 'destination'.
 $1589 LD DE,($5C53) ; {Save the current value of #SYSVAR(PROG) to avoid
 $158D PUSH DE       ; corruption when adding a first line.}
 $158E CALL $1655    ; Space for the new line is created.
 $1591 POP HL        ; {The old value of #SYSVAR(PROG) is fetched and restored.
 $1592 LD ($5C53),HL ; }
 $1595 POP BC        ; {A copy of the line length (without parameters) is
 $1596 PUSH BC       ; taken.}
 $1597 INC DE        ; {Make #REGde point to the end location of the new area
 $1598 LD HL,($5C61) ; and #REGhl to the 'carriage return' character of the new
 $159B DEC HL        ; line in the editing area (#SYSVAR(WORKSP)-2).
 $159C DEC HL        ; }
 $159D LDDR          ; Now copy over the line.
 $159F LD HL,($5C49) ; Fetch the line's number (#R$5C49(E_PPC)).
 $15A2 EX DE,HL      ; Destination into #REGhl and number into #REGde.
 $15A3 POP BC        ; Fetch the new line's length.
 $15A4 LD (HL),B     ; {The high length byte.
 $15A5 DEC HL        ; }
 $15A6 LD (HL),C     ; {The low length byte.
 $15A7 DEC HL        ; }
 $15A8 LD (HL),E     ; {The low line number byte.
 $15A9 DEC HL        ; }
 $15AA LD (HL),D     ; The high line number byte.
@label=MAIN_ADD2
*$15AB POP AF        ; Drop the address of #R$1555.
 $15AC JP $12A2      ; Jump back and this time do produce an automatic listing.

; THE 'INITIAL CHANNEL INFORMATION'
;
; Used by the routine at #R$11B7, which copies the information from here to
; #SYSVAR(CHINFO).
; .
; Initially there are four channels - 'K', 'S', 'R', and 'P' - for
; communicating with the 'keyboard', 'screen', 'work space' and 'printer'. For
; each channel the output routine address comes before the input routine
; address and the channel's code.
@label=CHANINFO
b$15AF DEFW $09F4    ; {Keyboard.
 $15B1 DEFW $10A8    ;
 $15B3 DEFB "K"      ; }
 $15B4 DEFW $09F4    ; {Screen.
 $15B6 DEFW $15C4    ;
 $15B8 DEFB "S"      ; }
 $15B9 DEFW $0F81    ; {Work space.
 $15BB DEFW $15C4    ;
 $15BD DEFB "R"      ; }
 $15BE DEFW $09F4    ; {Printer.
 $15C0 DEFW $15C4    ;
 $15C2 DEFB "P"      ; }
 $15C3 DEFB $80      ; End marker.

; Report J - Invalid I/O device
;
; The address of this routine is found in the #R$15AF(initial channel
; information table).
@refs=$15E6
@label=REPORT_J
c$15C4 RST $08       ; {Call the error handling routine.
 $15C5 DEFB $12      ; }

; THE 'INITIAL STREAM DATA'
;
; Used by the routines at #R$11B7 and #R$16E5.
; .
; Initially there are seven streams - &FD to &03.
@label=STRMDATA
@keep
w$15C6 DEFW $0001    ; &FD: Leads to channel 'K' (keyboard)
@keep
 $15C8 DEFW $0006    ; &FE: Leads to channel 'S' (screen)
@keep
 $15CA DEFW $000B    ; &FF: Leads to channel 'R' (work space)
@keep
 $15CC DEFW $0001    ; &00: Leads to channel 'K' (keyboard)
@keep
 $15CE DEFW $0001    ; &01: Leads to channel 'K' (keyboard)
@keep
 $15D0 DEFW $0006    ; &02: Leads to channel 'S' (screen)
@keep
 $15D2 DEFW $0010    ; &03: Leads to channel 'P' (printer)

; THE 'WAIT-KEY' SUBROUTINE
;
; Used by the routines at #R$0970, #R$0C55, #R$0F2C and #R$101E.
; .
; This subroutine is the controlling subroutine for calling the current input
; subroutine.
@label=WAIT_KEY
c$15D4 BIT 5,(IY+$02) ; {Jump forward if the flag (bit 5 of #SYSVAR(TV-FLAG))
 $15D8 JR NZ,$15DE    ; indicates the lower screen does not require clearing.}
 $15DA SET 3,(IY+$02) ; Otherwise signal 'consider the mode as having changed'
                      ; (set bit 3 of #SYSVAR(TV-FLAG)).
@label=WAIT_KEY1
*$15DE CALL $15E6     ; Call the input subroutine indirectly via #R$15E6.
 $15E1 RET C          ; Return with acceptable codes.
 $15E2 JR Z,$15DE     ; Both the carry flag and the zero flag are reset if 'no
                      ; key is being pressed'; otherwise signal an error.
; Report 8 - End of file.
 $15E4 RST $08        ; {Call the error handling routine.
 $15E5 DEFB $07       ; }

; THE 'INPUT-AD' SUBROUTINE
;
; Used by the routines at #R$15D4 and #R$3645.
; .
; The registers are saved and #REGhl made to point to the input address.
@label=INPUT_AD
c$15E6 EXX           ; {Save the registers.
 $15E7 PUSH HL       ; }
 $15E8 LD HL,($5C51) ; Fetch the base address for the current channel
                     ; information (#SYSVAR(CURCHL)).
 $15EB INC HL        ; {Step past the output address.
 $15EC INC HL        ; }
 $15ED JR $15F7      ; Jump forward.

; THE 'MAIN PRINTING' SUBROUTINE
;
; Used by the routines at #R$12A2, #R$1925, #R$1A1B and #R$2DE3.
;
; A Value from &00 to &09 (for digits) or &11 to &22 (for the letters A-R)
@label=OUT_CODE
c$15EF LD E,$30      ; {Increase the value in the #REGa register by &30.
 $15F1 ADD A,E       ; }
; This entry point is used by the routine at #R$0010 with #REGa holding the
; code of the character to be printed.
@label=PRINT_A_2
*$15F2 EXX           ; {Save the registers.
 $15F3 PUSH HL       ; }
 $15F4 LD HL,($5C51) ; Fetch the base address for the current channel
                     ; (#SYSVAR(CURCHL)). This will point to an output address.
; This entry point is used by the routine at #R$15E6 with #REGa holding the
; code of the character to be printed.
; .
; Now call the actual subroutine. #REGhl points to the output or the input
; address as directed.
@label=CALL_SUB
*$15F7 LD E,(HL)     ; Fetch the low byte.
 $15F8 INC HL        ; {Fetch the high byte.
 $15F9 LD D,(HL)     ; }
 $15FA EX DE,HL      ; Move the address to the #REGhl register pair.
 $15FB CALL $162C    ; Call the actual subroutine.
 $15FE POP HL        ; {Restore the registers.
 $15FF EXX           ; }
 $1600 RET           ; Return will be from here unless an error occurred.

; THE 'CHAN-OPEN' SUBROUTINE
;
; Used by the routines at #R$0605, #R$0970, #R$0C55, #R$0D6B, #R$0DAF, #R$0FA9,
; #R$1059, #R$12A2, #R$17F9, #R$1FC9, #R$2070, #R$2089, #R$361F and #R$3645.
; .
; This subroutine is called with the #REGa register holding a valid stream
; number - normally &FD to &03. Then depending on the stream data a particular
; channel will be made the current channel.
;
; A Stream number
@label=CHAN_OPEN
c$1601 ADD A,A       ; {The value in the #REGa register is doubled and then
 $1602 ADD A,$16     ; increased by &16.}
 $1604 LD L,A        ; The result is moved to #REGl.
 $1605 LD H,$5C      ; The address #R$5C16 is the base address for stream &00.
 $1607 LD E,(HL)     ; {Fetch the first two bytes of the required stream's
 $1608 INC HL        ; data.
 $1609 LD D,(HL)     ; }
 $160A LD A,D        ; {Give an error if both bytes are zero; otherwise jump
 $160B OR E          ; forward.
 $160C JR NZ,$1610   ; }
; This entry point is used by the routine at #R$2070.
; .
; Report O - Invalid stream.
@label=REPORT_O
*$160E RST $08       ; {Call the error handling routine.
 $160F DEFB $17      ; }
; Using the stream data now find the base address of the channel information
; associated with that stream.
@label=CHAN_OP_1
*$1610 DEC DE        ; Reduce the stream data.
 $1611 LD HL,($5C4F) ; The base address of the whole channel information area
                     ; (#SYSVAR(CHANS)).
 $1614 ADD HL,DE     ; Form the required address in this area.
; This routine continues into #R$1615.

; THE 'CHAN-FLAG' SUBROUTINE
;
; Used by the routines at #R$0FA9, #R$361F and #R$3645.
; .
; The routine at #R$1601 continues here.
; .
; The appropriate flags for the different channels are set by this subroutine.
;
; HL Base address of the channel (see #SYSVAR(CHINFO))
@label=CHAN_FLAG
c$1615 LD ($5C51),HL  ; The #REGhl register pair holds the base address for a
                      ; particular channel; set #SYSVAR(CURCHL) accordingly.
 $1618 RES 4,(IY+$30) ; Signal 'using other than channel 'K'' (reset bit 4 of
                      ; #R$5C6A(FLAGS2)).
 $161C INC HL         ; {Step past the output and the input addresses and make
 $161D INC HL         ; #REGhl point to the channel code.
 $161E INC HL         ;
 $161F INC HL         ; }
 $1620 LD C,(HL)      ; Fetch the code.
 $1621 LD HL,$162D    ; The base address of the #R$162D(channel code look-up
                      ; table).
 $1624 CALL $16DC     ; {Index into this table and locate the required offset,
 $1627 RET NC         ; but return if there is not a matching channel code.}
 $1628 LD D,$00       ; {Pass the offset to the #REGde register pair.
 $162A LD E,(HL)      ; }
 $162B ADD HL,DE      ; Point #REGhl at the appropriate flag setting routine.
; This entry point is used by the routine at #R$15EF.
@label=CALL_JUMP
*$162C JP (HL)        ; Jump to the routine.

; THE 'CHANNEL CODE LOOK-UP' TABLE
;
; Used by the routine at #R$1615.
@label=CHANCODE
b$162D DEFB "K",$06  ; Channel 'K', offset &06 (#R$1634).
 $162F DEFB "S",$12  ; Channel 'S', offset &12 (#R$1642).
 $1631 DEFB "P",$1B  ; Channel 'P', offset &1B (#R$164D).
 $1633 DEFB $00      ; End marker.

; THE 'CHANNEL 'K' FLAG' SUBROUTINE
;
; The address of this routine is derived from an offset found in the
; #R$162D(channel code lookup table).
@refs=$1615
@label=CHAN_K
c$1634 SET 0,(IY+$02) ; Signal 'using lower screen' (set bit 0 of
                      ; #SYSVAR(TV-FLAG)).
 $1638 RES 5,(IY+$01) ; Signal 'ready for a key' (reset bit 5 of
                      ; #SYSVAR(FLAGS)).
 $163C SET 4,(IY+$30) ; Signal 'using channel 'K'' (set bit 4 of
                      ; #R$5C6A(FLAGS2)).
 $1640 JR $1646       ; Jump forward.

; THE 'CHANNEL 'S' FLAG' SUBROUTINE
;
; The address of this routine is derived from an offset found in the
; #R$162D(channel code lookup table).
@refs=$1615
@label=CHAN_S
c$1642 RES 0,(IY+$02) ; Signal 'using main screen' (reset bit 0 of
                      ; #SYSVAR(TV-FLAG)).
; This entry point is used by the routine at #R$1634.
@label=CHAN_S_1
*$1646 RES 1,(IY+$01) ; Signal 'printer not being used' (reset bit 1 of
                      ; #SYSVAR(FLAGS)).
 $164A JP $0D4D       ; Exit via #R$0D4D so as to set the colour system
                      ; variables.

; THE 'CHANNEL 'P' FLAG' SUBROUTINE
;
; The address of this routine is derived from an offset found in the
; #R$162D(channel code lookup table).
@refs=$1615
@label=CHAN_P
c$164D SET 1,(IY+$01) ; Signal 'printer in use' (set bit 1 of #SYSVAR(FLAGS)).
 $1651 RET            ;

; THE 'MAKE-ROOM' SUBROUTINE
;
; Used by the routine at #R$0F2C.
; .
; This is a very important subroutine. It is called on many occasions to 'open
; up' an area. In all cases the #REGhl register pair points to the location
; after the place where 'room' is required and the #REGbc register pair holds
; the length of the 'room' needed.
;
;   HL Address at which to create the new space
; O:DE Address of the last byte of the new space
; O:HL Address of the byte before the start of the new space
;
; When a single space only is required then the subroutine is entered here.
@keep
@label=ONE_SPACE
c$1652 LD BC,$0001   ; Just the single extra location is required.
; This entry point is used by the routines at #R$0808, #R$092C, #R$0F2C,
; #R$155D, #R$169E, #R$1D03, #R$1F60, #R$268D, #R$2AFF and #R$2C02 with #REGbc
; holding the size of the space to create.
@label=MAKE_ROOM
*$1655 PUSH HL       ; Save the pointer.
 $1656 CALL $1F05    ; Make sure that there is sufficient memory available for
                     ; the task being undertaken.
 $1659 POP HL        ; Restore the pointer.
 $165A CALL $1664    ; Alter all the pointers before making the 'room'.
 $165D LD HL,($5C65) ; Make #REGhl hold the new #SYSVAR(STKEND).
 $1660 EX DE,HL      ; Switch 'old' and 'new'.
 $1661 LDDR          ; {Now make the 'room' and return.
 $1663 RET           ; }
; Note: this subroutine returns with the #REGhl register pair pointing to the
; location before the new 'room' and the #REGde register pair pointing to the
; last of the new locations. The new 'room' therefore has the description
; '(#REGhl)+1' to '(#REGde)' inclusive.
; .
; However as the 'new locations' still retain their 'old values' it is also
; possible to consider the new 'room' as having been made after the original
; location '(#REGhl)' and it thereby has the description '(#REGhl)+2' to
; '(#REGde)+1'.
; .
; In fact the programmer appears to have a preference for the 'second
; description' and this can be confusing.

; THE 'POINTERS' SUBROUTINE
;
; Used by the routines at #R$1652 and #R$19E5.
; .
; Whenever an area has to be 'made' or 'reclaimed' the system variables that
; address locations beyond the 'position' of the change have to be amended as
; required. On entry the #REGbc register pair holds the number of bytes
; involved and the #REGhl register pair addresses the location before the
; 'position'.
;
; BC Size of the area being created (positive) or reclaimed (negative)
; HL Base address of the area being created or reclaimed
@label=POINTERS
c$1664 PUSH AF       ; These registers are saved.
 $1665 PUSH HL       ; Copy the address of the 'position'.
 $1666 LD HL,$5C4B   ; {This is #SYSVAR(VARS), the first of the fourteen system
 $1669 LD A,$0E      ; pointers.}
; A loop is now entered to consider each pointer in turn. Only those pointers
; that point beyond the 'position' are changed.
@label=PTR_NEXT
*$166B LD E,(HL)     ; {Fetch the two bytes of the current pointer.
 $166C INC HL        ;
 $166D LD D,(HL)     ; }
 $166E EX (SP),HL    ; Exchange the system variable with the address of the
                     ; 'position'.
 $166F AND A         ; {The carry flag will become set if the system variable's
 $1670 SBC HL,DE     ; address is to be updated.
 $1672 ADD HL,DE     ; }
 $1673 EX (SP),HL    ; Restore the 'position'.
 $1674 JR NC,$167F   ; Jump forward if the pointer is to be left; otherwise
                     ; change it.
 $1676 PUSH DE       ; Save the old value.
 $1677 EX DE,HL      ; {Now add the value in #REGbc to the old value.
 $1678 ADD HL,BC     ;
 $1679 EX DE,HL      ; }
 $167A LD (HL),D     ; {Enter the new value into the system variable - high
 $167B DEC HL        ; byte before low byte.
 $167C LD (HL),E     ; }
 $167D INC HL        ; Point again to the high byte.
 $167E POP DE        ; Fetch the old value.
@label=PTR_DONE
*$167F INC HL        ; {Point to the next system variable and jump back until
 $1680 DEC A         ; all fourteen have been considered.
 $1681 JR NZ,$166B   ; }
; Now find the size of the block to be moved.
 $1683 EX DE,HL      ; {Put the old value of #SYSVAR(STKEND) in #REGhl and
 $1684 POP DE        ; restore the other registers.
 $1685 POP AF        ; }
 $1686 AND A         ; {Now find the difference between the old value of
 $1687 SBC HL,DE     ; #SYSVAR(STKEND) and the 'position'.}
 $1689 LD B,H        ; {Transfer the result to #REGbc and add 1 for the
 $168A LD C,L        ; inclusive byte.
 $168B INC BC        ; }
 $168C ADD HL,DE     ; {Reform the old value of #SYSVAR(STKEND) and pass it to
 $168D EX DE,HL      ; #REGde before returning.
 $168E RET           ; }

; THE 'COLLECT A LINE NUMBER' SUBROUTINE
;
; On entry the #REGhl register pair points to the location under consideration.
; If the location holds a value that constitutes a suitable high byte for a
; line number then the line number is returned in #REGde. However if this is
; not so then the location addressed by #REGde is tried instead; and should
; this also be unsuccessful line number zero is returned.
;
;   HL Address of the first byte of the BASIC line number to test
;   DE Address of the first byte of the previous BASIC line number
; O:DE The line number, or zero if none was found
@label=LINE_ZERO
c$168F DEFB $00,$00  ; Line number zero.
@label=LINE_NO_A
*$1691 EX DE,HL      ; Consider the other pointer.
@nowarn
 $1692 LD DE,$168F   ; Use line number zero.
; The main entry point is here, and is used by the routines at #R$0FA9, #R$1059
; and #R$190F.
@label=LINE_NO
*$1695 LD A,(HL)     ; {Fetch the high byte and test it.
 $1696 AND $C0       ; }
 $1698 JR NZ,$1691   ; Jump if not suitable.
 $169A LD D,(HL)     ; {Fetch the high byte and low byte and return.
 $169B INC HL        ;
 $169C LD E,(HL)     ;
 $169D RET           ; }

; THE 'RESERVE' SUBROUTINE
;
; Used by the routine at #R$0030.
; .
; On entry here the last value on the machine stack is #SYSVAR(WORKSP) and the
; value above it is the number of spaces that are to be 'reserved'.
; .
; This subroutine always makes 'room' between the existing work space and the
; calculator stack.
;
;   BC Number of spaces to reserve
; O:DE Address of the first byte of the new space
; O:HL Address of the last byte of the new space
@label=RESERVE
c$169E LD HL,($5C63) ; {Fetch the current value of #SYSVAR(STKBOT) and
 $16A1 DEC HL        ; decrement it to get the last location of the work space.
                     ; }
 $16A2 CALL $1655    ; Now make '#REGbc spaces'.
 $16A5 INC HL        ; {Point to the first new space and then the second.
 $16A6 INC HL        ; }
 $16A7 POP BC        ; {Fetch the old value of #SYSVAR(WORKSP) and restore it.
 $16A8 LD ($5C61),BC ; }
 $16AC POP BC        ; Restore #REGbc - number of spaces.
 $16AD EX DE,HL      ; Switch the pointers.
 $16AE INC HL        ; Make #REGhl point to the first of the displaced bytes.
 $16AF RET           ; Now return.
; Note: it can also be considered that the subroutine returns with the #REGde
; register pair pointing to a 'first extra byte' and the #REGhl register pair
; pointing to a 'last extra byte', these extra bytes having been added after
; the original '(#REGhl)+1' location.

; THE 'SET-MIN' SUBROUTINE
;
; Used by the routine at #R$12A2.
; .
; This subroutine resets the editing area and the areas after it to their
; minimum sizes. In effect it 'clears' the areas.
@label=SET_MIN
c$16B0 LD HL,($5C59) ; Fetch #SYSVAR(E-LINE).
 $16B3 LD (HL),$0D   ; {Make the editing area hold only the 'carriage return'
 $16B5 LD ($5C5B),HL ; character and the end marker, and set #SYSVAR(K-CUR)
 $16B8 INC HL        ; accordingly
 $16B9 LD (HL),$80   ; }
 $16BB INC HL        ; {Reset #SYSVAR(WORKSP) and move on to clear the work
 $16BC LD ($5C61),HL ; space.}
; This entry point is used by the routines at #R$1B28 and #R$2089.
; .
; Entering here will 'clear' the work space and the calculator stack.
@label=SET_WORK
*$16BF LD HL,($5C61) ; Fetch the start address of the work space
                     ; #SYSVAR(WORKSP).
 $16C2 LD ($5C63),HL ; Clear the work space by setting #SYSVAR(STKBOT) equal to
                     ; #SYSVAR(WORKSP).
; This entry point is used by the routines at #R$0053 and #R$19FB.
; .
; Entering here will 'clear' only the calculator stack.
@label=SET_STK
*$16C5 LD HL,($5C63) ; Fetch #SYSVAR(STKBOT).
 $16C8 LD ($5C65),HL ; Clear the stack by setting #SYSVAR(STKEND) equal to
                     ; #SYSVAR(STKBOT).
; In all cases make #SYSVAR(MEM) address the calculator's memory area.
 $16CB PUSH HL       ; Save #SYSVAR(STKEND).
 $16CC LD HL,$5C92   ; The base of the memory area (#SYSVAR(MEMBOT)).
 $16CF LD ($5C68),HL ; Set #SYSVAR(MEM) to this address.
 $16D2 POP HL        ; {Restore #SYSVAR(STKEND) to the #REGhl register pair
 $16D3 RET           ; before returning.}

; THE 'RECLAIM THE EDIT-LINE' SUBROUTINE
;
; This routine is not used.
@label=REC_EDIT
u$16D4 LD DE,($5C59) ; Fetch #SYSVAR(E-LINE).
 $16D8 JP $19E5      ; Reclaim the memory.

; THE 'INDEXER' SUBROUTINE
;
; This subroutine is used on several occasions to look through tables.
;
;   C Code to look for
;   HL Base address of the table
; O:HL Address of the second byte of the required table entry (if found)
; O:F Carry flag is set if the code is found
@label=INDEXER_1
c$16DB INC HL        ; Move on to consider the next pair of entries.
; The main entry point is here and is used by the routines at #R$1615, #R$1701,
; #R$175D, #R$24FB and #R$26C9.
@label=INDEXER
*$16DC LD A,(HL)     ; {Fetch the first of a pair of entries but return if it
 $16DD AND A         ; is zero - the end marker.
 $16DE RET Z         ; }
 $16DF CP C          ; Compare it to the supplied code.
 $16E0 INC HL        ; Point to the second entry.
 $16E1 JR NZ,$16DB   ; Jump back if the correct entry has not been found.
 $16E3 SCF           ; The carry flag is set upon a successful search.
 $16E4 RET           ;

; THE 'CLOSE #' COMMAND ROUTINE
;
; The address of this routine is found in the #R$1B02(parameter table).
; .
; This command allows the user to close streams. However for streams &00 to &03
; the 'initial' stream data is restored and these streams cannot therefore be
; closed.
@refs=$1C0D
@label=CLOSE
c$16E5 CALL $171E    ; The existing data for the stream is fetched.
 $16E8 CALL $1701    ; Check the code in that stream's channel.
@keep
 $16EB LD BC,$0000   ; Prepare to make the stream's data zero.
 $16EE LD DE,$A3E2   ; {Prepare to identify the use of streams &00 to &03.
 $16F1 EX DE,HL      ; }
 $16F2 ADD HL,DE     ; The carry flag will be set with streams &04 to &0F.
 $16F3 JR C,$16FC    ; {Jump forward with these streams; otherwise find the
@keep=$15D4,$0E
@ssub=LD BC,$15C6+$0E
 $16F5 LD BC,$15D4   ; correct entry in the #R$15C6(initial stream data table).
 $16F8 ADD HL,BC     ; }
 $16F9 LD C,(HL)     ; {Fetch the initial data for streams &00 to &03.
 $16FA INC HL        ;
 $16FB LD B,(HL)     ; }
@label=CLOSE_1
*$16FC EX DE,HL      ; {Now enter the data: either zero and zero, or the
 $16FD LD (HL),C     ; initial values.
 $16FE INC HL        ;
 $16FF LD (HL),B     ; }
 $1700 RET           ;

; THE 'CLOSE-2' SUBROUTINE
;
; Used by the routine at #R$16E5.
; .
; The code of the channel associated with the stream being closed has to be
; 'K', 'S', or 'P'.
;
; BC Offset from the stream data table (#SYSVAR(STRMS))
; HL Address of the offset in the stream data table
@label=CLOSE_2
c$1701 PUSH HL       ; Save the address of the stream's data.
 $1702 LD HL,($5C4F) ; {Fetch the base address of the channel information area
 $1705 ADD HL,BC     ; (#SYSVAR(CHANS)) and find the channel data for the
                     ; stream being closed.}
 $1706 INC HL        ; {Step past the subroutine addresses and pick up the code
 $1707 INC HL        ; for that channel.
 $1708 INC HL        ;
 $1709 LD C,(HL)     ; }
 $170A EX DE,HL      ; Save the pointer.
 $170B LD HL,$1716   ; The base address of the #R$1716(CLOSE stream look-up
                     ; table).
 $170E CALL $16DC    ; Index into this table and locate the required offset.
 $1711 LD C,(HL)     ; {Pass the offset to the #REGbc register pair.
 $1712 LD B,$00      ; }
 $1714 ADD HL,BC     ; {Jump to the appropriate routine.
 $1715 JP (HL)       ; }

; THE 'CLOSE STREAM LOOK-UP' TABLE
;
; Used by the routine at #R$1701.
@label=CLOSESTRM
b$1716 DEFB "K",$05  ; Channel 'K', offset &05 (#R$171C)
 $1718 DEFB "S",$03  ; Channel 'S', offset &03 (#R$171C)
 $171A DEFB "P",$01  ; Channel 'P', offset &01 (#R$171C)
; Note: there is no end marker at the end of this table, which is a
; #BUG#dontCloseTheStreams(bug).

; THE 'CLOSE STREAM' SUBROUTINE
;
; The address of this routine is derived from an offset found in the
; #R$1716(close stream lookup table).
;
; O:HL Address of the offset in the stream data table (see #SYSVAR(STRMS))
@refs=$1701
@label=CLOSE_STR
c$171C POP HL        ; {Fetch the channel information pointer and return.
 $171D RET           ; }

; THE 'STREAM DATA' SUBROUTINE
;
; Used by the routines at #R$16E5 and #R$1736.
; .
; This subroutine returns in the #REGbc register pair the stream data for a
; given stream.
;
; O:BC Offset from the stream data table (#SYSVAR(STRMS))
; O:HL Address of the offset in the stream data table
@label=STR_DATA
c$171E CALL $1E94    ; The given stream number is taken off the calculator
                     ; stack.
 $1721 CP $10        ; {Give an error if the stream number is greater than &0F.
 $1723 JR C,$1727    ; }
; This entry point is used by the routines at #R$1736 and #R$1793.
; .
; Report O - Invalid stream.
@label=REPORT_O_2
*$1725 RST $08       ; {Call the error handling routine.
 $1726 DEFB $17      ; }
; Continue with valid stream numbers.
@label=STR_DATA1
*$1727 ADD A,$03     ; Range now &03 to &12.
 $1729 RLCA          ; And now &06 to &24.
 $172A LD HL,$5C10   ; The base address of the #R$5C10(stream data area).
 $172D LD C,A        ; {Move the stream code to the #REGbc register pair.
 $172E LD B,$00      ; }
 $1730 ADD HL,BC     ; {Index into the data area and fetch the the two data
 $1731 LD C,(HL)     ; bytes into the #REGbc register pair.
 $1732 INC HL        ;
 $1733 LD B,(HL)     ; }
 $1734 DEC HL        ; {Make the pointer address the first of the data bytes
 $1735 RET           ; before returning.}

; THE 'OPEN #' COMMAND ROUTINE
;
; The address of this routine is found in the #R$1AFC(parameter table).
; .
; This command allows the user to OPEN streams. A channel code must be supplied
; and it must be 'K', 'k', 'S', 's', 'P', or 'p'.
; .
; Note that no attempt is made to give streams &00 to &03 their initial data.
@refs=$1C0D
@label=OPEN
c$1736 RST $28       ; Use the calculator to exchange the stream number and the
                     ; channel code.
 $1737 DEFB $01      ; #R$343C
 $1738 DEFB $38      ; #R$369B
 $1739 CALL $171E    ; Fetch the data for the stream.
 $173C LD A,B        ; {Jump forward if both bytes of the data are zero, i.e.
 $173D OR C          ; the stream was in a closed state.
 $173E JR Z,$1756    ; }
 $1740 EX DE,HL      ; Save #REGhl.
 $1741 LD HL,($5C4F) ; {Fetch #SYSVAR(CHANS) - the base address of the channel
 $1744 ADD HL,BC     ; information and find the code of the channel associated
 $1745 INC HL        ; with the stream being OPENed.
 $1746 INC HL        ;
 $1747 INC HL        ;
 $1748 LD A,(HL)     ; }
 $1749 EX DE,HL      ; Return #REGhl.
 $174A CP "K"        ; {The code fetched from the channel information area must
 $174C JR Z,$1756    ; be 'K', 'S' or 'P'; give an error if it is not.
 $174E CP "S"        ;
 $1750 JR Z,$1756    ;
 $1752 CP "P"        ;
 $1754 JR NZ,$1725   ; }
@label=OPEN_1
*$1756 CALL $175D    ; Collect the appropriate data in #REGde.
 $1759 LD (HL),E     ; {Enter the data into the two bytes in the stream
 $175A INC HL        ; information area.
 $175B LD (HL),D     ; }
 $175C RET           ; Finally return.

; THE 'OPEN-2' SUBROUTINE
;
; Used by the routine at #R$1736.
; .
; The appropriate stream data bytes for the channel that is associated with the
; stream being opened are found.
@label=OPEN_2
c$175D PUSH HL       ; Save #REGhl.
 $175E CALL $2BF1    ; Fetch the parameters of the channel code.
 $1761 LD A,B        ; {Give an error if the expression supplied is a null
 $1762 OR C          ; expression, e.g. OPEN #5,"".
 $1763 JR NZ,$1767   ; }
; This entry point is used by the routine at #R$1789.
; .
; Report F - Invalid file name.
@label=REPORT_F
*$1765 RST $08       ; {Call the error handling routine.
 $1766 DEFB $0E      ; }
; Continue if no error occurred.
@label=OPEN_3
*$1767 PUSH BC       ; The length of the expression is saved.
 $1768 LD A,(DE)     ; Fetch the first character.
 $1769 AND $DF       ; Convert lower case codes to upper case ones.
 $176B LD C,A        ; Move code to the #REGc register.
 $176C LD HL,$177A   ; The base address of the #R$177A(OPEN stream look-up
                     ; table).
 $176F CALL $16DC    ; Index into this table and locate the required offset.
 $1772 JR NC,$1765   ; Jump back if not found.
 $1774 LD C,(HL)     ; {Pass the offset to the #REGbc register pair.
 $1775 LD B,$00      ; }
 $1777 ADD HL,BC     ; Make #REGhl point to the start of the appropriate
                     ; subroutine.
 $1778 POP BC        ; {Fetch the length of the expression before jumping to
 $1779 JP (HL)       ; the subroutine.}

; THE 'OPEN STREAM LOOK-UP' TABLE
;
; Used by the routine at #R$175D.
@label=OPENSTRM
b$177A DEFB "K",$06  ; Channel 'K', offset &06 (#R$1781)
 $177C DEFB "S",$08  ; Channel 'S', offset &08 (#R$1785)
 $177E DEFB "P",$0A  ; Channel 'P', offset &0A (#R$1789)
 $1780 DEFB $00      ; End marker.

; THE 'OPEN-K' SUBROUTINE
;
; The address of this routine is derived from an offset found in the
; #R$177A(open stream lookup table).
;
; BC Length of the expression specifying the channel code
@refs=$175D
@label=OPEN_K
c$1781 LD E,$01      ; The data bytes will be &01 and &00.
 $1783 JR $178B      ;

; THE 'OPEN-S' SUBROUTINE
;
; The address of this routine is derived from an offset found in the
; #R$177A(open stream lookup table).
;
; BC Length of the expression specifying the channel code
@refs=$175D
@label=OPEN_S
c$1785 LD E,$06      ; The data bytes will be &06 and &00.
 $1787 JR $178B      ;

; THE 'OPEN-P' SUBROUTINE
;
; The address of this routine is derived from an offset found in the
; #R$177A(open stream lookup table).
;
; BC Length of the expression specifying the channel code
@refs=$175D
@label=OPEN_P
c$1789 LD E,$10      ; The data bytes will be &10 and &00.
; This entry point is used by the routines at #R$1781 and #R$1785.
@label=OPEN_END
*$178B DEC BC        ; {Decrease the length of the expression and give an error
 $178C LD A,B        ; if it was not a single character.
 $178D OR C          ;
 $178E JR NZ,$1765   ; }
 $1790 LD D,A        ; {Otherwise clear the #REGd register, fetch #REGhl and
 $1791 POP HL        ; return.
 $1792 RET           ; }

; THE 'CAT, ERASE, FORMAT and MOVE' COMMAND ROUTINES
;
; The address of this routine is found in the #R$1B06(parameter table).
; .
; In the standard Spectrum system the use of these commands leads to the
; production of report O - Invalid stream.
@refs=$1C0D
@label=CAT_ETC
c$1793 JR $1725      ; Give this report.

; THE 'LIST and LLIST' COMMAND ROUTINES
;
; The routines in this part of the 16K program are used to produce listings of
; the current BASIC program. Each line has to have its line number evaluated,
; its tokens expanded and the appropriate cursors positioned.
; .
; The entry point #R$1795 is used by both #R$12A2 and #R$1059 to produce a
; single page of the listing.
@label=AUTO_LIST
c$1795 LD ($5C3F),SP   ; The stack pointer is saved at #SYSVAR(LIST-SP)
                       ; allowing the machine stack to be reset when the
                       ; listing is finished (see #R$0C55).
 $1799 LD (IY+$02),$10 ; Signal 'automatic listing in the main screen' (set bit
                       ; 4 of #SYSVAR(TV-FLAG) and reset all other bits).
 $179D CALL $0DAF      ; Clear this part of the screen.
 $17A0 SET 0,(IY+$02)  ; Switch to the editing area (set bit 0 of
                       ; #SYSVAR(TV-FLAG)).
 $17A4 LD B,(IY+$31)   ; {Now clear the the lower part of the screen as well
 $17A7 CALL $0E44      ; (see #SYSVAR(DF-SZ)).}
 $17AA RES 0,(IY+$02)  ; Then switch back (reset bit 0 of #SYSVAR(TV-FLAG)).
 $17AE SET 0,(IY+$30)  ; Signal 'screen is clear' (set bit 0 of
                       ; #R$5C6A(FLAGS2)).
 $17B2 LD HL,($5C49)   ; {Now fetch the the 'current' line number
 $17B5 LD DE,($5C6C)   ; (#SYSVAR(E-PPC)) and the 'automatic' line number
                       ; (#SYSVAR(S-TOP)).}
 $17B9 AND A           ; {If the 'current' number is less than the 'automatic'
 $17BA SBC HL,DE       ; number then jump forward to update the 'automatic'
 $17BC ADD HL,DE       ; number.
 $17BD JR C,$17E1      ; }
; The 'automatic' number has now to be altered to give a listing with the
; 'current' line appearing near the bottom of the screen.
 $17BF PUSH DE         ; Save the 'automatic' number.
 $17C0 CALL $196E      ; {Find the address of the start of the 'current' line
@keep
 $17C3 LD DE,$02C0     ; and produce an address roughly a 'screen before it'
 $17C6 EX DE,HL        ; (negated).
 $17C7 SBC HL,DE       ; }
 $17C9 EX (SP),HL      ; {Save the 'result' on the machine stack whilst the
 $17CA CALL $196E      ; 'automatic' line address is also found (in #REGhl).}
 $17CD POP BC          ; The 'result' goes to the #REGbc register pair.
; A loop is now entered. The 'automatic' line number is increased on each pass
; until it is likely that the 'current' line will show on a listing.
@label=AUTO_L_1
*$17CE PUSH BC         ; Save the 'result'.
 $17CF CALL $19B8      ; Find the address of the start of the line after the
                       ; present 'automatic' line (in #REGde).
 $17D2 POP BC          ; Restore the 'result'.
 $17D3 ADD HL,BC       ; {Perform the computation and jump forward if finished.
 $17D4 JR C,$17E4      ; }
 $17D6 EX DE,HL        ; {Move the next line's address to the #REGhl register
 $17D7 LD D,(HL)       ; pair and collect its line number.
 $17D8 INC HL          ;
 $17D9 LD E,(HL)       ;
 $17DA DEC HL          ; }
 $17DB LD ($5C6C),DE   ; {Now #SYSVAR(S-TOP) can be updated and the test
 $17DF JR $17CE        ; repeated with the new line.}
; Now the 'automatic' listing can be made.
@label=AUTO_L_2
*$17E1 LD ($5C6C),HL   ; When #SYSVAR(E-PPC) is less than #SYSVAR(S-TOP).
@label=AUTO_L_3
*$17E4 LD HL,($5C6C)   ; {Fetch the top line's number (#SYSVAR(S-TOP)) and
 $17E7 CALL $196E      ; hence its address.}
 $17EA JR Z,$17ED      ; {If the line cannot be found use #REGde instead.
 $17EC EX DE,HL        ; }
@label=AUTO_L_4
*$17ED CALL $1833      ; The listing is produced.
 $17F0 RES 4,(IY+$02)  ; {The return will be to here unless scrolling was
 $17F4 RET             ; needed to show the current line; reset bit 4 of
                       ; #SYSVAR(TV-FLAG) before returning.}

; THE 'LLIST' ENTRY POINT
;
; The address of this routine is found in the #R$1ADC(parameter table).
; .
; The printer channel will need to be opened.
@refs=$1C0D
@label=LLIST
c$17F5 LD A,$03      ; Use stream &03.
 $17F7 JR $17FB      ; Jump forward.

; THE 'LIST' ENTRY POINT
;
; The address of this routine is found in the #R$1AAE(parameter table).
; .
; The 'main screen' channel will need to be opened.
@refs=$1C0D
@label=LIST
c$17F9 LD A,$02        ; Use stream &02.
; This entry point is used by the routine at #R$17F5.
@label=LIST_1
*$17FB LD (IY+$02),$00 ; Signal 'an ordinary listing in the main part of the
                       ; screen' (reset bit 4 of #SYSVAR(TV-FLAG) and all other
                       ; bits).
 $17FF CALL $2530      ; {Open the channel unless checking syntax.
 $1802 CALL NZ,$1601   ; }
 $1805 RST $18         ; {With the present character in the #REGa register see
 $1806 CALL $2070      ; if the stream is to be changed.}
 $1809 JR C,$181F      ; Jump forward if unchanged.
 $180B RST $18         ; {Is the present character a ';'?
 $180C CP ";"          ; }
 $180E JR Z,$1814      ; Jump if it is.
 $1810 CP ","          ; Is it a ','?
 $1812 JR NZ,$181A     ; Jump if it is not.
@label=LIST_2
*$1814 RST $20         ; {A numeric expression must follow, e.g. LIST #5,20.
 $1815 CALL $1C82      ; }
 $1818 JR $1822        ; Jump forward with it.
@label=LIST_3
*$181A CALL $1CE6      ; {Otherwise use zero and also jump forward.
 $181D JR $1822        ; }
; Come here if the stream was unaltered.
@label=LIST_4
*$181F CALL $1CDE      ; Fetch any line or use zero if none supplied.
@label=LIST_5
*$1822 CALL $1BEE      ; If checking the syntax of the edit-line move on to the
                       ; next statement.
 $1825 CALL $1E99      ; Line number to #REGbc.
 $1828 LD A,B          ; High byte to #REGa.
 $1829 AND $3F         ; {Limit the high byte to the correct range and pass the
 $182B LD H,A          ; whole line number to #REGhl.
 $182C LD L,C          ; }
 $182D LD ($5C49),HL   ; {Set #SYSVAR(E-PPC) and find the address of the start
 $1830 CALL $196E      ; of this line or the first line after it if the actual
                       ; line does not exist.}
; This entry point is used by the routine at #R$1795.
@label=LIST_ALL
*$1833 LD E,$01        ; Flag 'before the current line'.
; Now the controlling loop for printing a series of lines is entered.
@label=LIST_ALL_1
*$1835 CALL $1855      ; Print the whole of a BASIC line.
 $1838 RST $10         ; This will be a 'carriage return'.
 $1839 BIT 4,(IY+$02)  ; {Jump back unless dealing with an automatic listing
 $183D JR Z,$1835      ; (bit 4 of #SYSVAR(TV-FLAG) set).}
 $183F LD A,($5C6B)    ; {Also jump back if there is still part of the main
 $1842 SUB (IY+$4F)    ; screen that can be used (#SYSVAR(DF-SZ) <>
 $1845 JR NZ,$1835     ; #SYSVAR(S-POSN-hi)).}
 $1847 XOR E           ; {A return can be made at this point if the screen is
 $1848 RET Z           ; full and the current line has been printed
                       ; (#REGe=&00).}
 $1849 PUSH HL         ; {However if the current line is missing from the
 $184A PUSH DE         ; listing then #SYSVAR(S-TOP) has to be updated and a
 $184B LD HL,$5C6C     ; further line printed (using scrolling).
 $184E CALL $190F      ;
 $1851 POP DE          ;
 $1852 POP HL          ;
 $1853 JR $1835        ; }

; THE 'PRINT A WHOLE BASIC LINE' SUBROUTINE
;
; Used by the routines at #R$0FA9 and #R$17F9.
; .
; The #REGhl register pair points to the start of the line - the location
; holding the high byte of the line number.
; .
; Before the line number is printed it is tested to determine whether it comes
; before the 'current' line, is the 'current' line, or comes after.
;
; HL Address of the start of the BASIC line
@label=OUT_LINE
c$1855 LD BC,($5C49)  ; {Fetch the 'current' line number from #SYSVAR(E-PPC)
 $1859 CALL $1980     ; and compare it.}
 $185C LD D,">"       ; Pre-load the #REGd register with the current line
                      ; cursor.
 $185E JR Z,$1865     ; Jump forward if printing the 'current' line.
@keep
 $1860 LD DE,$0000    ; {Load the #REGd register with zero (it is not the
 $1863 RL E           ; cursor) and set #REGe to hold &01 if the line is before
                      ; the 'current' line and &00 if after. (The carry flag
                      ; comes from #R$1980.)}
@label=OUT_LINE1
*$1865 LD (IY+$2D),E  ; Save the line marker in #SYSVAR(BREG).
 $1868 LD A,(HL)      ; {Fetch the high byte of the line number and make a full
 $1869 CP $40         ; return if the listing has been finished.
 $186B POP BC         ;
 $186C RET NC         ; }
 $186D PUSH BC        ;
 $186E CALL $1A28     ; The line number can now be printed - with leading
                      ; spaces.
 $1871 INC HL         ; {Move the pointer on to address the first command code
 $1872 INC HL         ; in the line.
 $1873 INC HL         ; }
 $1874 RES 0,(IY+$01) ; Signal 'leading space allowed' (reset bit 0 of
                      ; #SYSVAR(FLAGS)).
 $1878 LD A,D         ; {Fetch the cursor code and jump forward unless the
 $1879 AND A          ; cursor is to be printed.
 $187A JR Z,$1881     ; }
 $187C RST $10        ; So print the cursor now.
; This entry point is used by the routine at #R$111D.
@label=OUT_LINE2
*$187D SET 0,(IY+$01) ; Signal 'no leading space now' (set bit 0 of
                      ; #SYSVAR(FLAGS)).
@label=OUT_LINE3
*$1881 PUSH DE        ; Save the registers.
 $1882 EX DE,HL       ; Move the pointer to #REGde.
 $1883 RES 2,(IY+$30) ; Signal 'not in quotes' (reset bit 2 of
                      ; #R$5C6A(FLAGS2)).
 $1887 LD HL,$5C3B    ; This is #SYSVAR(FLAGS).
 $188A RES 2,(HL)     ; Signal 'print in K-mode'.
 $188C BIT 5,(IY+$37) ; {Jump forward unless in INPUT mode (bit 5 of
 $1890 JR Z,$1894     ; #SYSVAR(FLAGX) set).}
 $1892 SET 2,(HL)     ; Signal 'print in L-mode'.
; Now enter a loop to print all the codes in the rest of the BASIC line -
; jumping over floating-point forms as necessary.
@label=OUT_LINE4
*$1894 LD HL,($5C5F)  ; {Fetch the syntax error pointer (#SYSVAR(X-PTR)) and
 $1897 AND A          ; jump forward unless it is time to print the error
 $1898 SBC HL,DE      ; marker.
 $189A JR NZ,$18A1    ; }
 $189C LD A,"?"       ; {Print the error marker now. It is a flashing '?'.
 $189E CALL $18C1     ; }
@label=OUT_LINE5
*$18A1 CALL $18E1     ; Consider whether to print the cursor.
 $18A4 EX DE,HL       ; Move the pointer to #REGhl now.
 $18A5 LD A,(HL)      ; Fetch each character in turn.
 $18A6 CALL $18B6     ; If the character is a 'number marker' then the hidden
                      ; floating-point form is not to be printed.
 $18A9 INC HL         ; Update the pointer for the next pass.
 $18AA CP $0D         ; Is the character a 'carriage return'?
 $18AC JR Z,$18B4     ; Jump if it is.
 $18AE EX DE,HL       ; Switch the pointer to #REGde.
 $18AF CALL $1937     ; Print the character.
 $18B2 JR $1894       ; Go around the loop for at least one further pass.
; The line has now been printed.
@label=OUT_LINE6
*$18B4 POP DE         ; {Restore the #REGde register pair and return.
 $18B5 RET            ; }

; THE 'NUMBER' SUBROUTINE
;
; Used by the routines at #R$1855 and #R$198B.
; .
; If the #REGa register holds the 'number marker' then the #REGhl register pair
; is advanced past the floating-point form.
;
;   A Character code from a BASIC line
;   HL Address of that character
; O:A Next character code from the line (if the current one is a number marker)
; O:HL Address of that character
@label=NUMBER
c$18B6 CP $0E        ; Is the character a 'number marker'?
 $18B8 RET NZ        ; Return if not.
 $18B9 INC HL        ; {Advance the pointer six times so as to step past the
 $18BA INC HL        ; 'number marker' and the five locations holding the
 $18BB INC HL        ; floating-point form.
 $18BC INC HL        ;
 $18BD INC HL        ;
 $18BE INC HL        ; }
 $18BF LD A,(HL)     ; {Fetch the current code before returning.
 $18C0 RET           ; }

; THE 'PRINT A FLASHING CHARACTER' SUBROUTINE
;
; Used by the routines at #R$1855 and #R$18E1.
; .
; The 'error cursor' and the 'mode cursors' are printed using this subroutine.
;
; A Character code ('C', 'E', 'G', 'K', 'L' or '?')
@label=OUT_FLASH
c$18C1 EXX           ; Switch to the alternate registers.
 $18C2 LD HL,($5C8F) ; {Save the values of #SYSVAR(ATTR-T) and #SYSVAR(MASK-T)
 $18C5 PUSH HL       ; on the machine stack.}
 $18C6 RES 7,H       ; {Ensure that FLASH is active.
 $18C8 SET 7,L       ; }
 $18CA LD ($5C8F),HL ; Use these modified values for #SYSVAR(ATTR-T) and
                     ; #SYSVAR(MASK-T).
 $18CD LD HL,$5C91   ; This is #SYSVAR(P-FLAG).
 $18D0 LD D,(HL)     ; {Save #SYSVAR(P-FLAG) also on the machine stack.
 $18D1 PUSH DE       ; }
 $18D2 LD (HL),$00   ; Ensure INVERSE 0, OVER 0, and not PAPER 9 nor INK 9.
 $18D4 CALL $09F4    ; The character is printed.
 $18D7 POP HL        ; {The former value of #SYSVAR(P-FLAG) is restored.
 $18D8 LD (IY+$57),H ; }
 $18DB POP HL        ; {The former values of #SYSVAR(ATTR-T) and
 $18DC LD ($5C8F),HL ; #SYSVAR(MASK-T) are also restored before returning.
 $18DF EXX           ;
 $18E0 RET           ; }

; THE 'PRINT THE CURSOR' SUBROUTINE
;
; Used by the routines at #R$111D and #R$1855.
; .
; A return is made if it is not the correct place to print the cursor but if it
; is then 'C', 'E', 'G', 'K' or 'L' will be printed.
;
; DE Address of the current position in the edit line or INPUT line
@label=OUT_CURS
c$18E1 LD HL,($5C5B)  ; {Fetch the address of the cursor (#SYSVAR(K-CUR)) but
 $18E4 AND A          ; return if the correct place is not being considered.
 $18E5 SBC HL,DE      ;
 $18E7 RET NZ         ; }
 $18E8 LD A,($5C41)   ; {The current value of #SYSVAR(MODE) is fetched and
 $18EB RLC A          ; doubled.}
 $18ED JR Z,$18F3     ; Jump forward unless dealing with Extended mode or
                      ; Graphics.
 $18EF ADD A,$43      ; Add the appropriate offset to give 'E' or 'G'.
 $18F1 JR $1909       ; Jump forward to print it.
@label=OUT_C_1
*$18F3 LD HL,$5C3B    ; This is #SYSVAR(FLAGS).
 $18F6 RES 3,(HL)     ; Signal 'K-mode'.
 $18F8 LD A,"K"       ; The character 'K'.
 $18FA BIT 2,(HL)     ; {Jump forward to print 'K' if 'the printing is to be in
 $18FC JR Z,$1909     ; K-mode'.}
 $18FE SET 3,(HL)     ; The 'printing is to be in L-mode' so signal 'L-MODE'.
 $1900 INC A          ; Form the character 'L'.
 $1901 BIT 3,(IY+$30) ; {Jump forward if not in 'C-mode' (bit 3 of
 $1905 JR Z,$1909     ; #R$5C6A(FLAGS2) reset).}
 $1907 LD A,"C"       ; The character 'C'.
@label=OUT_C_2
*$1909 PUSH DE        ; {Save the #REGde register pair whilst the cursor is
 $190A CALL $18C1     ; printed - FLASHing.
 $190D POP DE         ; }
 $190E RET            ; Return once it has been done.
; Note: it is the action of considering which cursor-letter is to be printed
; that determines the mode - 'K', 'L' or 'C'.

; THE 'LN-FETCH' SUBROUTINE
;
; Used by the routines at #R$0FF3 and #R$17F9.
; .
; This subroutine is entered with the #REGhl register pair addressing a system
; variable - #SYSVAR(S-TOP) or #SYSVAR(E-PPC).
; .
; The subroutine returns with the system variable holding the line number of
; the following line.
;
; HL #SYSVAR(S-TOP) or #SYSVAR(E-PPC)
@label=LN_FETCH
c$190F LD E,(HL)      ; {The line number held by the system variable is
 $1910 INC HL         ; collected.
 $1911 LD D,(HL)      ; }
 $1912 PUSH HL        ; The pointer is saved.
 $1913 EX DE,HL       ; {The line number is moved to the #REGhl register pair
 $1914 INC HL         ; and incremented.}
 $1915 CALL $196E     ; The address of the start of this line is found, or the
                      ; next line if the actual line number is not being used.
 $1918 CALL $1695     ; The number of that line is fetched.
 $191B POP HL         ; The pointer to the system variable is restored.
; This entry point is used by the routine at #R$1059.
@label=LN_STORE
*$191C BIT 5,(IY+$37) ; {Return if in 'INPUT mode' (bit 5 of #SYSVAR(FLAGX)
 $1920 RET NZ         ; set).}
 $1921 LD (HL),D      ; {Otherwise proceed to enter the line number into the
 $1922 DEC HL         ; two locations of the system variable.
 $1923 LD (HL),E      ; }
 $1924 RET            ; Return when it has been done.

; THE 'PRINTING CHARACTERS IN A BASIC LINE' SUBROUTINE
;
; All of the character/token codes in a BASIC line are printed by repeatedly
; calling this subroutine.
@label=OUT_SP_2
c$1925 LD A,E         ; The #REGa register will hold &20 for a space or &FF for
                      ; no-space.
 $1926 AND A          ; {Test the value and return if there is not to be a
 $1927 RET M          ; space.}
 $1928 JR $1937       ; Jump forward to print a space.
; This entry point is used by the routine at #R$1A1B to print a line number
; that may (#REGe=&20) or may not (#REGe=&FF) require leading spaces.
@label=OUT_SP_NO
*$192A XOR A          ; Clear the #REGa register.
; The #REGhl register pair holds the line number and the #REGbc register the
; value for 'repeated subtraction' (-1000, -100 or -10).
@label=OUT_SP_1
*$192B ADD HL,BC      ; The 'trial subtraction'.
 $192C INC A          ; Count each 'trial'.
 $192D JR C,$192B     ; Jump back until exhausted.
 $192F SBC HL,BC      ; {Restore last 'subtraction' and discount it.
 $1931 DEC A          ; }
 $1932 JR Z,$1925     ; If no 'subtractions' were possible jump back to see if
                      ; a space is to be printed.
 $1934 JP $15EF       ; Otherwise print the digit.
; This entry point is used by the routine at #R$1855 to print a character or
; token.
@label=OUT_CHAR
*$1937 CALL $2D1B     ; Return carry reset if handling a digit code.
 $193A JR NC,$196C    ; Jump forward to print the digit.
 $193C CP $21         ; {Also print the control characters and 'space'.
 $193E JR C,$196C     ; }
 $1940 RES 2,(IY+$01) ; Signal 'print in K-mode' (reset bit 2 of
                      ; #SYSVAR(FLAGS)).
 $1944 CP $CB         ; {Jump forward if dealing with the token 'THEN'.
 $1946 JR Z,$196C     ; }
 $1948 CP ":"         ; {Jump forward unless dealing with ':'.
 $194A JR NZ,$195A    ; }
 $194C BIT 5,(IY+$37) ; {Jump forward to print the ':' if in 'INPUT mode' (bit
 $1950 JR NZ,$1968    ; 5 of #SYSVAR(FLAGX) set).}
 $1952 BIT 2,(IY+$30) ; {Jump forward if the ':' is 'not in quotes' (bit 2 of
 $1956 JR Z,$196C     ; #R$5C6A(FLAGS2) reset), i.e. an inter-statement marker.
                      ; }
 $1958 JR $1968       ; The ':' is inside quotes and can now be printed.
@label=OUT_CH_1
*$195A CP "\""        ; {Accept for printing all characters except '"'.
 $195C JR NZ,$1968    ; }
 $195E PUSH AF        ; Save the character code whilst changing the 'quote
                      ; mode'.
 $195F LD A,($5C6A)   ; {Fetch #R$5C6A(FLAGS2) and flip bit 2.
 $1962 XOR $04        ; }
 $1964 LD ($5C6A),A   ; {Enter the amended value into #R$5C6A(FLAGS2) and
 $1967 POP AF         ; restore the character code.}
@label=OUT_CH_2
*$1968 SET 2,(IY+$01) ; Signal 'the next character is to be printed in L-mode'
                      ; (set bit 2 of #SYSVAR(FLAGS)).
@label=OUT_CH_3
*$196C RST $10        ; {The present character is printed before returning.
 $196D RET            ; }
; Note: it is the consequence of the tests on the present character that
; determines whether the next character is to be printed in 'K' or 'L' mode.
; .
; Also note how the program does not cater for ':' in REM statements.

; THE 'LINE-ADDR' SUBROUTINE
;
; Used by the routines at #R$0FA9, #R$1059, #R$155D, #R$1795, #R$17F9, #R$190F,
; #R$1B9E and #R$1E42.
; .
; For a given line number, in the #REGhl register pair, this subroutine returns
; the starting address of that line or the 'first line after', in the #REGhl
; register pair, and the start of the previous line in the #REGde register
; pair.
; .
; If the line number is being used the zero flag will be set. However if the
; 'first line after' is substituted then the zero flag is returned reset.
;
;   HL Target line number
; O:DE Start address of the line before the target
; O:HL Start address of the target line (if found) or the first line after
; O:F Zero flag set if the target line was found
@label=LINE_ADDR
c$196E PUSH HL       ; Save the given line number.
 $196F LD HL,($5C53) ; {Fetch the system variable #SYSVAR(PROG) and transfer
 $1972 LD D,H        ; the address to the #REGde register pair.
 $1973 LD E,L        ; }
; Now enter a loop to test the line number of each line of the program against
; the given line number until the line number is matched or exceeded.
@label=LINE_AD_1
*$1974 POP BC        ; The given line number.
 $1975 CALL $1980    ; Compare the given line number against the addressed line
                     ; number
 $1978 RET NC        ; {Return if carry reset; otherwise address the next
 $1979 PUSH BC       ; line's number.
 $197A CALL $19B8    ; }
 $197D EX DE,HL      ; {Switch the pointers and jump back to consider the next
 $197E JR $1974      ; line of the program.}

; THE 'COMPARE LINE NUMBERS' SUBROUTINE
;
; Used by the routines at #R$1855 and #R$196E.
; .
; The given line number in the #REGbc register pair is matched against the
; addressed line number.
;
;   BC First line number
;   HL Address of the second line number
; O:F Zero flag set if the line numbers match
; O:F Carry flag set if the first line number is greater than the second
@label=CP_LINES
c$1980 LD A,(HL)     ; {Fetch the high byte of the addressed line number and
 $1981 CP B          ; compare it.}
 $1982 RET NZ        ; Return if they do not match.
 $1983 INC HL        ; {Next compare the low bytes.
 $1984 LD A,(HL)     ;
 $1985 DEC HL        ;
 $1986 CP C          ; }
 $1987 RET           ; Return with the carry flag set if the addressed line
                     ; number has yet to reach the given line number.

; Unused
u$1988 INC HL
 $1989 INC HL
 $198A INC HL

; THE 'FIND EACH STATEMENT' SUBROUTINE
;
; Used by the routines at #R$1BD1, #R$1D86, #R$1E39 and #R$27BD.
; .
; This subroutine has two distinct functions.
; .
; #LIST
; { It can be used to find the #REGdth statement in a BASIC line - returning
; with the #REGhl register pair addressing the location before the start of the
; statement and the zero flag set. }
; { Also the subroutine can be used to find a statement, if any, that starts
; with a given token code (in the #REGe register). }
; LIST#
;
;   D Statement number to look for (or &00 if looking for a token code)
;   E Token code to look for (or &00 if looking for a statement)
;   HL Address of the next character to consider
; O:HL Address of the token code or first character in the statement (if found)
; O:F Carry flag reset if the token code is found
; O:F Zero flag set if the statement is found
@label=EACH_STMT
c$198B LD ($5C5D),HL ; Set #SYSVAR(CH-ADD) to the current byte.
 $198E LD C,$00      ; Set a 'quotes off' flag.
; Enter a loop to handle each statement in the BASIC line.
@label=EACH_S_1
*$1990 DEC D         ; {Decrease #REGd and return if the required statement has
 $1991 RET Z         ; been found.}
 $1992 RST $20       ; {Fetch the next character code and jump if it does not
 $1993 CP E          ; match the given token code.
 $1994 JR NZ,$199A   ; }
 $1996 AND A         ; {But should it match then return with the carry and the
 $1997 RET           ; zero flags both reset.}
; Now enter another loop to consider the individual characters in the line to
; find where the statement ends.
@label=EACH_S_2
*$1998 INC HL        ; {Update the pointer and fetch the new code.
 $1999 LD A,(HL)     ; }
@label=EACH_S_3
*$199A CALL $18B6    ; Step over any number.
 $199D LD ($5C5D),HL ; Update #SYSVAR(CH-ADD).
 $19A0 CP "\""       ; {Jump forward if the character is not a '"'.
 $19A2 JR NZ,$19A5   ; }
 $19A4 DEC C         ; Otherwise set the 'quotes flag'.
@label=EACH_S_4
*$19A5 CP ":"        ; {Jump forward if the character is a ':'.
 $19A7 JR Z,$19AD    ; }
 $19A9 CP $CB        ; {Jump forward unless the code is the token 'THEN'.
 $19AB JR NZ,$19B1   ; }
@label=EACH_S_5
*$19AD BIT 0,C       ; {Read the 'quotes flag' and jump back at the end of each
 $19AF JR Z,$1990    ; statement (including after 'THEN').}
@label=EACH_S_6
*$19B1 CP $0D        ; {Jump back unless at the end of a BASIC line.
 $19B3 JR NZ,$1998   ; }
 $19B5 DEC D         ; {Decrease the statement counter and set the carry flag
 $19B6 SCF           ; before returning.
 $19B7 RET           ; }

; THE 'NEXT-ONE' SUBROUTINE
;
; Used by the routines at #R$08B6, #R$092C, #R$155D, #R$1795, #R$196E, #R$28B2
; and #R$2C02.
; .
; This subroutine can be used to find the 'next line' in the program area or
; the 'next variable' in the variables area. The subroutine caters for the six
; different types of variable that are used in the Spectrum system.
;
;   HL Start address of the current line or variable
; O:BC Length of the current line or variable
; O:DE Start address of the next line or variable
; O:HL Start address of the current line or variable (as on entry)
@label=NEXT_ONE
c$19B8 PUSH HL       ; Save the address of the current line or variable.
 $19B9 LD A,(HL)     ; Fetch the first byte.
 $19BA CP $40        ; {Jump forward if searching for a 'next line'.
 $19BC JR C,$19D5    ; }
 $19BE BIT 5,A       ; {Jump forward if searching for the next string or array
 $19C0 JR Z,$19D6    ; variable.}
 $19C2 ADD A,A       ; {Jump forward with simple numeric and FOR-NEXT
 $19C3 JP M,$19C7    ; variables.}
 $19C6 CCF           ; Long name numeric variables only.
@keep
@label=NEXT_O_1
*$19C7 LD BC,$0005   ; {A numeric variable will occupy five locations but a
 $19CA JR NC,$19CE   ; FOR-NEXT control variable will need eighteen locations.
 $19CC LD C,$12      ; }
@label=NEXT_O_2
*$19CE RLA           ; The carry flag becomes reset for long named variables
                     ; only, until the final character of the long name is
                     ; reached.
 $19CF INC HL        ; {Increment the pointer and fetch the new code.
 $19D0 LD A,(HL)     ; }
 $19D1 JR NC,$19CE   ; Jump back unless the previous code was the last code of
                     ; the variable's name.
 $19D3 JR $19DB      ; Now jump forward (#REGbc=&0005 or &0012).
@label=NEXT_O_3
*$19D5 INC HL        ; Step past the low byte of the line number.
@label=NEXT_O_4
*$19D6 INC HL        ; Now point to the low byte of the length.
 $19D7 LD C,(HL)     ; {Fetch the length into the #REGbc register pair.
 $19D8 INC HL        ;
 $19D9 LD B,(HL)     ; }
 $19DA INC HL        ; Allow for the inclusive byte.
; In all cases the address of the 'next' line or variable is found.
@label=NEXT_O_5
*$19DB ADD HL,BC     ; Point to the first byte of the 'next' line or variable.
 $19DC POP DE        ; Fetch the address of the previous one and continue into
                     ; #R$19DD.

; THE 'DIFFERENCE' SUBROUTINE
;
; Used by the routine at #R$19E5.
; .
; The routine at #R$19B8 continues here.
; .
; The 'length' between two 'starts' is formed in the #REGbc register pair. The
; pointers are reformed but returned exchanged.
;
;   DE First address
;   HL Second address
; O:BC #REGhl-#REGde
; O:DE Second address (as in #REGhl on entry)
; O:HL First address (as in #REGde on entry)
@label=DIFFER
c$19DD AND A         ; Prepare for a true subtraction.
 $19DE SBC HL,DE     ; {Find the length from one 'start' to the next and pass
 $19E0 LD B,H        ; it to the #REGbc register pair.
 $19E1 LD C,L        ; }
 $19E2 ADD HL,DE     ; {Reform the address and exchange them before returning.
 $19E3 EX DE,HL      ;
 $19E4 RET           ; }

; THE 'RECLAIMING' SUBROUTINE
;
; Used by the routines at #R$0808, #R$1097, #R$16D4 and #R$1EAC.
; .
; The main entry point is used when the address of the first location to be
; reclaimed is in the #REGde register pair and the address of the first
; location to be left alone is in the #REGhl register pair. The entry point
; #R$19E8 is used when the #REGhl register pair points to the first location to
; be reclaimed and the #REGbc register pair holds the number of bytes that are
; to be reclaimed.
;
;   DE Start address of the area to reclaim
;   HL One past the end address of the area to reclaim
; O:HL Start address of the area reclaimed (as #REGde on entry)
@label=RECLAIM_1
c$19E5 CALL $19DD    ; Use the 'difference' subroutine to develop the
                     ; appropriate values.
; This entry point is used by the routines at #R$0808, #R$092C, #R$1015,
; #R$11A7, #R$155D, #R$2AFF and #R$2C02.
@label=RECLAIM_2
*$19E8 PUSH BC       ; Save the number of bytes to be reclaimed.
 $19E9 LD A,B        ; {All the system variable pointers above the area have to
 $19EA CPL           ; be reduced by #REGbc, so this number is 2's complemented
 $19EB LD B,A        ; before the pointers are altered.
 $19EC LD A,C        ;
 $19ED CPL           ;
 $19EE LD C,A        ;
 $19EF INC BC        ;
 $19F0 CALL $1664    ; }
 $19F3 EX DE,HL      ; {Return the 'first location' address to the #REGde
 $19F4 POP HL        ; register pair and form the address of the first location
 $19F5 ADD HL,DE     ; to the left.}
 $19F6 PUSH DE       ; {Save the 'first location' whilst the actual reclamation
 $19F7 LDIR          ; occurs.
 $19F9 POP HL        ; }
 $19FA RET           ; Now return.

; THE 'E-LINE-NO' SUBROUTINE
;
; Used by the routines at #R$12A2 and #R$1B17.
; .
; This subroutine is used to read the line number of the line in the editing
; area. If there is no line number, i.e. a direct BASIC line, then the line
; number is considered to be zero.
;
; O:BC Number of the line in the editing area (or &0000 if none)
@label=E_LINE_NO
c$19FB LD HL,($5C59) ; Pick up the pointer to the edit-line (#SYSVAR(E-LINE)).
 $19FE DEC HL        ; {Set #SYSVAR(CH-ADD) to point to the location before any
 $19FF LD ($5C5D),HL ; number.}
 $1A02 RST $20       ; Pass the first code to the #REGa register.
 $1A03 LD HL,$5C92   ; {However before considering the code make the
 $1A06 LD ($5C65),HL ; calculator's memory area a temporary calculator stack
                     ; area (by setting #SYSVAR(STKEND) equal to
                     ; #SYSVAR(MEMBOT)).}
 $1A09 CALL $2D3B    ; Now read the digits of the line number. Return zero if
                     ; no number exists.
 $1A0C CALL $2DA2    ; Compress the line number into the #REGbc register pair.
 $1A0F JR C,$1A15    ; Jump forward if the number exceeds 65,536.
 $1A11 LD HL,$D8F0   ; {Otherwise test it against 10,000.
 $1A14 ADD HL,BC     ; }
@label=E_L_1
*$1A15 JP C,$1C8A    ; Give report C if over 9,999.
 $1A18 JP $16C5      ; Return via #R$16C5 that restores the calculator stack to
                     ; its rightful place.

; THE 'REPORT AND LINE NUMBER PRINTING' SUBROUTINE
;
; The entry point #R$1A1B, used by the routines at #R$12A2 and #R$2DE3, will
; lead to the number in the #REGbc register pair being printed. Any value over
; 9,999 will not however be printed correctly.
;
; BC Number to print
@label=OUT_NUM_1
c$1A1B PUSH DE       ; {Save the other registers throughout the subroutine.
 $1A1C PUSH HL       ; }
 $1A1D XOR A         ; Clear the #REGa register.
 $1A1E BIT 7,B       ; {Jump forward to print a zero rather than '-2' when
 $1A20 JR NZ,$1A42   ; reporting on the edit-line.}
 $1A22 LD H,B        ; {Move the number to the #REGhl register pair.
 $1A23 LD L,C        ; }
 $1A24 LD E,$FF      ; Flag 'no leading spaces'.
 $1A26 JR $1A30      ; Jump forward to print the number.
; The entry point #R$1A28, used by the routine at #R$1855, will lead to the
; number indirectly addressed by the #REGhl register pair being printed. This
; time any necessary leading spaces will appear. Again the limit of correctly
; printed numbers is 9,999.
@label=OUT_NUM_2
*$1A28 PUSH DE       ; Save the #REGde register pair.
 $1A29 LD D,(HL)     ; {Fetch the number into the #REGde register pair and save
 $1A2A INC HL        ; the pointer (updated).
 $1A2B LD E,(HL)     ;
 $1A2C PUSH HL       ; }
 $1A2D EX DE,HL      ; {Move the number to the #REGhl register pair and flag
 $1A2E LD E,$20      ; 'leading spaces are to be printed'.}
; Now the integer form of the number in the #REGhl register pair is printed.
@label=OUT_NUM_3
*$1A30 LD BC,$FC18   ; This is '-1,000'.
 $1A33 CALL $192A    ; Print a first digit.
 $1A36 LD BC,$FF9C   ; This is '-100'.
 $1A39 CALL $192A    ; Print the second digit.
 $1A3C LD C,$F6      ; This is '-10'.
 $1A3E CALL $192A    ; Print the third digit.
 $1A41 LD A,L        ; Move any remaining part of the number to the #REGa
                     ; register.
@label=OUT_NUM_4
*$1A42 CALL $15EF    ; Print the digit.
 $1A45 POP HL        ; {Restore the registers before returning.
 $1A46 POP DE        ;
 $1A47 RET           ; }

; THE SYNTAX TABLES
;
; Used by the routine at #R$1B28.
; .
; i. The offset table.
; .
; There is an offset value for each of the fifty BASIC commands.
@label=SYNTAX
b$1A48 DEFB $B1      ; #R$1AF9
 $1A49 DEFB $CB      ; #R$1B14
 $1A4A DEFB $BC      ; #R$1B06
 $1A4B DEFB $BF      ; #R$1B0A
 $1A4C DEFB $C4      ; #R$1B10
 $1A4D DEFB $AF      ; #R$1AFC
 $1A4E DEFB $B4      ; #R$1B02
 $1A4F DEFB $93      ; #R$1AE2
 $1A50 DEFB $91      ; #R$1AE1
 $1A51 DEFB $92      ; #R$1AE3
 $1A52 DEFB $95      ; #R$1AE7
 $1A53 DEFB $98      ; #R$1AEB
 $1A54 DEFB $98      ; #R$1AEC
 $1A55 DEFB $98      ; #R$1AED
 $1A56 DEFB $98      ; #R$1AEE
 $1A57 DEFB $98      ; #R$1AEF
 $1A58 DEFB $98      ; #R$1AF0
 $1A59 DEFB $98      ; #R$1AF1
 $1A5A DEFB $7F      ; #R$1AD9
 $1A5B DEFB $81      ; #R$1ADC
 $1A5C DEFB $2E      ; #R$1A8A
 $1A5D DEFB $6C      ; #R$1AC9
 $1A5E DEFB $6E      ; #R$1ACC
 $1A5F DEFB $70      ; #R$1ACF
 $1A60 DEFB $48      ; #R$1AA8
 $1A61 DEFB $94      ; #R$1AF5
 $1A62 DEFB $56      ; #R$1AB8
 $1A63 DEFB $3F      ; #R$1AA2
 $1A64 DEFB $41      ; #R$1AA5
 $1A65 DEFB $2B      ; #R$1A90
 $1A66 DEFB $17      ; #R$1A7D
 $1A67 DEFB $1F      ; #R$1A86
 $1A68 DEFB $37      ; #R$1A9F
 $1A69 DEFB $77      ; #R$1AE0
 $1A6A DEFB $44      ; #R$1AAE
 $1A6B DEFB $0F      ; #R$1A7A
 $1A6C DEFB $59      ; #R$1AC5
 $1A6D DEFB $2B      ; #R$1A98
 $1A6E DEFB $43      ; #R$1AB1
 $1A6F DEFB $2D      ; #R$1A9C
 $1A70 DEFB $51      ; #R$1AC1
 $1A71 DEFB $3A      ; #R$1AAB
 $1A72 DEFB $6D      ; #R$1ADF
 $1A73 DEFB $42      ; #R$1AB5
 $1A74 DEFB $0D      ; #R$1A81
 $1A75 DEFB $49      ; #R$1ABE
 $1A76 DEFB $5C      ; #R$1AD2
 $1A77 DEFB $44      ; #R$1ABB
 $1A78 DEFB $15      ; #R$1A8D
 $1A79 DEFB $5D      ; #R$1AD6
; ii. The parameter table.
; .
; For each of the fifty BASIC commands there are up to eight entries in the
; parameter table. These entries comprise command class details, required
; separators and, where appropriate, command routine addresses.
@label=P_LET
 $1A7A DEFB $01      ; #R$1C1F
 $1A7B DEFB "="
 $1A7C DEFB $02      ; #R$1C4E
@label=P_GO_TO
 $1A7D DEFB $06      ; #R$1C82
 $1A7E DEFB $00      ; #R$1C10
 $1A7F DEFW $1E67
@label=P_IF
 $1A81 DEFB $06      ; #R$1C82
 $1A82 DEFB $CB      ; THEN
 $1A83 DEFB $05      ; #R$1C11
 $1A84 DEFW $1CF0
@label=P_GO_SUB
 $1A86 DEFB $06      ; #R$1C82
 $1A87 DEFB $00      ; #R$1C10
 $1A88 DEFW $1EED
@label=P_STOP
 $1A8A DEFB $00      ; #R$1C10
 $1A8B DEFW $1CEE
@label=P_RETURN
 $1A8D DEFB $00      ; #R$1C10
 $1A8E DEFW $1F23
@label=P_FOR
 $1A90 DEFB $04      ; #R$1C6C
 $1A91 DEFB "="
 $1A92 DEFB $06      ; #R$1C82
 $1A93 DEFB $CC      ; TO
 $1A94 DEFB $06      ; #R$1C82
 $1A95 DEFB $05      ; #R$1C11
 $1A96 DEFW $1D03
@label=P_NEXT
 $1A98 DEFB $04      ; #R$1C6C
 $1A99 DEFB $00      ; #R$1C10
 $1A9A DEFW $1DAB
@label=P_PRINT
 $1A9C DEFB $05      ; #R$1C11
 $1A9D DEFW $1FCD
@label=P_INPUT
 $1A9F DEFB $05      ; #R$1C11
 $1AA0 DEFW $2089
@label=P_DIM
 $1AA2 DEFB $05      ; #R$1C11
 $1AA3 DEFW $2C02
@label=P_REM
 $1AA5 DEFB $05      ; #R$1C11
 $1AA6 DEFW $1BB2
@label=P_NEW
 $1AA8 DEFB $00      ; #R$1C10
 $1AA9 DEFW $11B7
@label=P_RUN
 $1AAB DEFB $03      ; #R$1C0D
 $1AAC DEFW $1EA1
@label=P_LIST
 $1AAE DEFB $05      ; #R$1C11
 $1AAF DEFW $17F9
@label=P_POKE
 $1AB1 DEFB $08      ; #R$1C7A
 $1AB2 DEFB $00      ; #R$1C10
 $1AB3 DEFW $1E80
@label=P_RANDOM
 $1AB5 DEFB $03      ; #R$1C0D
 $1AB6 DEFW $1E4F
@label=P_CONT
 $1AB8 DEFB $00      ; #R$1C10
 $1AB9 DEFW $1E5F
@label=P_CLEAR
 $1ABB DEFB $03      ; #R$1C0D
 $1ABC DEFW $1EAC
@label=P_CLS
 $1ABE DEFB $00      ; #R$1C10
 $1ABF DEFW $0D6B
@label=P_PLOT
 $1AC1 DEFB $09      ; #R$1CBE
 $1AC2 DEFB $00      ; #R$1C10
 $1AC3 DEFW $22DC
@label=P_PAUSE
 $1AC5 DEFB $06      ; #R$1C82
 $1AC6 DEFB $00      ; #R$1C10
 $1AC7 DEFW $1F3A
@label=P_READ
 $1AC9 DEFB $05      ; #R$1C11
 $1ACA DEFW $1DED
@label=P_DATA
 $1ACC DEFB $05      ; #R$1C11
 $1ACD DEFW $1E27
@label=P_RESTORE
 $1ACF DEFB $03      ; #R$1C0D
 $1AD0 DEFW $1E42
@label=P_DRAW
 $1AD2 DEFB $09      ; #R$1CBE
 $1AD3 DEFB $05      ; #R$1C11
 $1AD4 DEFW $2382
@label=P_COPY
 $1AD6 DEFB $00      ; #R$1C10
 $1AD7 DEFW $0EAC
@label=P_LPRINT
 $1AD9 DEFB $05      ; #R$1C11
 $1ADA DEFW $1FC9
@label=P_LLIST
 $1ADC DEFB $05      ; #R$1C11
 $1ADD DEFW $17F5
@label=P_SAVE
 $1ADF DEFB $0B      ; #R$1CDB
@label=P_LOAD
 $1AE0 DEFB $0B      ; #R$1CDB
@label=P_VERIFY
 $1AE1 DEFB $0B      ; #R$1CDB
@label=P_MERGE
 $1AE2 DEFB $0B      ; #R$1CDB
@label=P_BEEP
 $1AE3 DEFB $08      ; #R$1C7A
 $1AE4 DEFB $00      ; #R$1C10
 $1AE5 DEFW $03F8
@label=P_CIRCLE
 $1AE7 DEFB $09      ; #R$1CBE
 $1AE8 DEFB $05      ; #R$1C11
 $1AE9 DEFW $2320
@label=P_INK
 $1AEB DEFB $07      ; #R$1C96
@label=P_PAPER
 $1AEC DEFB $07      ; #R$1C96
@label=P_FLASH
 $1AED DEFB $07      ; #R$1C96
@label=P_BRIGHT
 $1AEE DEFB $07      ; #R$1C96
@label=P_INVERSE
 $1AEF DEFB $07      ; #R$1C96
@label=P_OVER
 $1AF0 DEFB $07      ; #R$1C96
@label=P_OUT
 $1AF1 DEFB $08      ; #R$1C7A
 $1AF2 DEFB $00      ; #R$1C10
 $1AF3 DEFW $1E7A
@label=P_BORDER
 $1AF5 DEFB $06      ; #R$1C82
 $1AF6 DEFB $00      ; #R$1C10
 $1AF7 DEFW $2294
@label=P_DEF_FN
 $1AF9 DEFB $05      ; #R$1C11
 $1AFA DEFW $1F60
@label=P_OPEN
 $1AFC DEFB $06      ; #R$1C82
 $1AFD DEFB ","
 $1AFE DEFB $0A      ; #R$1C8C
 $1AFF DEFB $00      ; #R$1C10
 $1B00 DEFW $1736
@label=P_CLOSE
 $1B02 DEFB $06      ; #R$1C82
 $1B03 DEFB $00      ; #R$1C10
 $1B04 DEFW $16E5
@label=P_FORMAT
 $1B06 DEFB $0A      ; #R$1C8C
 $1B07 DEFB $00      ; #R$1C10
 $1B08 DEFW $1793
@label=P_MOVE
 $1B0A DEFB $0A      ; #R$1C8C
 $1B0B DEFB ","
 $1B0C DEFB $0A      ; #R$1C8C
 $1B0D DEFB $00      ; #R$1C10
 $1B0E DEFW $1793
@label=P_ERASE
 $1B10 DEFB $0A      ; #R$1C8C
 $1B11 DEFB $00      ; #R$1C10
 $1B12 DEFW $1793
@label=P_CAT
 $1B14 DEFB $00      ; #R$1C10
 $1B15 DEFW $1793
; Note: the requirements for the different command classes are as follows:
; .
; #LIST
; { #R$1C10 - No further operands. }
; { #R$1C1F - Used in LET. A variable is required. }
; { #R$1C4E - Used in LET. An expression, numeric or string, must follow. }
; { #R$1C0D - A numeric expression may follow. Zero to be used in case of
; default. }
; { #R$1C6C - A single character variable must follow. }
; { #R$1C11 - A set of items may be given. }
; { #R$1C82 - A numeric expression must follow. }
; { #R$1C96 - Handles colour items. }
; { #R$1C7A - Two numeric expressions, separated by a comma, must follow. }
; { #R$1CBE - As for CLASS_08 but colour items may precede the expressions. }
; { #R$1C8C - A string expression must follow. }
; { #R$1CDB - Handles cassette routines. }
; LIST#

; THE 'MAIN PARSER' OF THE BASIC INTERPRETER
;
; Used by the routine at #R$12A2.
; .
; The parsing routine of the BASIC interpreter is entered here when syntax is
; being checked, and at #R$1B8A when a BASIC program of one or more statements
; is to be executed.
; .
; Each statement is considered in turn and the system variable #SYSVAR(CH-ADD)
; is used to point to each code of the statement as it occurs in the program
; area or the editing area.
@label=LINE_SCAN
c$1B17 RES 7,(IY+$01) ; Signal 'syntax checking' (reset bit 7 of
                      ; #SYSVAR(FLAGS)).
 $1B1B CALL $19FB     ; #SYSVAR(CH-ADD) is made to point to the first code
                      ; after any line number.
 $1B1E XOR A          ; {The system variable #SYSVAR(SUBPPC) is initialised to
 $1B1F LD ($5C47),A   ; &00 and #SYSVAR(ERR-NR) to &FF.
 $1B22 DEC A          ;
 $1B23 LD ($5C3A),A   ; }
 $1B26 JR $1B29       ; Jump forward to consider the first statement of the
                      ; line.

; THE STATEMENT LOOP
;
; Used by the routines at #R$1BD1 and #R$1BF4.
; .
; Each statement is considered in turn until the end of the line is reached.
@label=STMT_LOOP
c$1B28 RST $20       ; Advance #SYSVAR(CH-ADD) along the line.
; This entry point is used by the routines at #R$1B17 and #R$1CF0.
@label=STMT_L_1
*$1B29 CALL $16BF    ; The work space is cleared.
 $1B2C INC (IY+$0D)  ; Increase #SYSVAR(SUBPPC) on each passage around the
                     ; loop.
 $1B2F JP M,$1C8A    ; But only '127' statements are allowed in a single line.
 $1B32 RST $18       ; Fetch a character.
 $1B33 LD B,$00      ; Clear the #REGb register for later.
 $1B35 CP $0D        ; Is the character a 'carriage return'?
 $1B37 JR Z,$1BB3    ; Jump if it is.
 $1B39 CP ":"        ; {Go around the loop again if it is a ':'.
 $1B3B JR Z,$1B28    ; }
; A statement has been identified so, first, its initial command is considered.
@nowarn
 $1B3D LD HL,$1B76   ; {Pre-load the machine stack with the return address
 $1B40 PUSH HL       ; #R$1B76.}
 $1B41 LD C,A        ; {Save the command temporarily in the #REGc register
 $1B42 RST $20       ; whilst #SYSVAR(CH-ADD) is advanced again.
 $1B43 LD A,C        ; }
 $1B44 SUB $CE       ; Reduce the command's code by &CE, giving the range &00
                     ; to &31 for the fifty commands.
 $1B46 JP C,$1C8A    ; Give the appropriate error if not a command code.
 $1B49 LD C,A        ; Move the command code to the #REGbc register pair (#REGb
                     ; holds &00).
 $1B4A LD HL,$1A48   ; The base address of the #R$1A48(syntax offset table).
 $1B4D ADD HL,BC     ; {The required offset is passed to the #REGc register and
 $1B4E LD C,(HL)     ; used to compute the base address for the command's
 $1B4F ADD HL,BC     ; entries in the #R$1A7A(parameter table).}
 $1B50 JR $1B55      ; Jump forward into the scanning loop with this address.
; Each of the command class routines applicable to the present command is
; executed in turn. Any required separators are also considered.
@label=SCAN_LOOP
 $1B52 LD HL,($5C74) ; The temporary pointer to the entries in the
                     ; #R$1A7A(parameter table) (#SYSVAR(T-ADDR)).
@label=GET_PARAM
*$1B55 LD A,(HL)     ; Fetch each entry in turn.
 $1B56 INC HL        ; {Update the pointer to the entries (#SYSVAR(T-ADDR)) for
 $1B57 LD ($5C74),HL ; the next pass.}
@nowarn
 $1B5A LD BC,$1B52   ; {Pre-load the machine stack with the return address
 $1B5D PUSH BC       ; #R$1B52.}
 $1B5E LD C,A        ; Copy the entry to the #REGc register for later.
 $1B5F CP $20        ; {Jump forward if the entry is a 'separator'.
 $1B61 JR NC,$1B6F   ; }
 $1B63 LD HL,$1C01   ; The base address of the #R$1C01(command class table).
 $1B66 LD B,$00      ; {Clear the #REGb register and index into the table.
 $1B68 ADD HL,BC     ; }
 $1B69 LD C,(HL)     ; {Fetch the offset and compute the starting address of
 $1B6A ADD HL,BC     ; the required command class routine.}
 $1B6B PUSH HL       ; Push the address on to the machine stack.
 $1B6C RST $18       ; {Before making an indirect jump to the command class
 $1B6D DEC B         ; routine pass the command code to the #REGa register and
 $1B6E RET           ; set the #REGb register to &FF.}

; THE 'SEPARATOR' SUBROUTINE
;
; Used by the routine at #R$1B28.
; .
; The report 'Nonsense in BASIC' is given if the required separator is not
; present. But note that when syntax is being checked the actual report does
; not appear on the screen - only the 'error marker'.
;
; C Entry from the #R$1A7A(parameter table)
@label=SEPARATOR
c$1B6F RST $18       ; {The current character is fetched and compared to the
 $1B70 CP C          ; entry in the parameter table.}
 $1B71 JP NZ,$1C8A   ; Give the error report if there is not a match.
 $1B74 RST $20       ; {Step past a correct character and return.
 $1B75 RET           ; }

; THE 'STMT-RET' SUBROUTINE
;
; Used by the routine at #R$1B28.
; .
; After the correct interpretation of a statement a return is made to this
; entry point.
@refs=$1E67,$1EED,$1F23,$1D03,$1DAB,$1FC9,$2089,$2C02,$1EA1,$17F9,$1E80,$1E4F,$1E5F,$1EAC,$0D6B,$22DC,$1F3A,$1DEC,$1E27,$1E42,$2382,$0EAC,$17F5,$03F8,$2320,$1E7A,$2294,$1F60,$1736,$16E5
@label=STMT_RET
c$1B76 CALL $1F54     ; The BREAK key is tested after every statement.
 $1B79 JR C,$1B7D     ; Jump forward unless it has been pressed.
; Report L - BREAK into program.
 $1B7B RST $08        ; {Call the error handling routine.
 $1B7C DEFB $14       ; }
; Continue here as the BREAK key was not pressed.
@label=STMT_R_1
*$1B7D BIT 7,(IY+$0A) ; {Jump forward if there is not a 'jump' to be made
 $1B81 JR NZ,$1BF4    ; (#SYSVAR(NSPPC) is &FF).}
 $1B83 LD HL,($5C42)  ; {Fetch the 'new line' number (#SYSVAR(NEWPPC)) and jump
 $1B86 BIT 7,H        ; forward unless dealing with a further statement in the
 $1B88 JR Z,$1B9E     ; editing area.}
; This routine continues into #R$1B8A.

; THE 'LINE-RUN' ENTRY POINT
;
; Used by the routine at #R$12A2.
; .
; The routine at #R$1B76 continues here.
; .
; This entry point is used wherever a line in the editing area is to be 'run'.
; In such a case the syntax/run flag (bit 7 of #SYSVAR(FLAGS)) will be set.
; .
; The entry point is also used in the syntax checking of a line in the editing
; area that has more than one statement (bit 7 of #SYSVAR(FLAGS) will be
; reset).
@label=LINE_RUN
c$1B8A LD HL,$FFFE   ; {A line in the editing area is considered as line '-2';
 $1B8D LD ($5C45),HL ; set #SYSVAR(PPC) accordingly}
 $1B90 LD HL,($5C61) ; {Make #REGhl point to the end marker of the editing area
 $1B93 DEC HL        ; (#SYSVAR(WORKSP)-1) and #REGde to the location before
 $1B94 LD DE,($5C59) ; the start of that area (#SYSVAR(E-LINE)-1).
 $1B98 DEC DE        ; }
 $1B99 LD A,($5C44)  ; {Fetch the number of the next statement to be handled
 $1B9C JR $1BD1      ; (#SYSVAR(NSPPC)) before jumping forward.}

; THE 'LINE-NEW' SUBROUTINE
;
; Used by the routine at #R$1B76.
; .
; There has been a jump in the program and the starting address of the new line
; has to be found.
;
; HL Number of the new line
@label=LINE_NEW
c$1B9E CALL $196E    ; The starting address of the line, or the 'first line
                     ; after' is found.
 $1BA1 LD A,($5C44)  ; Collect the statement number (#SYSVAR(NSPPC)).
 $1BA4 JR Z,$1BBF    ; {Jump forward if the required line was found; otherwise
 $1BA6 AND A         ; check the validity of the statement number - must be
 $1BA7 JR NZ,$1BEC   ; zero.}
 $1BA9 LD B,A        ; {Also check that the 'first line after' is not after the
 $1BAA LD A,(HL)     ; actual 'end of program'.
 $1BAB AND $C0       ;
 $1BAD LD A,B        ; }
 $1BAE JR Z,$1BBF    ; Jump forward with valid addresses; otherwise signal the
                     ; error 'OK'.
; Report 0 - OK.
 $1BB0 RST $08       ; {Use the error handling routine.
 $1BB1 DEFB $FF      ; }
; Note: obviously not an error in the normal sense - but rather a jump past the
; program.

; THE 'REM' COMMAND ROUTINE
;
; The address of this routine is found in the #R$1AA5(parameter table).
; .
; The return address to #R$1B76 is dropped which has the effect of forcing the
; rest of the line to be ignored.
@refs=$1C0D
@label=REM
c$1BB2 POP BC        ; Drop the address - #R$1B76.
; This routine continues into #R$1BB3.

; THE 'LINE-END' ROUTINE
;
; Used by the routines at #R$1B28, #R$1BF4 and #R$1CF0.
; .
; The routine at #R$1BB2 continues here.
; .
; If checking syntax a simple return is made but when 'running' the address
; held by #SYSVAR(NXTLIN) has to be checked before it can be used.
@label=LINE_END
c$1BB3 CALL $2530    ; {Return if syntax is being checked; otherwise fetch the
 $1BB6 RET Z         ; address in #SYSVAR(NXTLIN).
 $1BB7 LD HL,($5C55) ; }
 $1BBA LD A,$C0      ; {Return also if the address is after the end of the
 $1BBC AND (HL)      ; program - the 'run' is finished.
 $1BBD RET NZ        ; }
 $1BBE XOR A         ; Signal 'statement zero' before proceeding.
; This routine continues into #R$1BBF.

; THE 'LINE-USE' ROUTINE
;
; Used by the routine at #R$1B9E.
; .
; The routine at #R$1BB3 continues here.
; .
; This short routine has three functions:
; .
; #LIST
; { Change statement zero to statement '1'. }
; { Find the number of the new line and enter it into #SYSVAR(PPC). }
; { Form the address of the start of the line after. }
; LIST#
;
; A Statement number
; HL Start address of the line
@label=LINE_USE
c$1BBF CP $01        ; {Statement zero becomes statement '1'.
 $1BC1 ADC A,$00     ; }
 $1BC3 LD D,(HL)     ; {The line number of the line to be used is collected and
 $1BC4 INC HL        ; passed to #SYSVAR(PPC).
 $1BC5 LD E,(HL)     ;
 $1BC6 LD ($5C45),DE ; }
 $1BCA INC HL        ; {Now find the 'length' of the line.
 $1BCB LD E,(HL)     ;
 $1BCC INC HL        ;
 $1BCD LD D,(HL)     ; }
 $1BCE EX DE,HL      ; Switch over the values.
 $1BCF ADD HL,DE     ; {Form the address of the start of the line after in
 $1BD0 INC HL        ; #REGhl and the location before the 'next' line's first
                     ; character in #REGde.}
; This routine continues into #R$1BD1.

; THE 'NEXT-LINE' ROUTINE
;
; Used by the routine at #R$1B8A.
; .
; The routine at #R$1BBF continues here.
; .
; On entry the #REGhl register pair points to the location after the end of the
; 'next' line to be handled and the #REGde register pair to the location before
; the first character of the line. This applies to lines in the program area
; and also to a line in the editing area - where the next line will be the same
; line again whilst there are still statements to be interpreted.
;
; DE One before the address of the first character in the line
; HL Start address of the following line
@label=NEXT_LINE
c$1BD1 LD ($5C55),HL   ; Set #SYSVAR(NXTLIN) for use once the current line has
                       ; been completed.
 $1BD4 EX DE,HL        ; {As usual #SYSVAR(CH-ADD) points to the location
 $1BD5 LD ($5C5D),HL   ; before the first character to be considered.}
 $1BD8 LD D,A          ; The statement number is fetched.
 $1BD9 LD E,$00        ; The #REGe register is cleared in case #R$198B is used.
 $1BDB LD (IY+$0A),$FF ; Signal 'no jump' by setting #SYSVAR(NSPPC) to &FF.
 $1BDF DEC D           ; {The statement number minus one goes into
 $1BE0 LD (IY+$0D),D   ; #SYSVAR(SUBPPC).}
 $1BE3 JP Z,$1B28      ; A first statement can now be considered.
 $1BE6 INC D           ; {However for later statements the 'starting address'
 $1BE7 CALL $198B      ; has to be found.}
 $1BEA JR Z,$1BF4      ; Jump forward unless the statement does not exist.
; This entry point is used by the routine at #R$1B9E.
; .
; Report N - Statement lost.
@label=REPORT_N
*$1BEC RST $08         ; {Call the error handling routine.
 $1BED DEFB $16        ; }

; THE 'CHECK-END' SUBROUTINE
;
; Used by the routines at #R$0605, #R$17F9, #R$1C0D, #R$1C4E, #R$1C96, #R$1D03,
; #R$1DEC, #R$1E27, #R$1F60, #R$1FC9, #R$2089, #R$2320, #R$2382 and #R$2C02.
; .
; This is an important routine and is called from many places in the monitor
; program when the syntax of the edit-line is being checked. The purpose of the
; routine is to give an error report if the end of a statement has not been
; reached and to move on to the next statement if the syntax is correct.
@label=CHECK_END
c$1BEE CALL $2530    ; {Do not proceed unless checking syntax.
 $1BF1 RET NZ        ; }
 $1BF2 POP BC        ; {Drop the addresses of #R$1B52 and #R$1B76 before
 $1BF3 POP BC        ; continuing into #R$1BF4.}

; THE 'STMT-NEXT' ROUTINE
;
; Used by the routines at #R$1B76 and #R$1BD1.
; .
; The routine at #R$1BEE continues here.
; .
; If the present character is a 'carriage return' then the 'next statement' is
; on the 'next line'; if ':' it is on the same line; but if any other character
; is found then there is an error in syntax.
@label=STMT_NEXT
c$1BF4 RST $18       ; Fetch the present character.
 $1BF5 CP $0D        ; {Consider the 'next line' if it is a 'carriage return'.
 $1BF7 JR Z,$1BB3    ; }
 $1BF9 CP ":"        ; {Consider the 'next statement' if it is a ':'.
 $1BFB JP Z,$1B28    ; }
 $1BFE JP $1C8A      ; Otherwise there has been a syntax error.

; THE 'COMMAND CLASS' TABLE
;
; Used by the routine at #R$1B28.
@label=CMDCLASS
b$1C01 DEFB $0F      ; #R$1C10
 $1C02 DEFB $1D      ; #R$1C1F
 $1C03 DEFB $4B      ; #R$1C4E
 $1C04 DEFB $09      ; #R$1C0D
 $1C05 DEFB $67      ; #R$1C6C
 $1C06 DEFB $0B      ; #R$1C11
 $1C07 DEFB $7B      ; #R$1C82
 $1C08 DEFB $8E      ; #R$1C96
 $1C09 DEFB $71      ; #R$1C7A
 $1C0A DEFB $B4      ; #R$1CBE
 $1C0B DEFB $81      ; #R$1C8C
 $1C0C DEFB $CF      ; #R$1CDB

; THE 'COMMAND CLASSES - &00, &03 and &05'
;
; The address of this routine is derived from an offset found in the
; #R$1C01(command class table).
; .
; The commands of class &03 may, or may not, be followed by a number. e.g. RUN
; and RUN 200.
;
; A Code of the first character after the command
; HL Address of the first character after the command
@refs=$1B28
@label=CLASS_03
c$1C0D CALL $1CDE    ; A number is fetched but zero is used in cases of
                     ; default.
; The address of this entry point is derived from an offset found in the
; #R$1C01(command class table).
; .
; The commands of class &00 must not have any operands, e.g. COPY and CONTINUE.
@refs=$1B28
@label=CLASS_00
*$1C10 CP A          ; Set the zero flag for later.
; The address of this entry point is derived from an offset found in the
; #R$1C01(command class table).
; .
; The commands of class &05 may be followed by a set of items, e.g. PRINT and
; PRINT "222".
@refs=$1B28
@label=CLASS_05
*$1C11 POP BC        ; In all cases drop the address - #R$1B52.
 $1C12 CALL Z,$1BEE  ; If handling commands of classes &00 and &03 and syntax
                     ; is being checked move on now to consider the next
                     ; statement.
 $1C15 EX DE,HL      ; Save the line pointer in the #REGde register pair.
; After the command class entries and the separator entries in the
; #R$1A7A(parameter table) have been considered the jump to the appropriate
; command routine is made.
 $1C16 LD HL,($5C74) ; {Fetch the pointer to the entries in the
 $1C19 LD C,(HL)     ; #R$1A7A(parameter table) from #SYSVAR(T-ADDR) and fetch
 $1C1A INC HL        ; the address of the required command routine.
 $1C1B LD B,(HL)     ; }
 $1C1C EX DE,HL      ; {Exchange the pointers back and make an indirect jump to
 $1C1D PUSH BC       ; the command routine.
 $1C1E RET           ; }

; THE 'COMMAND CLASS &01' ROUTINE
;
; Used by the routines at #R$1DEC and #R$2089.
; .
; The address of this routine is derived from an offset found in the
; #R$1C01(command class table).
; .
; Command class &01 is concerned with the identification of the variable in a
; LET, READ or INPUT statement.
@refs=$1B28
@label=CLASS_01
c$1C1F CALL $28B2    ; Look in the variables area to determine whether or not
                     ; the variable has been used already.
; This routine continues into #R$1C22.

; THE 'VARIABLE IN ASSIGNMENT' SUBROUTINE
;
; Used by the routine at #R$1C6C.
; .
; The routine at #R$1C1F continues here.
; .
; This subroutine develops the appropriate values for the system variables
; #SYSVAR(DEST) and #SYSVAR(STRLEN).
;
; C Bit 5: Set if the variable is numeric, reset if it's a string
; C Bit 6: Set if the variable is simple, reset if it's an array
; C Bit 7: Set if checking syntax, reset if executing
; HL Address of the last letter of the variable's name (in the variables area,
; .  if it exists)
; F Carry flag reset if the variable already exists
; F Zero flag reset if the variable is simple (not an array) and does not exist
@label=VAR_A_1
c$1C22 LD (IY+$37),$00 ; Initialise #SYSVAR(FLAGX) to &00.
 $1C26 JR NC,$1C30     ; Jump forward if the variable has been used before.
 $1C28 SET 1,(IY+$37)  ; Signal 'a new variable' (set bit 1 of #SYSVAR(FLAGX)).
 $1C2C JR NZ,$1C46     ; Give an error if trying to use an 'undimensioned
                       ; array'.
; This entry point is used by the routines at #R$1DAB and #R$26C9.
; .
; Report 2 - Variable not found.
@label=REPORT_2
*$1C2E RST $08         ; {Call the error handling routine.
 $1C2F DEFB $01        ; }
; Continue with the handling of existing variables.
@label=VAR_A_2
*$1C30 CALL Z,$2996    ; The parameters of simple string variables and all
                       ; array variables are passed to the calculator stack.
                       ; (#R$2996 will 'slice' a string if required.)
 $1C33 BIT 6,(IY+$01)  ; {Jump forward if handling a numeric variable (bit 6 of
 $1C37 JR NZ,$1C46     ; #SYSVAR(FLAGS) set).}
 $1C39 XOR A           ; Clear the #REGa register.
 $1C3A CALL $2530      ; {The parameters of the string or string array variable
 $1C3D CALL NZ,$2BF1   ; are fetched unless syntax is being checked.}
 $1C40 LD HL,$5C71     ; This is #SYSVAR(FLAGX).
 $1C43 OR (HL)         ; {Bit 0 is set only when handling complete 'simple
 $1C44 LD (HL),A       ; strings' thereby signalling 'old copy to be deleted'.}
 $1C45 EX DE,HL        ; #REGhl now points to the string or the element of the
                       ; array.
; The pathways now come together to set #SYSVAR(STRLEN) and #SYSVAR(DEST) as
; required. For all numeric variables and 'new' string and string array
; variables #SYSVAR(STRLEN-lo) holds the 'letter' of the variable's name. But
; for 'old' string and string array variables whether 'sliced' or complete it
; holds the 'length' in 'assignment'.
@label=VAR_A_3
*$1C46 LD ($5C72),BC   ; Set #SYSVAR(STRLEN) as required.
; #SYSVAR(DEST) holds the address for the 'destination' of an 'old' variable
; but in effect the 'source' for a 'new' variable.
 $1C4A LD ($5C4D),HL   ; {Set #SYSVAR(DEST) as required and return.
 $1C4D RET             ; }

; THE 'COMMAND CLASS &02' ROUTINE
;
; The address of this routine is derived from an offset found in the
; #R$1C01(command class table).
; .
; Command class &02 is concerned with the actual calculation of the value to be
; assigned in a LET statement.
@refs=$1B28
@label=CLASS_02
c$1C4E POP BC        ; The address #R$1B52 is dropped.
 $1C4F CALL $1C56    ; The assignment is made.
 $1C52 CALL $1BEE    ; {Move on to the next statement either via #R$1BEE if
 $1C55 RET           ; checking syntax, or #R$1B76 if in 'run-time'.}

; THE 'FETCH A VALUE' SUBROUTINE
;
; Used by the routines at #R$1C4E and #R$1DEC.
; .
; This subroutine is used by LET, READ and INPUT statements to first evaluate
; and then assign values to the previously designated variable.
; .
; The main entry point is used by LET and READ and considers #SYSVAR(FLAGS),
; whereas the entry point #R$1C59 is used by INPUT and considers
; #SYSVAR(FLAGX).
@label=VAL_FET_1
c$1C56 LD A,($5C3B)  ; Use #SYSVAR(FLAGS).
; This entry point is used by the routine at #R$21B9 with #REGa holding the
; contents of #SYSVAR(FLAGX).
@label=VAL_FET_2
*$1C59 PUSH AF       ; Save #SYSVAR(FLAGS) or #SYSVAR(FLAGX).
 $1C5A CALL $24FB    ; Evaluate the next expression.
 $1C5D POP AF        ; Fetch the old #SYSVAR(FLAGS) or #SYSVAR(FLAGX).
 $1C5E LD D,(IY+$01) ; Fetch the new #SYSVAR(FLAGS).
 $1C61 XOR D         ; {The nature - numeric or string - of the variable and
 $1C62 AND $40       ; the expression must match.}
 $1C64 JR NZ,$1C8A   ; Give report C if they do not.
 $1C66 BIT 7,D       ; {Jump forward to make the actual assignment unless
 $1C68 JP NZ,$2AFF   ; checking syntax (in which case simply return).
 $1C6B RET           ; }

; THE 'COMMAND CLASS &04' ROUTINE
;
; The address of this routine is derived from an offset found in the
; #R$1C01(command class table).
; .
; The command class &04 entry point is used by FOR and NEXT statements.
@refs=$1B28
@label=CLASS_04
c$1C6C CALL $28B2    ; Look in the variables area for the variable being used.
 $1C6F PUSH AF       ; {Save the #REGaf register pair whilst the discriminator
 $1C70 LD A,C        ; byte is tested to ensure that the variable is a FOR-NEXT
 $1C71 OR $9F        ; control variable.
 $1C73 INC A         ;
 $1C74 JR NZ,$1C8A   ; }
 $1C76 POP AF        ; {Restore the flags register and jump to make the
 $1C77 JR $1C22      ; variable that has been found the 'variable in
                     ; assignment'.}

; THE 'EXPECT NUMERIC/STRING EXPRESSIONS' SUBROUTINE
;
; Used by the routines at #R$1FFC and #R$2522.
; .
; There is a series of short subroutines that are used to fetch the result of
; evaluating the next expression. The result from a single expression is
; returned as a 'last value' on the calculator stack.
;
; .
;
; This entry point is used when #SYSVAR(CH-ADD) needs updating to point to the
; start of the first expression.
@label=NEXT_2NUM
c$1C79 RST $20        ; Advance #SYSVAR(CH-ADD).
; This entry point is used by the routine at #R$1CBE.
; .
; The address of this entry point is derived from an offset found in the
; #R$1C01(command class table).
; .
; This entry point allows for two numeric expressions, separated by a comma, to
; be evaluated.
@refs=$1B28
@label=CLASS_08
*$1C7A CALL $1C82     ; Evaluate each expression in turn - so evaluate the
                      ; first.
 $1C7D CP ","         ; {Give an error report if the separator is not a comma.
 $1C7F JR NZ,$1C8A    ; }
 $1C81 RST $20        ; Advance #SYSVAR(CH-ADD).
; This entry point is used by the routines at #R$0605, #R$17F9, #R$1CDE,
; #R$1D03, #R$1FFC, #R$2070, #R$21E1, #R$2320, #R$2382 and #R$2ACC.
; .
; The address of this entry point is derived from an offset found in the
; #R$1C01(command class table).
; .
; This entry point allows for a single numeric expression to be evaluated.
@refs=$1B28
@label=CLASS_06
*$1C82 CALL $24FB     ; Evaluate the next expression.
 $1C85 BIT 6,(IY+$01) ; {Return as long as the result was numeric (bit 6 of
 $1C89 RET NZ         ; #SYSVAR(FLAGS) set); otherwise it is an error.}
; This entry point is used by the routines at #R$04AA, #R$0605, #R$19FB,
; #R$1B28, #R$1B6F, #R$1BF4, #R$1C56, #R$1C6C, #R$1F60, #R$2089, #R$21E1,
; #R$2320, #R$250F, #R$2522, #R$25E8, #R$26C9, #R$27BD, #R$28B2, #R$2A52,
; #R$2C02, #R$2C9B and #R$35DE.
; .
; Report C - Nonsense in BASIC.
@label=REPORT_C
*$1C8A RST $08        ; {Call the error handling routine.
 $1C8B DEFB $0B       ; }
; This entry point is used by the routine at #R$0605.
; .
; The address of this entry point is derived from an offset found in the
; #R$1C01(command class table).
; .
; This entry point allows for a single string expression to be evaluated.
@refs=$1B28
@label=CLASS_0A
*$1C8C CALL $24FB     ; Evaluate the next expression.
 $1C8F BIT 6,(IY+$01) ; {This time return if the result indicates a string (bit
 $1C93 RET Z          ; 6 of #SYSVAR(FLAGS) reset); otherwise give an error
 $1C94 JR $1C8A       ; report.}

; THE 'SET PERMANENT COLOURS' SUBROUTINE
;
; The address of this routine is derived from an offset found in the
; #R$1C01(command class table).
; .
; This subroutine allows for the current temporary colours to be made
; permanent. As command class &07 it is in effect the command routine for the
; six colour item commands.
@refs=$1B28
@label=CLASS_07
c$1C96 BIT 7,(IY+$01) ; The syntax/run flag (bit 7 of #SYSVAR(FLAGS)) is read.
 $1C9A RES 0,(IY+$02) ; Signal 'main screen' (reset bit 0 of #SYSVAR(TV-FLAG)).
 $1C9E CALL NZ,$0D4D  ; Only during a 'run' call #R$0D4D to ensure the
                      ; temporary colours are the main screen colours.
 $1CA1 POP AF         ; Drop the return address #R$1B52.
 $1CA2 LD A,($5C74)   ; {Fetch the low byte of #SYSVAR(T-ADDR) and subtract &13
 $1CA5 SUB $13        ; to give the range &D9 to &DE which are the token codes
                      ; for INK to OVER.}
 $1CA7 CALL $21FC     ; Change the temporary colours as directed by the BASIC
                      ; statement.
 $1CAA CALL $1BEE     ; Move on to the next statement if checking syntax.
 $1CAD LD HL,($5C8F)  ; {Now the temporary colour values (#SYSVAR(ATTR-T) and
 $1CB0 LD ($5C8D),HL  ; #SYSVAR(MASK-T)) are made permanent (#SYSVAR(ATTR-P)
                      ; and #SYSVAR(MASK-P)).}
 $1CB3 LD HL,$5C91    ; {This is #SYSVAR(P-FLAG), and that too has to be
 $1CB6 LD A,(HL)      ; considered.}
; The following instructions cleverly copy the even bits of the supplied byte
; to the odd bits, in effect making the permanent bits the same as the
; temporary ones.
 $1CB7 RLCA           ; Move the mask leftwards.
 $1CB8 XOR (HL)       ; {Impress onto the mask only the even bits of the other
 $1CB9 AND %10101010  ; byte.
 $1CBB XOR (HL)       ; }
 $1CBC LD (HL),A      ; Restore the result.
 $1CBD RET            ;

; THE 'COMMAND CLASS &09' ROUTINE
;
; The address of this routine is derived from an offset found in the
; #R$1C01(command class table).
; .
; This routine is used by PLOT, DRAW and CIRCLE statements in order to specify
; the default conditions of 'FLASH 8; BRIGHT 8; PAPER 8;' that are set up
; before any embedded colour items are considered.
@refs=$1B28
@label=CLASS_09
c$1CBE CALL $2530     ; {Jump forward if checking syntax.
 $1CC1 JR Z,$1CD6     ; }
 $1CC3 RES 0,(IY+$02) ; Signal 'main screen' (reset bit 0 of #SYSVAR(TV-FLAG)).
 $1CC7 CALL $0D4D     ; Set the temporary colours for the main screen.
 $1CCA LD HL,$5C90    ; This is #SYSVAR(MASK-T).
 $1CCD LD A,(HL)      ; {Fetch its present value but keep only its INK part
 $1CCE OR $F8         ; 'unmasked'.}
 $1CD0 LD (HL),A      ; Restore the value which now indicates 'FLASH 8; BRIGHT
                      ; 8; PAPER 8;'.
 $1CD1 RES 6,(IY+$57) ; Also ensure NOT 'PAPER 9' (reset bit 6 of
                      ; #SYSVAR(P-FLAG)).
 $1CD5 RST $18        ; Fetch the present character before continuing to deal
                      ; with embedded colour items.
@label=CL_09_1
*$1CD6 CALL $21E2     ; Deal with the locally dominant colour items.
 $1CD9 JR $1C7A       ; Now get the first two operands for PLOT, DRAW or
                      ; CIRCLE.

; THE 'COMMAND CLASS &0B' ROUTINE
;
; The address of this routine is derived from an offset found in the
; #R$1C01(command class table).
; .
; This routine is used by SAVE, LOAD, VERIFY and MERGE statements.
@refs=$1B28
@label=CLASS_0B
c$1CDB JP $0605      ; Jump to the cassette handling routine.

; THE 'FETCH A NUMBER' SUBROUTINE
;
; Used by the routines at #R$17F9 and #R$1C0D.
; .
; This subroutine leads to a following numeric expression being evaluated but
; zero being used instead if there is no expression.
;
; A Code of the first character of the expression
@label=FETCH_NUM
c$1CDE CP $0D        ; {Jump forward if at the end of a line.
 $1CE0 JR Z,$1CE6    ; }
 $1CE2 CP ":"        ; {But jump to #R$1C82 unless at the end of a statement.
 $1CE4 JR NZ,$1C82   ; }
; This entry point is used by the routines at #R$0605 and #R$17F9.
; .
; The calculator is now used to add the value zero to the calculator stack.
@label=USE_ZERO
*$1CE6 CALL $2530    ; {Do not perform the operation if syntax is being
 $1CE9 RET Z         ; checked.}
 $1CEA RST $28       ; Use the calculator.
 $1CEB DEFB $A0      ; #R$341B(stk_zero)
 $1CEC DEFB $38      ; #R$369B
 $1CED RET           ; Return with zero added to the stack.

; THE 'STOP' COMMAND ROUTINE
;
; The address of this routine is found in the #R$1A8A(parameter table).
; .
; The command routine for STOP contains only a call to the error handling
; routine.
@refs=$1C0D
@label=STOP
c$1CEE RST $08       ; {Call the error handling routine.
 $1CEF DEFB $08      ; }

; THE 'IF' COMMAND ROUTINE
;
; The address of this routine is found in the #R$1A81(parameter table).
; .
; On entry the value of the expression between the IF and the THEN is the 'last
; value' on the calculator stack. If this is logically true then the next
; statement is considered; otherwise the line is considered to have been
; finished.
@refs=$1C0D
@label=IF_CMD
c$1CF0 POP BC        ; Drop the return address - #R$1B76.
 $1CF1 CALL $2530    ; {Jump forward if checking syntax.
 $1CF4 JR Z,$1D00    ; }
; Now use the calculator to 'delete' the last value on the calculator stack but
; leave the #REGde register pair addressing the first byte of the value.
 $1CF6 RST $28       ; Use the calculator.
 $1CF7 DEFB $02      ; #R$33A1
 $1CF8 DEFB $38      ; #R$369B
 $1CF9 EX DE,HL      ; {Make #REGhl point to the first byte and call #R$34E9.
 $1CFA CALL $34E9    ; }
 $1CFD JP C,$1BB3    ; If the value was 'FALSE' jump to the next line.
@label=IF_1
*$1D00 JP $1B29      ; But if 'TRUE' jump to the next statement (after the
                     ; THEN).

; THE 'FOR' COMMAND ROUTINE
;
; The address of this routine is found in the #R$1A90(parameter table).
; .
; This command routine is entered with the VALUE and the LIMIT of the FOR
; statement already on the top of the calculator stack.
;
; A Code of the next character in the statement
@refs=$1C0D
@label=FOR
c$1D03 CP $CD        ; {Jump forward unless a 'STEP' is given.
 $1D05 JR NZ,$1D10   ; }
 $1D07 RST $20       ; {Advance #SYSVAR(CH-ADD) and fetch the value of the
 $1D08 CALL $1C82    ; STEP.}
 $1D0B CALL $1BEE    ; {Move on to the next statement if checking syntax;
 $1D0E JR $1D16      ; otherwise jump forward.}
; There has not been a STEP supplied so the value '1' is to be used.
@label=F_USE_1
*$1D10 CALL $1BEE    ; Move on to the next statement if checking syntax.
 $1D13 RST $28       ; Otherwise use the calculator to place a '1' on the
                     ; calculator stack.
 $1D14 DEFB $A1      ; #R$341B(stk_one)
 $1D15 DEFB $38      ; #R$369B
; The three values on the calculator stack are the VALUE (v), the LIMIT (l) and
; the STEP (s). These values now have to be manipulated.
@label=F_REORDER
*$1D16 RST $28       ; v, l, s
 $1D17 DEFB $C0      ; #R$342D(st_mem_0): v, l, s (mem-0=s)
 $1D18 DEFB $02      ; #R$33A1: v, l
 $1D19 DEFB $01      ; #R$343C: l, v
 $1D1A DEFB $E0      ; #R$340F(get_mem_0): l, v, s
 $1D1B DEFB $01      ; #R$343C: l, s, v
 $1D1C DEFB $38      ; #R$369B
; A FOR control variable is now established and treated as a temporary
; calculator memory area.
 $1D1D CALL $2AFF    ; The variable is found, or created if needed (v is used).
 $1D20 LD ($5C68),HL ; Make it a 'memory area' by setting #SYSVAR(MEM).
; The variable that has been found may be a simple numeric variable using only
; six locations in which case it will need extending.
 $1D23 DEC HL        ; {Fetch the variable's single character name.
 $1D24 LD A,(HL)     ; }
 $1D25 SET 7,(HL)    ; Ensure bit 7 of the name is set.
@keep
 $1D27 LD BC,$0006   ; It will have six locations at least.
 $1D2A ADD HL,BC     ; Make #REGhl point after them.
 $1D2B RLCA          ; {Rotate the name and jump if it was already a FOR
 $1D2C JR C,$1D34    ; variable.}
 $1D2E LD C,$0D      ; {Otherwise create thirteen more locations.
 $1D30 CALL $1655    ; }
 $1D33 INC HL        ; Again make #REGhl point to the LIMIT position.
; The initial values for the LIMIT and the STEP are now added.
@label=F_L_S
*$1D34 PUSH HL       ; The pointer is saved.
 $1D35 RST $28       ; l, s
 $1D36 DEFB $02      ; #R$33A1: l
 $1D37 DEFB $02      ; #R$33A1: -
 $1D38 DEFB $38      ; #R$369B: #REGde still points to 'l'
 $1D39 POP HL        ; {The pointer is restored and both pointers exchanged.
 $1D3A EX DE,HL      ; }
 $1D3B LD C,$0A      ; {The ten bytes of the LIMIT and the STEP are moved.
 $1D3D LDIR          ; }
; The looping line number and statement number are now entered.
 $1D3F LD HL,($5C45) ; The current line number (#SYSVAR(PPC)).
 $1D42 EX DE,HL      ; {Exchange the registers before adding the line number to
 $1D43 LD (HL),E     ; the FOR control variable.
 $1D44 INC HL        ;
 $1D45 LD (HL),D     ; }
 $1D46 LD D,(IY+$0D) ; {The looping statement is always the next statement
 $1D49 INC D         ; whether it exists or not (increment #SYSVAR(SUBPPC)).
 $1D4A INC HL        ;
 $1D4B LD (HL),D     ; }
; The #R$1DDA subroutine is called to test the possibility of a 'pass' and a
; return is made if one is possible; otherwise the statement after for FOR -
; NEXT loop has to be identified.
 $1D4C CALL $1DDA    ; Is a 'pass' possible?
 $1D4F RET NC        ; Return now if it is.
 $1D50 LD B,(IY+$38) ; Fetch the variable's name from #SYSVAR(STRLEN).
 $1D53 LD HL,($5C45) ; {Copy the present line number (#SYSVAR(PPC)) to
 $1D56 LD ($5C42),HL ; #SYSVAR(NEWPPC).}
 $1D59 LD A,($5C47)  ; {Fetch the current statement number (#SYSVAR(SUBPPC))
 $1D5C NEG           ; and two's complement it.}
 $1D5E LD D,A        ; Transfer the result to the #REGd register.
 $1D5F LD HL,($5C5D) ; Fetch the current value of #SYSVAR(CH-ADD).
 $1D62 LD E,$F3      ; The search will be for 'NEXT'.
; Now a search is made in the program area, from the present point onwards, for
; the first occurrence of NEXT followed by the correct variable.
@label=F_LOOP
*$1D64 PUSH BC       ; Save the variable's name.
 $1D65 LD BC,($5C55) ; Fetch the current value of #SYSVAR(NXTLIN).
 $1D69 CALL $1D86    ; The program area is now searched and #REGbc will change
                     ; with each new line examined.
 $1D6C LD ($5C55),BC ; Upon return save the pointer at #SYSVAR(NXTLIN).
 $1D70 POP BC        ; Restore the variable's name.
 $1D71 JR C,$1D84    ; If there are no further NEXTs then give an error.
 $1D73 RST $20       ; Advance past the NEXT that was found.
 $1D74 OR $20        ; {Allow for upper and lower case letters before the new
 $1D76 CP B          ; variable name is tested.}
 $1D77 JR Z,$1D7C    ; Jump forward if it matches.
 $1D79 RST $20       ; {Advance #SYSVAR(CH-ADD) again and jump back if not the
 $1D7A JR $1D64      ; correct variable.}
; #SYSVAR(NEWPPC) holds the line number of the line in which the correct NEXT
; was found. Now the statement number has to be found and stored in
; #SYSVAR(NSPPC).
@label=F_FOUND
*$1D7C RST $20       ; Advance #SYSVAR(CH-ADD).
 $1D7D LD A,$01      ; {The statement counter in the #REGd register counted
 $1D7F SUB D         ; statements back from zero so it has to be subtracted
                     ; from '1'.}
 $1D80 LD ($5C44),A  ; The result is stored in #SYSVAR(NSPPC).
 $1D83 RET           ; Now return - to #R$1B76.
; Report I - FOR without NEXT.
@label=REPORT_I
*$1D84 RST $08       ; {Call the error handling routine.
 $1D85 DEFB $11      ; }

; THE 'LOOK-PROG' SUBROUTINE
;
; Used by the routines at #R$1D03, #R$1DEC and #R$27BD.
; .
; This subroutine is used to find occurrences of either DATA, DEF FN or NEXT.
;
;   E Token code to search for
;   HL Search start address
; O:F Carry flag reset if the token is found
@label=LOOK_PROG
c$1D86 LD A,(HL)     ; Fetch the present character.
 $1D87 CP ":"        ; {Jump forward if it is a ':', which will indicate there
 $1D89 JR Z,$1DA3    ; are more statements in the present line.}
; Now a loop is entered to examine each further line in the program.
@label=LOOK_P_1
*$1D8B INC HL        ; {Fetch the high byte of the line number and return with
 $1D8C LD A,(HL)     ; carry set if there are no further lines in the program.
 $1D8D AND $C0       ;
 $1D8F SCF           ;
 $1D90 RET NZ        ; }
 $1D91 LD B,(HL)     ; {The line number is fetched and passed to
 $1D92 INC HL        ; #SYSVAR(NEWPPC).
 $1D93 LD C,(HL)     ;
 $1D94 LD ($5C42),BC ; }
 $1D98 INC HL        ; {Then the length is collected.
 $1D99 LD C,(HL)     ;
 $1D9A INC HL        ;
 $1D9B LD B,(HL)     ; }
 $1D9C PUSH HL       ; {The pointer is saved whilst the address of the end of
 $1D9D ADD HL,BC     ; the line is formed in the #REGbc register pair.
 $1D9E LD B,H        ;
 $1D9F LD C,L        ; }
 $1DA0 POP HL        ; The pointer is restored.
 $1DA1 LD D,$00      ; Set the statement counter to zero.
@label=LOOK_P_2
*$1DA3 PUSH BC       ; {The end-of-line pointer is saved whilst the statements
 $1DA4 CALL $198B    ; of the line are examined.
 $1DA7 POP BC        ; }
 $1DA8 RET NC        ; {Make a return if there was an 'occurrence'; otherwise
 $1DA9 JR $1D8B      ; consider the next line.}

; THE 'NEXT' COMMAND ROUTINE
;
; The address of this routine is found in the #R$1A98(parameter table).
; .
; The 'variable in assignment' has already been determined (see #R$1C6C), and
; it remains to change the VALUE as required.
@refs=$1C0D
@label=NEXT
c$1DAB BIT 1,(IY+$37) ; {Jump to give the error report if the variable was not
 $1DAF JP NZ,$1C2E    ; found (bit 1 of #SYSVAR(FLAGX) set).}
 $1DB2 LD HL,($5C4D)  ; {The address of the variable is fetched from
 $1DB5 BIT 7,(HL)     ; #SYSVAR(DEST) and the name tested further.
 $1DB7 JR Z,$1DD8     ; }
; Next the variable's VALUE (v) and STEP (s) are manipulated by the calculator.
 $1DB9 INC HL         ; Step past the name.
 $1DBA LD ($5C68),HL  ; Make the variable a temporary 'memory area' by setting
                      ; #SYSVAR(MEM).
 $1DBD RST $28        ; -
 $1DBE DEFB $E0       ; #R$340F(get_mem_0): v
 $1DBF DEFB $E2       ; #R$340F(get_mem_2): v, s
 $1DC0 DEFB $0F       ; #R$3014: v+s
 $1DC1 DEFB $C0       ; #R$342D(st_mem_0): v+s (v is replaced by v+s in mem-0)
 $1DC2 DEFB $02       ; #R$33A1: -
 $1DC3 DEFB $38       ; #R$369B: -
; The result of adding the VALUE and the STEP is now tested against the LIMIT
; by calling #R$1DDA.
 $1DC4 CALL $1DDA     ; Test the new VALUE against the LIMIT.
 $1DC7 RET C          ; Return now if the FOR-NEXT loop has been completed.
; Otherwise collect the 'looping' line number and statement.
 $1DC8 LD HL,($5C68)  ; {Find the address of the low byte of the looping line
@keep
 $1DCB LD DE,$000F    ; number (#SYSVAR(MEM)+#h0F).
 $1DCE ADD HL,DE      ; }
 $1DCF LD E,(HL)      ; {Now fetch this line number.
 $1DD0 INC HL         ;
 $1DD1 LD D,(HL)      ;
 $1DD2 INC HL         ; }
 $1DD3 LD H,(HL)      ; Followed by the statement number.
 $1DD4 EX DE,HL       ; {Exchange the numbers before jumping forward to treat
 $1DD5 JP $1E73       ; them as the destination line of a GO TO command.}
; Report 1 - NEXT without FOR.
@label=REPORT_1
*$1DD8 RST $08        ; {Call the error handling routine.
 $1DD9 DEFB $00       ; }

; THE 'NEXT-LOOP' SUBROUTINE
;
; Used by the routines at #R$1D03 and #R$1DAB.
; .
; This subroutine is used to determine whether the LIMIT (l) has been exceeded
; by the present VALUE (v). Note has to be taken of the sign of the STEP (s).
; .
; The subroutine returns the carry flag set if the LIMIT is exceeded.
@label=NEXT_LOOP
c$1DDA RST $28       ; -
 $1DDB DEFB $E1      ; #R$340F(get_mem_1): l
 $1DDC DEFB $E0      ; #R$340F(get_mem_0): l, v
 $1DDD DEFB $E2      ; #R$340F(get_mem_2): l, v, s
 $1DDE DEFB $36      ; #R$3506: l, v,( 1/0)
 $1DDF DEFB $00      ; {#R$368F to #R$1DE2: l, v, (1/0)
 $1DE0 DEFB $02      ; }
 $1DE1 DEFB $01      ; #R$343C: v, l
@label=NEXT_1
 $1DE2 DEFB $03      ; #R$300F: v-l or l-v
 $1DE3 DEFB $37      ; #R$34F9: (1/0)
 $1DE4 DEFB $00      ; {#R$368F to #R$1DE9: (1/0)
 $1DE5 DEFB $04      ; }
 $1DE6 DEFB $38      ; #R$369B: -
 $1DE7 AND A         ; {Clear the carry flag and return - loop is possible.
 $1DE8 RET           ; }
; However if the loop is impossible the carry flag has to be set.
@label=NEXT_2
 $1DE9 DEFB $38      ; #R$369B: -
 $1DEA SCF           ; {Set the carry flag and return.
 $1DEB RET           ; }

; THE 'READ' COMMAND ROUTINE
;
; The READ command allows for the reading of a DATA list and has an effect
; similar to a series of LET statements.
; .
; Each assignment within a single READ statement is dealt with in turn. The
; system variable #SYSVAR(X-PTR) is used as a storage location for the pointer
; to the READ statement whilst #SYSVAR(CH-ADD) is used to step along the DATA
; list.
@label=READ_3
c$1DEC RST $20         ; Come here on each pass, after the first, to move along
                       ; the READ statement.
; The address of this entry point is found in the #R$1AC9(parameter table).
@refs=$1C0D
@label=READ
*$1DED CALL $1C1F      ; Consider whether the variable has been used before;
                       ; find the existing entry if it has.
 $1DF0 CALL $2530      ; {Jump forward if checking syntax.
 $1DF3 JR Z,$1E1E      ; }
 $1DF5 RST $18         ; {Save the current pointer #SYSVAR(CH-ADD) in
 $1DF6 LD ($5C5F),HL   ; #SYSVAR(X-PTR).}
 $1DF9 LD HL,($5C57)   ; {Fetch the current DATA list pointer (#SYSVAR(DATADD))
 $1DFC LD A,(HL)       ; and jump forward unless a new DATA statement has to be
 $1DFD CP ","          ; found.
 $1DFF JR Z,$1E0A      ; }
 $1E01 LD E,$E4        ; The search is for 'DATA'.
 $1E03 CALL $1D86      ; {Jump forward if the search is successful.
 $1E06 JR NC,$1E0A     ; }
; Report E - Out of DATA.
 $1E08 RST $08         ; {Call the error handling routine.
 $1E09 DEFB $0D        ; }
; Continue - picking up a value from the DATA list.
@label=READ_1
*$1E0A CALL $0077      ; Advance the pointer along the DATA list and set
                       ; #SYSVAR(CH-ADD).
 $1E0D CALL $1C56      ; Fetch the value and assign it to the variable.
 $1E10 RST $18         ; {Fetch the current value of #SYSVAR(CH-ADD) and store
 $1E11 LD ($5C57),HL   ; it in #SYSVAR(DATADD).}
 $1E14 LD HL,($5C5F)   ; {Fetch the pointer to the READ statement from
 $1E17 LD (IY+$26),$00 ; #SYSVAR(X-PTR) and clear it.}
 $1E1B CALL $0078      ; Make #SYSVAR(CH-ADD) once again point to the READ
                       ; statement.
@label=READ_2
*$1E1E RST $18         ; {Get the present character and see if it is a ','.
 $1E1F CP ","          ; }
 $1E21 JR Z,$1DEC      ; {If it is then jump back as there are further items;
 $1E23 CALL $1BEE      ; otherwise return via either #R$1BEE (if checking
 $1E26 RET             ; syntax) or the '#S/RET/' instruction (to #R$1B76).}

; THE 'DATA' COMMAND ROUTINE
;
; The address of this routine is found in the #R$1ACC(parameter table).
; .
; During syntax checking a DATA statement is checked to ensure that it contains
; a series of valid expressions, separated by commas. But in 'run-time' the
; statement is passed by.
@refs=$1C0D
@label=DATA
c$1E27 CALL $2530    ; {Jump forward unless checking syntax.
 $1E2A JR NZ,$1E37   ; }
; A loop is now entered to deal with each expression in the DATA statement.
@label=DATA_1
*$1E2C CALL $24FB    ; Scan the next expression.
 $1E2F CP ","        ; Check for a comma separator.
 $1E31 CALL NZ,$1BEE ; Move on to the next statement if not matched.
 $1E34 RST $20       ; {Whilst there are still expressions to be checked go
 $1E35 JR $1E2C      ; around the loop.}
; The DATA statement has to be passed by in 'run-time'.
@label=DATA_2
*$1E37 LD A,$E4      ; It is a 'DATA' statement that is to be passed by.
; This routine continues into #R$1E39.

; THE 'PASS-BY' SUBROUTINE
;
; Used by the routine at #R$1F60.
; .
; The routine at #R$1E27 continues here.
; .
; On entry the #REGa register will hold either the token 'DATA' or the token
; 'DEF FN' depending on the type of statement that is being passed by.
;
; A &CE (DEF FN) or &E4 (DATA)
@label=PASS_BY
c$1E39 LD B,A        ; Make the #REGbc register pair hold a very high number.
 $1E3A CPDR          ; Look back along the statement for the token.
@keep
 $1E3C LD DE,$0200   ; {Now look along the line for the statement after (the
 $1E3F JP $198B      ; '#REGd-1'th statement from the current position).}

; THE 'RESTORE' COMMAND ROUTINE
;
; The address of this routine is found in the #R$1ACF(parameter table).
; .
; The operand for a RESTORE command is taken as a line number, zero being used
; if no operand is given.
@refs=$1C0D
@label=RESTORE
c$1E42 CALL $1E99    ; Compress the operand into the #REGbc register pair.
; This entry point is used by the routine at #R$1EA1.
@label=REST_RUN
*$1E45 LD H,B        ; {Transfer the result to the #REGhl register pair.
 $1E46 LD L,C        ; }
 $1E47 CALL $196E    ; Now find the address of that line or the 'first line
                     ; after'.
 $1E4A DEC HL        ; {Make #SYSVAR(DATADD) point to the location before.
 $1E4B LD ($5C57),HL ; }
 $1E4E RET           ; Return once it is done.

; THE 'RANDOMIZE' COMMAND ROUTINE
;
; The address of this routine is found in the #R$1AB5(parameter table).
; .
; The operand is compressed into the #REGbc register pair and transferred to
; the required system variable. However if the operand is zero the value in
; #R$5C78(FRAMES1 and FRAMES2) is used instead.
@refs=$1C0D
@label=RANDOMIZE
c$1E4F CALL $1E99    ; Fetch the operand.
 $1E52 LD A,B        ; {Jump forward unless the value of the operand is zero.
 $1E53 OR C          ;
 $1E54 JR NZ,$1E5A   ; }
 $1E56 LD BC,($5C78) ; Fetch the two low order bytes of #SYSVAR(FRAMES)
                     ; instead.
@label=RAND_1
*$1E5A LD ($5C76),BC ; {Now enter the result into the system variable
 $1E5E RET           ; #SYSVAR(SEED) before returning.}

; THE 'CONTINUE' COMMAND ROUTINE
;
; The address of this routine is found in the #R$1AB8(parameter table).
; .
; The required line number and statement number within that line are made the
; object of a jump.
@refs=$1C0D
@label=CONTINUE
c$1E5F LD HL,($5C6E) ; The line number (#SYSVAR(OLDPPC)).
 $1E62 LD D,(IY+$36) ; The statement number (#SYSVAR(OSPCC)).
 $1E65 JR $1E73      ; Jump forward.

; THE 'GO TO' COMMAND ROUTINE
;
; Used by the routines at #R$1EA1 and #R$1EED.
; .
; The address of this routine is found in the #R$1A7D(parameter table).
; .
; The operand of a GO TO ought to be a line number in the range 1-9999 but the
; actual test is against an upper value of 61439.
@refs=$1C0D
@label=GO_TO
c$1E67 CALL $1E99    ; {Fetch the operand and transfer it to the #REGhl
 $1E6A LD H,B        ; register pair.
 $1E6B LD L,C        ; }
 $1E6C LD D,$00      ; Set the statement number to zero.
 $1E6E LD A,H        ; {Give the error message 'Integer out of range' with line
 $1E6F CP $F0        ; numbers over 61439.
 $1E71 JR NC,$1E9F   ; }
; This entry point is used by the routines at #R$1DAB, #R$1E5F and #R$1F23 to
; determine the line number of the next line to be handled.
@label=GO_TO_2
*$1E73 LD ($5C42),HL ; {Enter the line number (#SYSVAR(NEWPPC)) and then the
 $1E76 LD (IY+$0A),D ; statement number (#SYSVAR(NSPPC)).}
 $1E79 RET           ; Return - to #R$1B76.

; THE 'OUT' COMMAND ROUTINE
;
; The address of this routine is found in the #R$1AF1(parameter table).
; .
; The two parameters for the '#S/OUT/' instruction are fetched from the
; calculator stack and used as directed.
@refs=$1C0D
@label=OUT_CMD
c$1E7A CALL $1E85    ; The operands are fetched.
 $1E7D OUT (C),A     ; The actual '#S/OUT/' instruction.
 $1E7F RET           ; Return - to #R$1B76.

; THE 'POKE' COMMAND ROUTINE
;
; The address of this routine is found in the #R$1AB1(parameter table).
; .
; In a similar manner to #R$1E7A(OUT), the POKE operation is performed.
@refs=$1C0D
@label=POKE
c$1E80 CALL $1E85    ; The operands are fetched.
 $1E83 LD (BC),A     ; The actual POKE operation.
 $1E84 RET           ; Return - to #R$1B76.

; THE 'TWO-PARAM' SUBROUTINE
;
; Used by the routines at #R$1E7A and #R$1E80.
; .
; The topmost parameter on the calculator stack must be compressible into a
; single register. It is two's complemented if it is negative. The second
; parameter must be compressible into a register pair.
@label=TWO_PARAM
c$1E85 CALL $2DD5    ; The parameter is fetched.
 $1E88 JR C,$1E9F    ; Give an error if it is too high a number.
 $1E8A JR Z,$1E8E    ; {Jump forward with positive numbers but two's complement
 $1E8C NEG           ; negative numbers.}
@label=TWO_P_1
*$1E8E PUSH AF       ; {Save the first parameter whilst the second is fetched.
 $1E8F CALL $1E99    ; }
 $1E92 POP AF        ; {The first parameter is restored before returning.
 $1E93 RET           ; }

; THE 'FIND INTEGERS' SUBROUTINE
;
; Used by the routines at #R$03F8, #R$171E, #R$2070, #R$21E1, #R$2294, #R$2320
; and #R$3645.
; .
; The 'last value' on the calculator stack is fetched and compressed into a
; single register or a register pair by entering at #R$1E94 and #R$1E99
; respectively.
@label=FIND_INT1
c$1E94 CALL $2DD5    ; Fetch the 'last value'.
 $1E97 JR $1E9C      ; Jump forward.
; This entry point is used by the routines at #R$03F8, #R$0605, #R$17F9,
; #R$1E42, #R$1E4F, #R$1E67, #R$1E85, #R$1EAC, #R$1F3A, #R$1FFC, #R$2ACC,
; #R$34A5, #R$34AC and #R$34B3.
@label=FIND_INT2
*$1E99 CALL $2DA2    ; Fetch the 'last value'.
@label=FIND_I_1
*$1E9C JR C,$1E9F    ; In both cases overflow is indicated by a set carry flag.
 $1E9E RET Z         ; Return with all positive numbers that are in range.
; This entry point is used by the routines at #R$0A6D, #R$1E67, #R$1E85 and
; #R$3645.
; .
; Report B - Integer out of range.
@label=REPORT_B_2
*$1E9F RST $08       ; {Call the error handling routine.
 $1EA0 DEFB $0A      ; }

; THE 'RUN' COMMAND ROUTINE
;
; The address of this routine is found in the #R$1AAB(parameter table).
; .
; The parameter of the RUN command is passed to #SYSVAR(NEWPPC) by calling
; #R$1E67. The operations of 'RESTORE 0' and 'CLEAR 0' are then performed
; before a return is made.
@refs=$1C0D
@label=RUN
c$1EA1 CALL $1E67    ; Set #SYSVAR(NEWPPC) as required.
@keep
 $1EA4 LD BC,$0000   ; {Now perform a 'RESTORE 0'.
 $1EA7 CALL $1E45    ; }
 $1EAA JR $1EAF      ; Exit via the #R$1EAC command routine.

; THE 'CLEAR' COMMAND ROUTINE
;
; The address of this routine is found in the #R$1ABB(parameter table).
; .
; This routine allows for the variables area to be cleared, the display area
; cleared and #SYSVAR(RAMTOP) moved. In consequence of the last operation the
; machine stack is rebuilt thereby having the effect of also clearing the GO
; SUB stack.
@refs=$1C0D
@label=CLEAR
c$1EAC CALL $1E99    ; Fetch the operand - using zero by default.
; This entry point is used by the routine at #R$1EA1.
@label=CLEAR_RUN
*$1EAF LD A,B        ; {Jump forward if the operand is other than zero. When
 $1EB0 OR C          ; called from #R$1EA1 there is no jump.
 $1EB1 JR NZ,$1EB7   ; }
 $1EB3 LD BC,($5CB2) ; If zero use the existing value in #SYSVAR(RAMTOP).
@label=CLEAR_1
*$1EB7 PUSH BC       ; Save the value.
 $1EB8 LD DE,($5C4B) ; {Next reclaim all the bytes of the present variables
 $1EBC LD HL,($5C59) ; area (#SYSVAR(VARS) to #SYSVAR(E-LINE)-1).
 $1EBF DEC HL        ;
 $1EC0 CALL $19E5    ; }
 $1EC3 CALL $0D6B    ; Clear the display area.
; The value in the #REGbc register pair which will be used as #SYSVAR(RAMTOP)
; is tested to ensure it is neither too low nor too high.
 $1EC6 LD HL,($5C65) ; {The current value of #SYSVAR(STKEND) is increased by 50
@keep
 $1EC9 LD DE,$0032   ; before being tested. This forms the lower limit.
 $1ECC ADD HL,DE     ;
 $1ECD POP DE        ;
 $1ECE SBC HL,DE     ; }
 $1ED0 JR NC,$1EDA   ; #SYSVAR(RAMTOP) will be too low.
 $1ED2 LD HL,($5CB4) ; {For the upper test the value for #SYSVAR(RAMTOP) is
 $1ED5 AND A         ; tested against #SYSVAR(P-RAMT).
 $1ED6 SBC HL,DE     ; }
 $1ED8 JR NC,$1EDC   ; Jump forward if acceptable.
; Report M - RAMTOP no good.
@label=REPORT_M
*$1EDA RST $08       ; {Call the error handling routine.
 $1EDB DEFB $15      ; }
; Continue with the CLEAR operation.
@label=CLEAR_2
*$1EDC EX DE,HL      ; {Now the value can actually be passed to
 $1EDD LD ($5CB2),HL ; #SYSVAR(RAMTOP).}
 $1EE0 POP DE        ; Fetch the address of #R$1B76.
 $1EE1 POP BC        ; Fetch the 'error address'.
 $1EE2 LD (HL),$3E   ; Enter a GO SUB stack end marker.
 $1EE4 DEC HL        ; Leave one location.
 $1EE5 LD SP,HL      ; Make the stack pointer point to an empty GO SUB stack.
 $1EE6 PUSH BC       ; {Next pass the 'error address' to the stack and save its
 $1EE7 LD ($5C3D),SP ; address in #SYSVAR(ERR-SP).}
 $1EEB EX DE,HL      ; {An indirect return is now made to #R$1B76.
 $1EEC JP (HL)       ; }
; Note: when the routine is called from #R$1EA1 the values of #SYSVAR(NEWPPC)
; and #SYSVAR(NSPPC) will have been affected and no statements coming after RUN
; can ever be found before the jump is taken.

; THE 'GO SUB' COMMAND ROUTINE
;
; The address of this routine is found in the #R$1A86(parameter table).
; .
; The present value of #SYSVAR(PPC) and the incremented value of
; #SYSVAR(SUBPPC) are stored on the GO SUB stack.
@refs=$1C0D
@label=GO_SUB
c$1EED POP DE        ; Save the address - #R$1B76.
 $1EEE LD H,(IY+$0D) ; {Fetch the statement number (#SYSVAR(SUBPPC)) and
 $1EF1 INC H         ; increment it.}
 $1EF2 EX (SP),HL    ; Exchange the 'error address' with the statement number.
 $1EF3 INC SP        ; Reclaim the use of a location.
 $1EF4 LD BC,($5C45) ; {Next save the present line number (#SYSVAR(PPC)).
 $1EF8 PUSH BC       ; }
 $1EF9 PUSH HL       ; {Return the 'error address' to the machine stack and
 $1EFA LD ($5C3D),SP ; reset #SYSVAR(ERR-SP) to point to it.}
 $1EFE PUSH DE       ; Return the address #R$1B76.
 $1EFF CALL $1E67    ; Now set #SYSVAR(NEWPPC) and #SYSVAR(NSPPC) to the
                     ; required values.
@keep
 $1F02 LD BC,$0014   ; But before making the jump make a test for room.
; This routine continues into #R$1F05.

; THE 'TEST-ROOM' SUBROUTINE
;
; Used by the routines at #R$0808, #R$0FA9, #R$1652, #R$1F1A and #R$33A9.
; .
; The routine at #R$1EED continues here.
; .
; A series of tests is performed to ensure that there is sufficient free memory
; available for the task being undertaken.
;
;   BC Size of the required space
; O:HL #SYSVAR(STKEND)+#REGbc+80-#REGsp
@label=TEST_ROOM
c$1F05 LD HL,($5C65) ; {Increase the value taken from #SYSVAR(STKEND) by the
 $1F08 ADD HL,BC     ; value carried into the routine by the #REGbc register
                     ; pair.}
 $1F09 JR C,$1F15    ; Jump forward if the result is over &FFFF.
 $1F0B EX DE,HL      ; {Try it again allowing for a further eighty bytes.
@keep
 $1F0C LD HL,$0050   ;
 $1F0F ADD HL,DE     ;
 $1F10 JR C,$1F15    ; }
 $1F12 SBC HL,SP     ; Finally test the value against the address of the
                     ; machine stack.
 $1F14 RET C         ; Return if satisfactory.
; This entry point is used by the routines at #R$2AF4 and #R$2C02.
; .
; Report 4 - Out of memory.
@label=REPORT_4
*$1F15 LD L,$03      ; {This is a 'run-time' error and the error marker is not
 $1F17 JP $0055      ; to be used.}

; THE 'FREE MEMORY' SUBROUTINE
;
@ignoreua
; There is no BASIC command 'FRE' in the Spectrum but there is a subroutine for
; performing such a task.
; .
; An estimate of the amount of free space can be found at any time by using
; 'PRINT 65536-USR 7962'.
;
; O:BC #SYSVAR(STKEND)+80-#REGsp (free space * -1)
@label=FREE_MEM
@keep
u$1F1A LD BC,$0000   ; Do not allow any overhead.
 $1F1D CALL $1F05    ; {Make the test and pass the result to the #REGbc
 $1F20 LD B,H        ; register before returning.
 $1F21 LD C,L        ;
 $1F22 RET           ; }

; THE 'RETURN' COMMAND ROUTINE
;
; The address of this routine is found in the #R$1A8D(parameter table).
; .
; The line number and the statement number that are to be made the object of a
; 'return' are fetched from the GO SUB stack.
@refs=$1C0D
@label=RETURN
c$1F23 POP BC        ; Fetch the address - #R$1B76.
 $1F24 POP HL        ; Fetch the 'error address'.
 $1F25 POP DE        ; Fetch the last entry on the GO SUB stack.
 $1F26 LD A,D        ; {The entry is tested to see if it is the GO SUB stack
 $1F27 CP $3E        ; end marker.}
 $1F29 JR Z,$1F36    ; Jump if it is.
 $1F2B DEC SP        ; The full entry uses three locations only.
 $1F2C EX (SP),HL    ; Exchange the statement number with the 'error address'.
 $1F2D EX DE,HL      ; Move the statement number.
 $1F2E LD ($5C3D),SP ; Reset the error pointer (#SYSVAR(ERR-SP)).
 $1F32 PUSH BC       ; Replace the address #R$1B76.
 $1F33 JP $1E73      ; Jump back to change #SYSVAR(NEWPPC) and #SYSVAR(NSPPC).
; Report 7 - RETURN without GOSUB.
@label=REPORT_7
*$1F36 PUSH DE       ; {Replace the end marker and the 'error address'.
 $1F37 PUSH HL       ; }
 $1F38 RST $08       ; {Call the error handling routine.
 $1F39 DEFB $06      ; }

; THE 'PAUSE' COMMAND ROUTINE
;
; The address of this routine is found in the #R$1AC5(parameter table).
; .
; The period of the pause is determined by counting the number of maskable
; interrupts as they occur every 1/50th of a second.
; .
; A pause is finished either after the appropriate number of interrupts or by
; the system variable #SYSVAR(FLAGS) indicating that a key has been pressed.
@refs=$1C0D
@label=PAUSE
c$1F3A CALL $1E99     ; Fetch the operand.
@label=PAUSE_1
*$1F3D HALT           ; Wait for a maskable interrupt.
 $1F3E DEC BC         ; Decrease the counter.
 $1F3F LD A,B         ; {If the counter is thereby reduced to zero the pause
 $1F40 OR C           ; has come to an end.
 $1F41 JR Z,$1F4F     ; }
 $1F43 LD A,B         ; {If the operand was zero #REGbc will now hold &FFFF and
 $1F44 AND C          ; this value will be returned to zero. Jump with all
 $1F45 INC A          ; other operand values.
 $1F46 JR NZ,$1F49    ;
 $1F48 INC BC         ; }
@label=PAUSE_2
*$1F49 BIT 5,(IY+$01) ; {Jump back unless a key has been pressed (bit 5 of
 $1F4D JR Z,$1F3D     ; #SYSVAR(FLAGS) set).}
; The period of the pause has now finished.
@label=PAUSE_END
*$1F4F RES 5,(IY+$01) ; Signal 'no key pressed' (reset bit 5 of
                      ; #SYSVAR(FLAGS)).
 $1F53 RET            ; Now return - to #R$1B76.

; THE 'BREAK-KEY' SUBROUTINE
;
; Used by the routines at #R$0EF4 and #R$1B76.
; .
; This subroutine is called in several instances to read the BREAK key. The
; carry flag is returned reset only if the SHIFT and the BREAK keys are both
; being pressed.
@label=BREAK_KEY
c$1F54 LD A,$7F      ; {Form the port address &7FFE and read in a byte.
 $1F56 IN A,($FE)    ; }
 $1F58 RRA           ; Examine only bit 0 by shifting it into the carry
                     ; position.
 $1F59 RET C         ; Return if the BREAK key is not being pressed.
 $1F5A LD A,$FE      ; {Form the port address &FEFE and read in a byte.
 $1F5C IN A,($FE)    ; }
 $1F5E RRA           ; Again examine bit 0.
 $1F5F RET           ; Return with carry reset if both keys are being pressed.

; THE 'DEF FN' COMMAND ROUTINE
;
; The address of this routine is found in the #R$1AF9(parameter table).
; .
; During syntax checking a DEF FN statement is checked to ensure that it has
; the correct form. Space is also made available for the result of evaluating
; the function.
; .
; But in 'run-time' a DEF FN statement is passed by.
;
; A Code of the next character in the statement
@refs=$1C0D
@label=DEF_FN
c$1F60 CALL $2530     ; {Jump forward if checking syntax.
 $1F63 JR Z,$1F6A     ; }
 $1F65 LD A,$CE       ; {Otherwise pass by the 'DEF FN' statement.
 $1F67 JP $1E39       ; }
; First consider the variable of the function.
@label=DEF_FN_1
*$1F6A SET 6,(IY+$01) ; Signal 'a numeric variable' (set bit 6 of
                      ; #SYSVAR(FLAGS)).
 $1F6E CALL $2C8D     ; Check that the present code is a letter.
 $1F71 JR NC,$1F89    ; Jump forward if not.
 $1F73 RST $20        ; Fetch the next character.
 $1F74 CP "$"         ; {Jump forward unless it is a '$'.
 $1F76 JR NZ,$1F7D    ; }
 $1F78 RES 6,(IY+$01) ; Reset bit 6 of #SYSVAR(FLAGS) as it is a string
                      ; variable.
 $1F7C RST $20        ; Fetch the next character.
@label=DEF_FN_2
*$1F7D CP "("         ; {A '(' must follow the variable's name.
 $1F7F JR NZ,$1FBD    ; }
 $1F81 RST $20        ; Fetch the next character.
 $1F82 CP ")"         ; {Jump forward if it is a ')' as there are no parameters
 $1F84 JR Z,$1FA6     ; of the function.}
; A loop is now entered to deal with each parameter in turn.
@label=DEF_FN_3
*$1F86 CALL $2C8D     ; {The present code must be a letter.
@label=DEF_FN_4
*$1F89 JP NC,$1C8A    ; }
 $1F8C EX DE,HL       ; Save the pointer in #REGde.
 $1F8D RST $20        ; Fetch the next character.
 $1F8E CP "$"         ; {Jump forward unless it is a '$'.
 $1F90 JR NZ,$1F94    ; }
 $1F92 EX DE,HL       ; Otherwise save the new pointer in #REGde instead.
 $1F93 RST $20        ; Fetch the next character.
@label=DEF_FN_5
*$1F94 EX DE,HL       ; Move the pointer to the last character of the name to
                      ; the #REGhl register pair.
@keep
 $1F95 LD BC,$0006    ; {Now make six locations after that last character and
 $1F98 CALL $1655     ; enter a 'number marker' into the first of the new
 $1F9B INC HL         ; locations.
 $1F9C INC HL         ;
 $1F9D LD (HL),$0E    ; }
 $1F9F CP ","         ; {If the present character is a ',' then jump back as
 $1FA1 JR NZ,$1FA6    ; there should be a further parameter; otherwise jump out
 $1FA3 RST $20        ; of the loop.
 $1FA4 JR $1F86       ; }
; Next the definition of the function is considered.
@label=DEF_FN_6
*$1FA6 CP ")"         ; {Check that the ')' does exist.
 $1FA8 JR NZ,$1FBD    ; }
 $1FAA RST $20        ; The next character is fetched.
 $1FAB CP "="         ; {It must be an '='.
 $1FAD JR NZ,$1FBD    ; }
 $1FAF RST $20        ; Fetch the next character.
 $1FB0 LD A,($5C3B)   ; {Save the nature - numeric or string - of the variable
 $1FB3 PUSH AF        ; (bit 6 of #SYSVAR(FLAGS)).}
 $1FB4 CALL $24FB     ; Now consider the definition as an expression.
 $1FB7 POP AF         ; {Fetch the nature of the variable and check that it is
 $1FB8 XOR (IY+$01)   ; of the same type as found for the definition (specified
 $1FBB AND $40        ; by bit 6 of #SYSVAR(FLAGS)).}
@label=DEF_FN_7
*$1FBD JP NZ,$1C8A    ; Give an error report if it is required.
 $1FC0 CALL $1BEE     ; Exit via #R$1BEE (thereby moving on to consider the
                      ; next statement in the line).
; This routine continues into #R$1FC3.

; THE 'UNSTACK-Z' SUBROUTINE
;
; Used by the routines at #R$1FF5, #R$1FFC, #R$2070 and #R$21E1.
; .
; The routine at #R$1F60 continues here.
; .
; This subroutine is called in several instances in order to 'return early'
; from a subroutine when checking syntax. The reason for this is to avoid
; actually printing characters or passing values to/from the calculator stack.
@label=UNSTACK_Z
c$1FC3 CALL $2530    ; Is syntax being checked?
 $1FC6 POP HL        ; {Fetch the return address but ignore it in
 $1FC7 RET Z         ; 'syntax-time'.}
 $1FC8 JP (HL)       ; In 'run-time' make a simple return to the calling
                     ; routine.

; THE 'LPRINT and PRINT' COMMAND ROUTINES
;
; The address of this routine is found in the #R$1AD9(parameter table).
; .
; The appropriate channel is opened as necessary and the items to be printed
; are considered in turn.
@refs=$1C0D
@label=LPRINT
c$1FC9 LD A,$03      ; Prepare to open channel 'P'.
 $1FCB JR $1FCF      ; Jump forward.
; The address of this entry point is found in the #R$1A9C(parameter table).
@refs=$1C0D
@label=PRINT
*$1FCD LD A,$02      ; Prepare to open channel 'S'.
@label=PRINT_1
*$1FCF CALL $2530    ; {Unless syntax is being checked open a channel.
 $1FD2 CALL NZ,$1601 ; }
 $1FD5 CALL $0D4D    ; Set the temporary colour system variables.
 $1FD8 CALL $1FDF    ; Call the print controlling subroutine.
 $1FDB CALL $1BEE    ; {Move on to consider the next statement (via #R$1BEE if
 $1FDE RET           ; checking syntax).}

; THE 'PRINT CONTROLLING' SUBROUTINE
;
; This subroutine is called by the #R$1FC9 and #R$2089 command routines.
@label=PRINT_2
c$1FDF RST $18       ; Get the first character.
 $1FE0 CALL $2045    ; {Jump forward if already at the end of the item list.
 $1FE3 JR Z,$1FF2    ; }
; Now enter a loop to deal with the 'position controllers' and the print items.
@label=PRINT_3
*$1FE5 CALL $204E    ; {Deal with any consecutive position controllers.
 $1FE8 JR Z,$1FE5    ; }
 $1FEA CALL $1FFC    ; Deal with a single print item.
 $1FED CALL $204E    ; {Check for further position controllers and print items
 $1FF0 JR Z,$1FE5    ; until there are none left.}
@label=PRINT_4
*$1FF2 CP ")"        ; {Return now if the present character is a ')'; otherwise
 $1FF4 RET Z         ; consider performing a 'carriage return'.}
; This routine continues into #R$1FF5.

; THE 'PRINT A CARRIAGE RETURN' SUBROUTINE
;
; Used by the routine at #R$204E.
; .
; The routine at #R$1FDF continues here.
@label=PRINT_CR
c$1FF5 CALL $1FC3    ; Return if checking syntax.
 $1FF8 LD A,$0D      ; {Print a carriage return character and then return.
 $1FFA RST $10       ;
 $1FFB RET           ; }

; THE 'PRINT ITEMS' SUBROUTINE
;
; This subroutine is called from the #R$1FDF and #R$2089 routines.
; .
; The various types of print item are identified and printed.
@label=PR_ITEM_1
c$1FFC RST $18        ; The first character is fetched.
 $1FFD CP $AC         ; {Jump forward unless it is an 'AT'.
 $1FFF JR NZ,$200E    ; }
; Now deal with an 'AT'.
 $2001 CALL $1C79     ; The two parameters are transferred to the calculator
                      ; stack.
 $2004 CALL $1FC3     ; Return now if checking syntax.
 $2007 CALL $2307     ; The parameters are compressed into the #REGbc register
                      ; pair.
 $200A LD A,$16       ; {The #REGa register is loaded with the AT control
 $200C JR $201E       ; character before the jump is taken.}
; Next look for a 'TAB'.
@label=PR_ITEM_2
*$200E CP $AD         ; {Jump forward unless it is a 'TAB'.
 $2010 JR NZ,$2024    ; }
; Now deal with a 'TAB'.
 $2012 RST $20        ; Get the next character.
 $2013 CALL $1C82     ; Transfer one parameter to the calculator stack.
 $2016 CALL $1FC3     ; Return now if checking syntax.
 $2019 CALL $1E99     ; The value is compressed into the #REGbc register pair.
 $201C LD A,$17       ; The #REGa register is loaded with the TAB control
                      ; character.
; The 'AT' and the 'TAB' print items are printed by making three calls to
; #R$0010.
@label=PR_AT_TAB
*$201E RST $10        ; Print the control character.
 $201F LD A,C         ; {Follow it with the first value.
 $2020 RST $10        ; }
 $2021 LD A,B         ; {Finally print the second value, then return.
 $2022 RST $10        ;
 $2023 RET            ; }
; Next consider embedded colour items.
@label=PR_ITEM_3
*$2024 CALL $21F2     ; {Return with carry reset if colour items were found.
 $2027 RET NC         ; Continue if none were found.}
 $2028 CALL $2070     ; Next consider if the stream is to be changed.
 $202B RET NC         ; Continue unless it was altered.
; The print item must now be an expression, either numeric or string.
 $202C CALL $24FB     ; {Evaluate the expression but return now if checking
 $202F CALL $1FC3     ; syntax.}
 $2032 BIT 6,(IY+$01) ; Test for the nature of the expression (bit 6 of
                      ; #SYSVAR(FLAGS)).
 $2036 CALL Z,$2BF1   ; {If it is a string then fetch the necessary parameters;
 $2039 JP NZ,$2DE3    ; but if it is numeric then exit via #R$2DE3.}
; A loop is now set up to deal with each character in turn of the string.
@label=PR_STRING
*$203C LD A,B         ; {Return now if there are no characters remaining in the
 $203D OR C           ; string; otherwise decrease the counter.
 $203E DEC BC         ;
 $203F RET Z          ; }
 $2040 LD A,(DE)      ; {Fetch the code and increment the pointer.
 $2041 INC DE         ; }
 $2042 RST $10        ; {The code is printed and a jump taken to consider any
 $2043 JR $203C       ; further characters.}

; THE 'END OF PRINTING' SUBROUTINE
;
; Used by the routines at #R$1FDF and #R$204E.
; .
; The zero flag will be set if no further printing is to be done.
;
;   A Code of the current character
; O:F Zero flag set if the character is ')', ':' or a carriage return
@label=PR_END_Z
c$2045 CP ")"        ; {Return now if the character is a ')'.
 $2047 RET Z         ; }
; This entry point is used by the routine at #R$0605.
@label=PR_ST_END
*$2048 CP $0D        ; {Return now if the character is a 'carriage return'.
 $204A RET Z         ; }
 $204B CP ":"        ; {Make a final test against ':' before returning.
 $204D RET           ; }

; THE 'PRINT POSITION' SUBROUTINE
;
; Used by the routines at #R$1FDF and #R$2089.
; .
; The various position controlling characters are considered by this
; subroutine.
;
; O:F Zero flag set if a position controlling character is found
@label=PR_POSN_1
c$204E RST $18       ; Get the present character.
 $204F CP ";"        ; {Jump forward if it is a ';'.
 $2051 JR Z,$2067    ; }
 $2053 CP ","        ; {Also jump forward with a character other than a ',',
 $2055 JR NZ,$2061   ; but do not actually print the character if checking
 $2057 CALL $2530    ; syntax.
 $205A JR Z,$2067    ; }
 $205C LD A,$06      ; {Load the #REGa register with the 'comma' control code
 $205E RST $10       ; and print it, then jump forward.
 $205F JR $2067      ; }
@label=PR_POSN_2
*$2061 CP "'"        ; Is it a '''?
 $2063 RET NZ        ; Return now (with the zero flag reset) if not any of the
                     ; position controllers.
 $2064 CALL $1FF5    ; Print 'carriage return' unless checking syntax.
@label=PR_POSN_3
*$2067 RST $20       ; Fetch the next character.
 $2068 CALL $2045    ; {If not at the end of a print statement then jump
 $206B JR NZ,$206E   ; forward.}
 $206D POP BC        ; Otherwise drop the return address from the stack.
@label=PR_POSN_4
*$206E CP A          ; {Set the zero flag and return.
 $206F RET           ; }

; THE 'ALTER STREAM' SUBROUTINE
;
; Used by the routines at #R$17F9 and #R$1FFC.
; .
; This subroutine is called whenever there is the need to consider whether the
; user wishes to use a different stream.
;
;   A Code of the current character
; O:F Carry flag set if the character is not '#'
@label=STR_ALTER
c$2070 CP "#"        ; {Unless the present character is a '#' return with the
 $2072 SCF           ; carry flag set.
 $2073 RET NZ        ; }
 $2074 RST $20       ; Advance #SYSVAR(CH-ADD).
 $2075 CALL $1C82    ; Pass the parameter to the calculator stack.
 $2078 AND A         ; Clear the carry flag.
 $2079 CALL $1FC3    ; Return now if checking syntax.
 $207C CALL $1E94    ; The value is passed to the #REGa register.
 $207F CP $10        ; {Give report O if the value is over &0F.
 $2081 JP NC,$160E   ; }
 $2084 CALL $1601    ; Use the channel for the stream in question.
 $2087 AND A         ; {Clear the carry flag and return.
 $2088 RET           ; }

; THE 'INPUT' COMMAND ROUTINE
;
; The address of this routine is found in the #R$1A9F(parameter table).
; .
; This routine allows for values entered from the keyboard to be assigned to
; variables. It is also possible to have print items embedded in the INPUT
; statement and these items are printed in the lower part of the display.
@refs=$1C0D
@label=INPUT
c$2089 CALL $2530      ; {Jump forward if syntax is being checked.
 $208C JR Z,$2096      ; }
 $208E LD A,$01        ; {Open channel 'K'.
 $2090 CALL $1601      ; }
 $2093 CALL $0D6E      ; The lower part of the display is cleared.
@label=INPUT_1
*$2096 LD (IY+$02),$01 ; Signal that the lower screen is being handled (set bit
                       ; 0 of #SYSVAR(TV-FLAG) and reset all other bits).
 $209A CALL $20C1      ; Call the subroutine to deal with the INPUT items.
 $209D CALL $1BEE      ; Move on to the next statement if checking syntax.
 $20A0 LD BC,($5C88)   ; Fetch the current print position (#SYSVAR(S-POSN)).
 $20A4 LD A,($5C6B)    ; {Jump forward if the current position is above the
 $20A7 CP B            ; lower screen (see #SYSVAR(DF-SZ)).
 $20A8 JR C,$20AD      ; }
 $20AA LD C,$21        ; {Otherwise set the print position to the top of the
 $20AC LD B,A          ; lower screen.}
@label=INPUT_2
*$20AD LD ($5C88),BC   ; Reset #SYSVAR(S-POSN).
 $20B1 LD A,$19        ; {Now set the scroll counter (#SYSVAR(SCR-CT)).
 $20B3 SUB B           ;
 $20B4 LD ($5C8C),A    ; }
 $20B7 RES 0,(IY+$02)  ; Signal 'main screen' (reset bit 0 of
                       ; #SYSVAR(TV-FLAG)).
 $20BB CALL $0DD9      ; {Set the system variables and exit via #R$0D6E.
 $20BE JP $0D6E        ; }
; The INPUT items and embedded PRINT items are dealt with in turn by the
; following loop.
@label=IN_ITEM_1
*$20C1 CALL $204E      ; {Consider first any position control characters.
 $20C4 JR Z,$20C1      ; }
 $20C6 CP "("          ; {Jump forward if the present character is not a '('.
 $20C8 JR NZ,$20D8     ; }
 $20CA RST $20         ; Fetch the next character.
 $20CB CALL $1FDF      ; Now call the PRINT command routine to handle the items
                       ; inside the brackets.
 $20CE RST $18         ; Fetch the present character.
 $20CF CP ")"          ; {Give report C unless the character is a ')'.
 $20D1 JP NZ,$1C8A     ; }
 $20D4 RST $20         ; {Fetch the next character and jump forward to see if
 $20D5 JP $21B2        ; there are any further INPUT items.}
; Now consider whether INPUT LINE is being used.
@label=IN_ITEM_2
*$20D8 CP $CA          ; {Jump forward if it is not 'LINE'.
 $20DA JR NZ,$20ED     ; }
 $20DC RST $20         ; Advance #SYSVAR(CH-ADD).
 $20DD CALL $1C1F      ; Determine the destination address for the variable.
 $20E0 SET 7,(IY+$37)  ; Signal 'using INPUT LINE' (set bit 7 of
                       ; #SYSVAR(FLAGX)).
 $20E4 BIT 6,(IY+$01)  ; {Give report C unless using a string variable (bit 6
 $20E8 JP NZ,$1C8A     ; of #SYSVAR(FLAGS) reset).}
 $20EB JR $20FA        ; Jump forward to issue the prompt message.
; Proceed to handle simple INPUT variables.
@label=IN_ITEM_3
*$20ED CALL $2C8D      ; {Jump to consider going round the loop again if the
 $20F0 JP NC,$21AF     ; present character is not a letter.}
 $20F3 CALL $1C1F      ; Determine the destination address for the variable.
 $20F6 RES 7,(IY+$37)  ; Signal 'not INPUT LINE' (reset bit 7 of
                       ; #SYSVAR(FLAGX)).
; The prompt message is now built up in the work space.
@label=IN_PROMPT
*$20FA CALL $2530      ; {Jump forward if only checking syntax.
 $20FD JP Z,$21B2      ; }
 $2100 CALL $16BF      ; The work space is set to null.
 $2103 LD HL,$5C71     ; This is #SYSVAR(FLAGX).
 $2106 RES 6,(HL)      ; Signal 'string result'.
 $2108 SET 5,(HL)      ; Signal 'INPUT mode'.
@keep
 $210A LD BC,$0001     ; Allow the prompt message only a single location.
 $210D BIT 7,(HL)      ; {Jump forward if using 'LINE'.
 $210F JR NZ,$211C     ; }
 $2111 LD A,($5C3B)    ; {Jump forward if awaiting a numeric entry (bit 6 of
 $2114 AND $40         ; #SYSVAR(FLAGS) set).
 $2116 JR NZ,$211A     ; }
 $2118 LD C,$03        ; A string entry will need three locations.
@label=IN_PR_1
*$211A OR (HL)         ; {Bit 6 of #SYSVAR(FLAGX) will become set for a numeric
 $211B LD (HL),A       ; entry.}
@label=IN_PR_2
*$211C RST $30         ; The required number of locations is made available.
 $211D LD (HL),$0D     ; A 'carriage return' goes into the last location.
 $211F LD A,C          ; {Test bit 6 of the #REGc register and jump forward if
 $2120 RRCA            ; only one location was required.
 $2121 RRCA            ;
 $2122 JR NC,$2129     ; }
 $2124 LD A,"\""       ; {A 'double quotes' character goes into the first and
 $2126 LD (DE),A       ; second locations.
 $2127 DEC HL          ;
 $2128 LD (HL),A       ; }
@label=IN_PR_3
*$2129 LD ($5C5B),HL   ; The position of the cursor (#SYSVAR(K-CUR)) can now be
                       ; saved.
; In the case of INPUT LINE the EDITOR can be called without further
; preparation but for other types of INPUT the error stack has to be changed so
; as to trap errors.
 $212C BIT 7,(IY+$37)  ; {Jump forward with 'INPUT LINE' (bit 7 of
 $2130 JR NZ,$215E     ; #SYSVAR(FLAGX) set).}
 $2132 LD HL,($5C5D)   ; {Save the current values of #SYSVAR(CH-ADD) and
 $2135 PUSH HL         ; #SYSVAR(ERR-SP) on the machine stack.
 $2136 LD HL,($5C3D)   ;
 $2139 PUSH HL         ; }
@nowarn
@label=IN_VAR_1
 $213A LD HL,$213A     ; {This will be the 'return point' in case of errors.
 $213D PUSH HL         ; }
 $213E BIT 4,(IY+$30)  ; {Only change the error stack pointer (#SYSVAR(ERR-SP))
 $2142 JR Z,$2148      ; if using channel 'K' (bit 4 of #R$5C6A(FLAGS2) set).
 $2144 LD ($5C3D),SP   ; }
@label=IN_VAR_2
*$2148 LD HL,($5C61)   ; {Set #REGhl to the start of the INPUT line
 $214B CALL $11A7      ; (#SYSVAR(WORKSP)) and remove any floating-point forms.
                       ; (There will not be any except perhaps after an error.)
                       ; }
 $214E LD (IY+$00),$FF ; Signal 'no error yet' by resetting #SYSVAR(ERR-NR).
 $2152 CALL $0F2C      ; {Now get the INPUT and with the syntax/run flag (bit 7
 $2155 RES 7,(IY+$01)  ; of #SYSVAR(FLAGS)) indicating syntax, check the INPUT
 $2159 CALL $21B9      ; for errors; jump if in order; return to #R$213A if
 $215C JR $2161        ; not.}
@label=IN_VAR_3
*$215E CALL $0F2C      ; Get a 'LINE'.
; All the system variables have to be reset before the actual assignment of a
; value can be made.
@label=IN_VAR_4
*$2161 LD (IY+$22),$00 ; The cursor address (#SYSVAR(K-CUR)) is reset.
 $2165 CALL $21D6      ; {The jump is taken if using other than channel 'K'.
 $2168 JR NZ,$2174     ; }
 $216A CALL $111D      ; {The input-line is copied to the display and the
 $216D LD BC,($5C82)   ; position in #SYSVAR(ECHO-E) made the current position
 $2171 CALL $0DD9      ; in the lower screen.}
@label=IN_VAR_5
*$2174 LD HL,$5C71     ; This is #SYSVAR(FLAGX).
 $2177 RES 5,(HL)      ; Signal 'edit mode'.
 $2179 BIT 7,(HL)      ; {Jump forward if handling an INPUT LINE.
 $217B RES 7,(HL)      ;
 $217D JR NZ,$219B     ; }
 $217F POP HL          ; Drop the address IN-VAR-1.
 $2180 POP HL          ; {Reset the #SYSVAR(ERR-SP) to its original address.
 $2181 LD ($5C3D),HL   ; }
 $2184 POP HL          ; {Save the original #SYSVAR(CH-ADD) address in
 $2185 LD ($5C5F),HL   ; #SYSVAR(X-PTR).}
 $2188 SET 7,(IY+$01)  ; {Now with the syntax/run flag (bit 7 of
 $218C CALL $21B9      ; #SYSVAR(FLAGS)) indicating 'run' make the assignment.}
 $218F LD HL,($5C5F)   ; {Restore the original address to #SYSVAR(CH-ADD) and
 $2192 LD (IY+$26),$00 ; clear #SYSVAR(X-PTR).
 $2196 LD ($5C5D),HL   ; }
 $2199 JR $21B2        ; Jump forward to see if there are further INPUT items.
@label=IN_VAR_6
*$219B LD HL,($5C63)   ; {The length of the 'LINE' in the work space is found
 $219E LD DE,($5C61)   ; (#SYSVAR(STKBOT)-#SYSVAR(WORKSP)-1).
 $21A2 SCF             ;
 $21A3 SBC HL,DE       ; }
 $21A5 LD B,H          ; {#REGde points to the start and #REGbc holds the
 $21A6 LD C,L          ; length.}
 $21A7 CALL $2AB2      ; {These parameters are stacked and the actual
 $21AA CALL $2AFF      ; assignment made.}
 $21AD JR $21B2        ; Also jump forward to consider further items.
; Further items in the INPUT statement are considered.
@label=IN_NEXT_1
*$21AF CALL $1FFC      ; Handle any print items.
@label=IN_NEXT_2
*$21B2 CALL $204E      ; Handle any position controllers.
 $21B5 JP Z,$20C1      ; {Go around the loop again if there are further items;
 $21B8 RET             ; otherwise return.}

; THE 'IN-ASSIGN' SUBROUTINE
;
; Used by the routine at #R$2089.
; .
; This subroutine is called twice for each INPUT value: once with the
; syntax/run flag reset (syntax) and once with it set (run).
@label=IN_ASSIGN
c$21B9 LD HL,($5C61) ; {Set #SYSVAR(CH-ADD) to point to the first location of
 $21BC LD ($5C5D),HL ; the work space (#SYSVAR(WORKSP)) and fetch the
 $21BF RST $18       ; character.}
 $21C0 CP $E2        ; Is it a 'STOP'?
 $21C2 JR Z,$21D0    ; Jump if it is.
 $21C4 LD A,($5C71)  ; {Otherwise pick up #SYSVAR(FLAGX) and make the
 $21C7 CALL $1C59    ; assignment of the 'value' to the variable.}
 $21CA RST $18       ; {Get the present character and check it is a 'carriage
 $21CB CP $0D        ; return'.}
 $21CD RET Z         ; Return if it is.
; Report C - Nonsense in BASIC.
 $21CE RST $08       ; {Call the error handling routine.
 $21CF DEFB $0B      ; }
; Come here if the INPUT line starts with 'STOP'.
@label=IN_STOP
*$21D0 CALL $2530    ; {But do not give the error report on the syntax-pass.
 $21D3 RET Z         ; }
; Report H - STOP in INPUT.
 $21D4 RST $08       ; {Call the error handling routine.
 $21D5 DEFB $10      ; }

; THE 'IN-CHAN-K' SUBROUTINE
;
; Used by the routine at #R$2089.
;
; O:F Zero flag set if channel 'K' (keyboard) is being used
@label=IN_CHAN_K
c$21D6 LD HL,($5C51) ; {The base address of the channel information for the
 $21D9 INC HL        ; current channel (#SYSVAR(CURCHL)) is fetched and the
 $21DA INC HL        ; channel code compared to the character 'K'.
 $21DB INC HL        ;
 $21DC INC HL        ;
 $21DD LD A,(HL)     ;
 $21DE CP "K"        ; }
 $21E0 RET           ; Return afterwards.

; THE 'COLOUR ITEM' ROUTINES
;
; This set of routines can be readily divided into two parts:
; .
; #LIST
; { i. The embedded colour item' handler. }
; { ii. The 'colour system variable' handler. }
; LIST#
; .
; i. Embedded colour items are handled by calling #R$0010 as required.
; .
; A loop is entered to handle each item in turn. The entry point is at #R$21E2.
@label=CO_TEMP_1
c$21E1 RST $20       ; Consider the next character in the BASIC statement.
; This entry point is used by the routine at #R$1CBE.
@label=CO_TEMP_2
*$21E2 CALL $21F2    ; {Jump forward to see if the present code represents an
 $21E5 RET C         ; embedded 'temporary' colour item. Return carry set if
                     ; not a colour item.}
 $21E6 RST $18       ; Fetch the present character.
 $21E7 CP ","        ; {Jump back if it is either a ',' or a ';'; otherwise
 $21E9 JR Z,$21E1    ; there has been an error.
 $21EB CP ";"        ;
 $21ED JR Z,$21E1    ; }
 $21EF JP $1C8A      ; Exit via 'report C'.
; This entry point is used by the routine at #R$1FFC.
@label=CO_TEMP_3
*$21F2 CP $D9        ; {Return with the carry flag set if the code is not in
 $21F4 RET C         ; the range &D9 to &DE (INK to OVER).
 $21F5 CP $DF        ;
 $21F7 CCF           ;
 $21F8 RET C         ; }
 $21F9 PUSH AF       ; {The colour item code is preserved whilst
 $21FA RST $20       ; #SYSVAR(CH-ADD) is advanced to address the parameter
 $21FB POP AF        ; that follows it.}
; This entry point is used by the routine at #R$1C96.
; .
; The colour item code and the parameter are now 'printed' by calling #R$0010
; on two occasions.
@label=CO_TEMP_4
*$21FC SUB $C9       ; The token range (&D9 to &DE) is reduced to the control
                     ; character range (&10 to &15).
 $21FE PUSH AF       ; {The control character code is preserved whilst the
 $21FF CALL $1C82    ; parameter is moved to the calculator stack.
 $2202 POP AF        ; }
 $2203 AND A         ; {A return is made at this point if syntax is being
 $2204 CALL $1FC3    ; checked.}
 $2207 PUSH AF       ; {The control character code is preserved whilst the
 $2208 CALL $1E94    ; parameter is moved to the #REGd register.
 $220B LD D,A        ;
 $220C POP AF        ; }
 $220D RST $10       ; The control character is sent out.
 $220E LD A,D        ; {Then the parameter is fetched and sent out before
 $220F RST $10       ; returning.
 $2210 RET           ; }
; This entry point is used by the routine at #R$0A6D.
; .
; ii. The colour system variables - #SYSVAR(ATTR-T), #SYSVAR(MASK-T) and
; #SYSVAR(P-FLAG) - are altered as required. On entry the control character
; code is in the #REGa register and the parameter is in the #REGd register.
; .
; Note that all changes are to the 'temporary' system variables.
@label=CO_TEMP_5
*$2211 SUB $11       ; {Reduce the range and jump forward with INK and PAPER.
 $2213 ADC A,$00     ;
 $2215 JR Z,$2234    ; }
 $2217 SUB $02       ; {Reduce the range once again and jump forward with FLASH
 $2219 ADC A,$00     ; and BRIGHT.
 $221B JR Z,$2273    ; }
; The colour control code will now be &01 for INVERSE and &02 for OVER and the
; system variable #SYSVAR(P-FLAG) is altered accordingly.
 $221D CP $01        ; Prepare to jump with OVER.
 $221F LD A,D        ; Fetch the parameter.
 $2220 LD B,$01      ; Prepare the mask for OVER.
 $2222 JR NZ,$2228   ; Now jump.
 $2224 RLCA          ; {Bit 2 of the #REGa register is to be reset for INVERSE
 $2225 RLCA          ; 0 and set for INVERSE 1; the mask is to have bit 2 set.
 $2226 LD B,$04      ; }
@label=CO_TEMP_6
*$2228 LD C,A        ; Save the #REGa register whilst the range is tested.
 $2229 LD A,D        ; {The correct range for INVERSE and OVER is only '0-1'.
 $222A CP $02        ;
 $222C JR NC,$2244   ; }
 $222E LD A,C        ; Restore the #REGa register.
 $222F LD HL,$5C91   ; It is #SYSVAR(P-FLAG) that is to be changed.
 $2232 JR $226C      ; Exit via #R$226C and alter #SYSVAR(P-FLAG) using #REGb
                     ; as a mask, i.e. bit 0 for OVER and bit 2 for INVERSE.
; PAPER and INK are dealt with by the following routine. On entry the carry
; flag is set for INK.
@label=CO_TEMP_7
*$2234 LD A,D        ; Fetch the parameter.
 $2235 LD B,$07      ; Prepare the mask for INK.
 $2237 JR C,$223E    ; Jump forward with INK.
 $2239 RLCA          ; {Multiply the parameter for PAPER by eight.
 $223A RLCA          ;
 $223B RLCA          ; }
 $223C LD B,$38      ; Prepare the mask for PAPER.
@label=CO_TEMP_8
*$223E LD C,A        ; Save the parameter in the #REGc register whilst the
                     ; range of the parameter is tested.
 $223F LD A,D        ; Fetch the original value.
 $2240 CP $0A        ; {Only allow PAPER/INK a range of '0' to '9'.
 $2242 JR C,$2246    ; }
; This entry point is used by the routine at #R$2294.
; .
; Report K - Invalid colour.
@label=REPORT_K
*$2244 RST $08       ; {Call the error handling routine.
 $2245 DEFB $13      ; }
; Continue to handle PAPER and INK.
@label=CO_TEMP_9
*$2246 LD HL,$5C8F   ; Prepare to alter #SYSVAR(ATTR-T), #SYSVAR(MASK-T) and
                     ; #SYSVAR(P-FLAG).
 $2249 CP $08        ; {Jump forward with PAPER/INK '0' to '7'.
 $224B JR C,$2258    ; }
 $224D LD A,(HL)     ; {Fetch the current value of #SYSVAR(ATTR-T) and use it
 $224E JR Z,$2257    ; unchanged, by jumping forward, with PAPER/INK '8'.}
 $2250 OR B          ; {But for PAPER/INK '9' the PAPER and INK colours have to
 $2251 CPL           ; be black and white.
 $2252 AND $24       ; }
 $2254 JR Z,$2257    ; {Jump for black INK/PAPER, but continue for white
 $2256 LD A,B        ; INK/PAPER.}
@label=CO_TEMP_A
*$2257 LD C,A        ; Move the value to the #REGc register.
; The mask (#REGb) and the value (#REGc) are now used to change
; #SYSVAR(ATTR-T).
@label=CO_TEMP_B
*$2258 LD A,C        ; Move the value.
 $2259 CALL $226C    ; Now change #SYSVAR(ATTR-T) as needed.
; Next #SYSVAR(MASK-T) is considered.
 $225C LD A,$07      ; {The bits of #SYSVAR(MASK-T) are set only when using
 $225E CP D          ; PAPER/INK '8' or '9'.
 $225F SBC A,A       ; }
 $2260 CALL $226C    ; Now change #SYSVAR(MASK-T) as needed.
; Next #SYSVAR(P-FLAG) is considered.
 $2263 RLCA          ; {The appropriate mask is built up in the #REGb register
 $2264 RLCA          ; in order to change bits 4 and 6 as necessary.
 $2265 AND $50       ;
 $2267 LD B,A        ; }
 $2268 LD A,$08      ; {The bits of #SYSVAR(P-FLAG) are set only when using
 $226A CP D          ; PAPER/INK '9'. Continue into #R$226C to manipulate
 $226B SBC A,A       ; #SYSVAR(P-FLAG).}
; The following subroutine is used to 'impress' upon a system variable the
; 'nature' of the bits in the #REGa register. The #REGb register holds a mask
; that shows which bits are to be 'copied over' from #REGa to (#REGhl).
@label=CO_CHANGE
*$226C XOR (HL)      ; {The bits, specified by the mask in the #REGb register,
 $226D AND B         ; are changed in the value and the result goes to form the
 $226E XOR (HL)      ; system variable.
 $226F LD (HL),A     ; }
 $2270 INC HL        ; Move on to address the next system variable.
 $2271 LD A,B        ; {Return with the mask in the #REGa register.
 $2272 RET           ; }
; FLASH and BRIGHT are handled by the following routine.
@label=CO_TEMP_C
*$2273 SBC A,A       ; The zero flag will be set for BRIGHT.
 $2274 LD A,D        ; {The parameter is fetched and rotated.
 $2275 RRCA          ; }
 $2276 LD B,$80      ; Prepare the mask for FLASH.
 $2278 JR NZ,$227D   ; Jump forward with FLASH.
 $227A RRCA          ; {Rotate an extra time and prepare the mask for BRIGHT.
 $227B LD B,$40      ; }
@label=CO_TEMP_D
*$227D LD C,A        ; Save the value in the #REGc register.
 $227E LD A,D        ; {Fetch the parameter and test its range; only '0', '1'
 $227F CP $08        ; and '8' are allowable.
 $2281 JR Z,$2287    ;
 $2283 CP $02        ;
 $2285 JR NC,$2244   ; }
; The system variable #SYSVAR(ATTR-T) can now be altered.
@label=CO_TEMP_E
*$2287 LD A,C        ; Fetch the value.
 $2288 LD HL,$5C8F   ; This is #SYSVAR(ATTR-T).
 $228B CALL $226C    ; Now change the system variable.
; The value in #SYSVAR(MASK-T) is now considered.
 $228E LD A,C        ; The value is fetched anew.
 $228F RRCA          ; {The set bit of FLASH/BRIGHT '8' (bit 3) is moved to bit
 $2290 RRCA          ; 7 (for FLASH) or bit 6 (for BRIGHT).
 $2291 RRCA          ; }
 $2292 JR $226C      ; Exit via #R$226C.

; THE 'BORDER' COMMAND ROUTINE
;
; The address of this routine is found in the #R$1AF5(parameter table).
; .
; The parameter of the BORDER command is used with an '#S/OUT/' command to
; actually alter the colour of the border. The parameter is then saved in the
; system variable #SYSVAR(BORDCR).
@refs=$1C0D
@label=BORDER
c$2294 CALL $1E94    ; {The parameter is fetched and its range is tested.
 $2297 CP $08        ;
 $2299 JR NC,$2244   ; }
 $229B OUT ($FE),A   ; The '#S/OUT/' instruction is then used to set the border
                     ; colour.
 $229D RLCA          ; {The parameter is then multiplied by eight.
 $229E RLCA          ;
 $229F RLCA          ; }
 $22A0 BIT 5,A       ; Is the border colour a 'light' colour?
 $22A2 JR NZ,$22A6   ; Jump if so (the INK colour will be black).
 $22A4 XOR $07       ; Change the INK colour to white.
@label=BORDER_1
*$22A6 LD ($5C48),A  ; {Set the system variable (#SYSVAR(BORDCR)) as required
 $22A9 RET           ; and return.}

; THE 'PIXEL ADDRESS' SUBROUTINE
;
; This subroutine is called by #R$22CB and by #R$22DC. Is is entered with the
; co-ordinates of a pixel in the #REGbc register pair and returns with #REGhl
; holding the address of the display file byte which contains that pixel and
; #REGa pointing to the position of the pixel within the byte.
;
;   B Pixel y-coordinate
;   C Pixel x-coordinate
; O:A #REGc mod 8
; O:HL Display file address
@label=PIXEL_ADD
c$22AA LD A,$AF      ; {Test that the y co-ordinate (in #REGb) is not greater
 $22AC SUB B         ; than 175.
 $22AD JP C,$24F9    ; }
 $22B0 LD B,A        ; #REGb now contains 175 minus y.
 $22B1 AND A         ; #REGa holds b7b6b5b4b3b2b1b0, the bits of #REGb.
 $22B2 RRA           ; And now 0b7b6b5b4b3b2b1.
 $22B3 SCF           ; {Now 10b7b6b5b4b3b2.
 $22B4 RRA           ; }
 $22B5 AND A         ; {Now 010b7b6b5b4b3.
 $22B6 RRA           ; }
 $22B7 XOR B         ; {Finally 010b7b6b2b1b0, so that #REGh becomes
 $22B8 AND %11111000 ; 64+8*INT(#REGb/64)+(#REGb mod 8), the high byte of the
 $22BA XOR B         ; pixel address.
 $22BB LD H,A        ; }
 $22BC LD A,C        ; #REGc contains x.
 $22BD RLCA          ; {#REGa starts as c7c6c5c4c3c2c1c0 and becomes
 $22BE RLCA          ; c4c3c2c1c0c7c6c5.
 $22BF RLCA          ; }
 $22C0 XOR B         ; {Now c4c3b5b4b3c7c6c5.
 $22C1 AND %11000111 ;
 $22C3 XOR B         ; }
 $22C4 RLCA          ; {Finally b5b4b3c7c6c5c4c3, so that #REGl becomes
 $22C5 RLCA          ; 32*INT((#REGb mod 64)/8)+INT(x/8), the low byte.
 $22C6 LD L,A        ; }
 $22C7 LD A,C        ; {#REGa holds x mod 8, so the pixel is bit (7-#REGa)
 $22C8 AND $07       ; within the byte.}
 $22CA RET           ;

; THE 'POINT' SUBROUTINE
;
; This subroutine is called from #R$267B. It is entered with the coordinates of
; a pixel on the calculator stack, and returns a last value of 1 if that pixel
; is ink colour, and 0 if it is paper colour.
@label=POINT_SUB
c$22CB CALL $2307    ; y-coordinate to #REGb, x to #REGc.
 $22CE CALL $22AA    ; Pixel address to #REGhl.
 $22D1 LD B,A        ; {#REGb will count #REGa+1 loops to get the wanted bit of
 $22D2 INC B         ; (#REGhl) to location 0.
 $22D3 LD A,(HL)     ; }
@label=POINT_LP
*$22D4 RLCA          ; {The shifts.
 $22D5 DJNZ $22D4    ; }
 $22D7 AND $01       ; The bit is 1 for ink, 0 for paper.
 $22D9 JP $2D28      ; It is put on the calculator stack.

; THE 'PLOT' COMMAND ROUTINE
;
; The address of this routine is found in the #R$1AC1(parameter table).
; .
; This routine consists of a main subroutine plus one line to call it and one
; line to exit from it. The main routine is used twice by #R$2320 and the
; subroutine is called by #R$24B7. The routine is entered with the coordinates
; of a pixel on the calculator stack. It finds the address of that pixel and
; plots it, taking account of the status of INVERSE and OVER held in the
; #SYSVAR(P-FLAG).
@refs=$1C0D
@label=PLOT
c$22DC CALL $2307    ; y-coordinate to #REGb, x to #REGc.
 $22DF CALL $22E5    ; The subroutine is called.
 $22E2 JP $0D4D      ; Exit, setting temporary colours.
; This entry point is used by the routine at #R$24B7.
@label=PLOT_SUB
*$22E5 LD ($5C7D),BC ; The system variable #SYSVAR(COORDS) is set.
 $22E9 CALL $22AA    ; Pixel address to #REGhl.
 $22EC LD B,A        ; {#REGb will count #REGa+1 loops to get a zero to the
 $22ED INC B         ; correct place in #REGa.}
 $22EE LD A,$FE      ; The zero is entered.
@label=PLOT_LOOP
*$22F0 RRCA          ; {Then lined up with the pixel bit position in the byte.
 $22F1 DJNZ $22F0    ; }
 $22F3 LD B,A        ; Then copied to #REGb.
 $22F4 LD A,(HL)     ; The pixel-byte is obtained in #REGa.
 $22F5 LD C,(IY+$57) ; {#SYSVAR(P-FLAG) is obtained and first tested for OVER.
 $22F8 BIT 0,C       ; }
 $22FA JR NZ,$22FD   ; Jump if OVER 1.
 $22FC AND B         ; OVER 0 first makes the pixel zero.
@label=PL_TST_IN
*$22FD BIT 2,C       ; Test for INVERSE.
 $22FF JR NZ,$2303   ; INVERSE 1 just leaves the pixel as it was (OVER 1) or
                     ; zero (OVER 0).
 $2301 XOR B         ; {INVERSE 0 leaves the pixel complemented (OVER 1) or 1
 $2302 CPL           ; (OVER 0).}
@label=PLOT_END
*$2303 LD (HL),A     ; The byte is entered. Its other bits are unchanged in
                     ; every case.
 $2304 JP $0BDB      ; Exit, setting attribute byte.

; THE 'STK-TO-BC' SUBROUTINE
;
; Used by the routines at #R$1FFC, #R$22CB, #R$22DC, #R$24B7, #R$2535 and
; #R$2580.
; .
; This subroutine loads two floating point numbers into the #REGbc register
; pair. It is thus used to pick up parameters in the range &00 to &FF. It also
; obtains in #REGde the 'diagonal move' values (+/-1,+/-1) which are used in
; #R$24B7.
;
; O:B First number from the calculator stack
; O:C Second number from the calculator stack
; O:D Sign of the first number (&01 or &FF)
; O:E Sign of the second number (&01 or &FF)
@label=STK_TO_BC
c$2307 CALL $2314    ; First number to #REGa.
 $230A LD B,A        ; Hence to #REGb.
 $230B PUSH BC       ; Save it briefly.
 $230C CALL $2314    ; Second number to #REGa.
 $230F LD E,C        ; Its sign indicator to #REGe.
 $2310 POP BC        ; Restore first number.
 $2311 LD D,C        ; Its sign indicator to #REGd.
 $2312 LD C,A        ; Second number to #REGc.
 $2313 RET           ; #REGbc, #REGde are now as required.

; THE 'STK-TO-A' SUBROUTINE
;
; Used by the routine at #R$2307.
; .
; This subroutine loads the #REGa register with the floating point number held
; at the top of the calculator stack. The number must be in the range &00 to
; &FF.
;
; O:A Number from the calculator stack
; O:C Sign of the number (&01 or &FF)
@label=STK_TO_A
c$2314 CALL $2DD5    ; {Modulus of rounded last value to #REGa if possible;
 $2317 JP C,$24F9    ; else, report error.}
 $231A LD C,$01      ; One to #REGc for positive last value.
 $231C RET Z         ; Return if value was positive.
 $231D LD C,$FF      ; Else change #REGc to &FF (i.e. minus one).
 $231F RET           ; Finished.

; THE 'CIRCLE' COMMAND ROUTINE
;
; The address of this routine is found in the #R$1AE7(parameter table).
; .
; This routine draws an approximation to the circle with centre co-ordinates X
; and Y and radius Z. These numbers are rounded to the nearest integer before
; use. Thus Z must be less than 87.5, even when (X,Y) is in the centre of the
; screen. The method used is to draw a series of arcs approximated by straight
; lines.
; .
; CIRCLE has four parts:
; .
; #LIST
; { i. Tests the radius. If its modulus is less than 1, just plot X,Y. }
; { ii. Calls #R$247D, which is used to set the initial parameters for both
; CIRCLE and DRAW. }
; { iii. Sets up the remaining parameters for CIRCLE, including the initial
; displacement for the first 'arc' (a straight line in fact). }
; { iv. Jumps to #R$2420 to use the arc-drawing loop. }
; LIST#
; .
; Parts i. to iii. will now be explained in turn.
; .
; i. The radius, say Z', is obtained from the calculator stack. Its modulus Z
; is formed and used from now on. If Z is less than 1, it is deleted from the
; stack and the point X,Y is plotted by a jump to PLOT.
@refs=$1C0D
@label=CIRCLE
c$2320 RST $18       ; Get the present character.
 $2321 CP ","        ; Test for comma.
 $2323 JP NZ,$1C8A   ; If not so, report the error.
 $2326 RST $20       ; Get next character (the radius).
 $2327 CALL $1C82    ; Radius to calculator stack.
 $232A CALL $1BEE    ; Move to consider next statement if checking syntax.
 $232D RST $28       ; Use calculator.
 $232E DEFB $2A      ; #R$346A: X, Y, Z
 $232F DEFB $3D      ; #R$3297: Z is re-stacked; its exponent is therefore
                     ; available.
 $2330 DEFB $38      ; #R$369B
 $2331 LD A,(HL)     ; Get exponent of radius.
 $2332 CP $81        ; Test whether radius less than 1.
 $2334 JR NC,$233B   ; If not, jump.
 $2336 RST $28       ; If less, delete it from the stack.
 $2337 DEFB $02      ; #R$33A1: X, Y
 $2338 DEFB $38      ; #R$369B
 $2339 JR $22DC      ; Just plot the point X, Y.
; ii. 2#pi is stored in mem-5 and #R$247D is called. This subroutine stores in
; the #REGb register the number of arcs required for the circle, viz. A=4*INT
; (#pi*SQR Z/4)+4, hence 4, 8, 12, etc., up to a maximum of 32. It also stores
; in mem-0 to mem-4 the quantities 2#pi/A, SIN(#pi/A), 0, COS (2#pi/A) and SIN
; (2#pi/A).
@label=C_R_GRE_1
*$233B RST $28       ;
 $233C DEFB $A3      ; #R$341B(stk_pi_2): X, Y, Z, #pi/2
 $233D DEFB $38      ; #R$369B
 $233E LD (HL),$83   ; Now increase exponent to &83, changing #pi/2 into 2#pi.
 $2340 RST $28       ; X, Y, Z, 2#pi.
 $2341 DEFB $C5      ; #R$342D(st_mem_5): (2#pi is copied to mem-5)
 $2342 DEFB $02      ; #R$33A1: X, Y, Z
 $2343 DEFB $38      ; #R$369B
 $2344 CALL $247D    ; Set the initial parameters.
; iii. A test is made to see whether the initial 'arc' length is less than 1.
; If it is, a jump is made simply to plot X, Y. Otherwise, the parameters are
; set: X+Z and X-Z*SIN (#pi/A) are stacked twice as start and end point, and
; copied to #SYSVAR(COORDS) as well; zero and 2*Z*SIN (#pi/A) are stored in
; mem-1 and mem-2 as initial increments, giving as first 'arc' the vertical
; straight line joining X+Z, y-Z*SIN (#pi/A) and X+Z, Y+Z*SIN (#pi/A). The
; arc-drawing loop at #R$2420 will ensure that all subsequent points remain on
; the same circle as these two points, with incremental angle 2#pi/A. But it is
; clear that these 2 points in fact subtend this angle at the point X+Z*(1-COS
; (#pi/A)), Y not at X, Y. Hence the end points of each arc of the circle are
; displaced right by an amount 2*(1-COS (#pi/A)), which is less than half a
; pixel, and rounds to one pixel at most.
 $2347 PUSH BC       ; Save the arc-count in #REGb.
 $2348 RST $28       ; X, Y, Z
 $2349 DEFB $31      ; #R$33C0: X, Y, Z, Z
 $234A DEFB $E1      ; #R$340F(get_mem_1): X, Y, Z, Z, SIN (#pi/A)
 $234B DEFB $04      ; #R$30CA: X, Y, Z, Z*SIN (#pi/A)
 $234C DEFB $38      ; #R$369B
 $234D LD A,(HL)     ; {Z*SIN (#pi/A) is half the initial 'arc' length; it is
 $234E CP $80        ; tested to see whether it is less than 0.5.}
 $2350 JR NC,$235A   ; If not, the jump is made.
 $2352 RST $28       ;
 $2353 DEFB $02      ; #R$33A1: X, Y, Z
 $2354 DEFB $02      ; #R$33A1: X, Y
 $2355 DEFB $38      ; #R$369B
 $2356 POP BC        ; Clear the machine stack.
 $2357 JP $22DC      ; Jump to plot X, Y.
@label=C_ARC_GE1
*$235A RST $28       ; X, Y, Z, Z*SIN (#pi/A)
 $235B DEFB $C2      ; #R$342D(st_mem_2): (Z*SIN (#pi/A) to mem-2 for now)
 $235C DEFB $01      ; #R$343C: X, Y, Z*SIN (#pi/A), Z
 $235D DEFB $C0      ; #R$342D(st_mem_0): X, Y, Z*SIN (#pi/A), Z (Z is copied
                     ; to mem-0)
 $235E DEFB $02      ; #R$33A1: X, Y, Z*SIN (#pi/A)
 $235F DEFB $03      ; #R$300F: X, Y-Z*SIN (#pi/A)
 $2360 DEFB $01      ; #R$343C: Y-Z*SIN (#pi/A), X
 $2361 DEFB $E0      ; #R$340F(get_mem_0): Y-Z*SIN (#pi/A), X, Z
 $2362 DEFB $0F      ; #R$3014: Y-Z*SIN (#pi/A), X+Z
 $2363 DEFB $C0      ; #R$342D(st_mem_0): (X+Z is copied to mem-0)
 $2364 DEFB $01      ; #R$343C: X+Z, Y-Z*SIN (#pi/A)
 $2365 DEFB $31      ; #R$33C0: X+Z, Y-Z*SIN (#pi/A), Y-Z*SIN (#pi/A)
 $2366 DEFB $E0      ; #R$340F(get_mem_0): sa, sb, sb, sa
 $2367 DEFB $01      ; #R$343C: sa, sb, sa, sb
 $2368 DEFB $31      ; #R$33C0: sa, sb, sa, sb, sb
 $2369 DEFB $E0      ; #R$340F(get_mem_0): sa, sb, sa, sb, sb, sa
 $236A DEFB $A0      ; #R$341B(stk_zero): sa, sb, sa, sb, sb, sa, 0
 $236B DEFB $C1      ; #R$342D(st_mem_1): (mem-1 is set to zero)
 $236C DEFB $02      ; #R$33A1: sa, sb, sa, sb, sb, sa
 $236D DEFB $38      ; #R$369B
; (Here sa denotes X+Z and sb denotes Y-Z*SIN (#pi/A).)
 $236E INC (IY+$62)  ; Incrementing the exponent byte of #R$5C9C(mem-2) sets
                     ; mem-2 to 2*Z*SIN(#pi/A).
 $2371 CALL $1E94    ; {The last value X+Z is moved from the stack to #REGa and
 $2374 LD L,A        ; copied to #REGl.}
 $2375 PUSH HL       ; It is saved in #REGhl.
 $2376 CALL $1E94    ; {Y-Z*SIN (#pi/A) goes from the stack to #REGa and is
 $2379 POP HL        ; copied to #REGh. #REGhl now holds the initial point.
 $237A LD H,A        ; }
 $237B LD ($5C7D),HL ; It is copied to #SYSVAR(COORDS).
 $237E POP BC        ; The arc-count is restored.
 $237F JP $2420      ; The jump is made to #R$2420.
; (The stack now holds X+Z, Y-Z*SIN (#pi/A), Y-Z*SIN (#pi/A), X+Z.)

; THE 'DRAW' COMMAND ROUTINE
;
; The address of this routine is found in the #R$1AD2(parameter table).
; .
; This routine is entered with the co-ordinates of a point X0, Y0, say, in
; #SYSVAR(COORDS). If only two parameters X, Y are given with the DRAW command,
; it draws an approximation to a straight line from the point X0, Y0 to X0+X,
; Y0+Y. If a third parameter G is given, it draws an approximation to a
; circular arc from X0, Y0 to X0+X, Y0+Y turning anti-clockwise through an
; angle G radians.
; .
; The routine has four parts:
; .
; #LIST
; { i. Just draws a line if only 2 parameters are given or if the diameter of
; the implied circle is less than 1. }
; { ii. Calls #R$247D to set the first parameters. }
; { iii. Sets up the remaining parameters, including the initial displacements
; for the first arc. }
; { iv. Enters the arc-drawing loop and draws the arc as a series of smaller
; arcs approximated by straight lines, calling the line-drawing subroutine at
; #R$24B7 as necessary. }
; LIST#
; .
; Two subroutines, #R$247D and #R$24B7, follow the main routine. The above 4
; parts of the main routine will now be treated in turn.
; .
; i. If there are only 2 parameters, a jump is made to #R$2477. A line is also
; drawn if the quantity Z=(ABS X+ABS Y)/ABS SIN(G/2) is less than 1. Z lies
; between 1 and 1.5 times the diameter of the implied circle. In this section
; mem-0 is set to SIN (G/2), mem-1 to Y, and mem-5 to G.
@refs=$1C0D
@label=DRAW
c$2382 RST $18       ; Get the current character.
 $2383 CP ","        ; {If it is a comma, then jump.
 $2385 JR Z,$238D    ; }
 $2387 CALL $1BEE    ; Move on to next statement if checking syntax.
 $238A JP $2477      ; Jump to just draw the line.
@label=DR_3_PRMS
*$238D RST $20       ; Get next character (the angle).
 $238E CALL $1C82    ; Angle to calculator stack.
 $2391 CALL $1BEE    ; Move on to next statement if checking syntax.
 $2394 RST $28       ; X, Y, G are on the stack.
 $2395 DEFB $C5      ; #R$342D(st_mem_5): (G is copied to mem-5)
 $2396 DEFB $A2      ; #R$341B(stk_half): X, Y, G, 0.5
 $2397 DEFB $04      ; #R$30CA: X, Y, G/2
 $2398 DEFB $1F      ; #R$37B5: X, Y, SIN (G/2)
 $2399 DEFB $31      ; #R$33C0: X, Y, SIN (G/2), SIN (G/2)
 $239A DEFB $30      ; #R$3501: X, Y, SIN (G/2), (0/1)
 $239B DEFB $30      ; #R$3501: X, Y, SIN (G/2), (1/0)
 $239C DEFB $00      ; #R$368F: X, Y, SIN (G/2)
 $239D DEFB $06      ; to #R$23A3 (if SIN (G/2)=0 i.e. G=2#piN just draw a
                     ; straight line).
 $239E DEFB $02      ; #R$33A1: X, Y
 $239F DEFB $38      ; #R$369B
 $23A0 JP $2477      ; Line X0, Y0 to X0+X, Y0+Y.
@label=DR_SIN_NZ
 $23A3 DEFB $C0      ; #R$342D(st_mem_0): (SIN (G/2) is copied to mem-0)
 $23A4 DEFB $02      ; #R$33A1: X, Y are now on the stack.
 $23A5 DEFB $C1      ; #R$342D(st_mem_1): (Y is copied to mem-1).
 $23A6 DEFB $02      ; #R$33A1: X
 $23A7 DEFB $31      ; #R$33C0: X, X
 $23A8 DEFB $2A      ; #R$346A: X, X' (X'=ABS X)
 $23A9 DEFB $E1      ; #R$340F(get_mem_1): X, X', Y
 $23AA DEFB $01      ; #R$343C: X, Y, X'
 $23AB DEFB $E1      ; #R$340F(get_mem_1): X, Y, X', Y
 $23AC DEFB $2A      ; #R$346A: X, Y, X', Y' (Y'=ABS Y)
 $23AD DEFB $0F      ; #R$3014: X, Y, X'+Y'
 $23AE DEFB $E0      ; #R$340F(get_mem_0): X, Y, X'+Y', SIN (G/2)
 $23AF DEFB $05      ; #R$31AF: X, Y, (X'+Y')/SIN (G/2)=Z', say
 $23B0 DEFB $2A      ; #R$346A: X, Y, Z (Z=ABS Z')
 $23B1 DEFB $E0      ; #R$340F(get_mem_0): X, Y, Z, SIN (G/2)
 $23B2 DEFB $01      ; #R$343C: X, Y, SIN (G/2), Z
 $23B3 DEFB $3D      ; #R$3297: (Z is re-stacked to make sure that its exponent
                     ; is available).
 $23B4 DEFB $38      ; #R$369B
 $23B5 LD A,(HL)     ; Get exponent of Z.
 $23B6 CP $81        ; {If Z is greater than or equal to 1, jump.
 $23B8 JR NC,$23C1   ; }
 $23BA RST $28       ; X, Y, SIN (G/2), Z
 $23BB DEFB $02      ; #R$33A1: X, Y, SIN (G/2)
 $23BC DEFB $02      ; #R$33A1: X, Y
 $23BD DEFB $38      ; #R$369B
 $23BE JP $2477      ; Just draw the line from X0, Y0 to X0+X, Y0+Y.
; ii. Just calls #R$247D. This subroutine saves in the #REGb register the
; number of shorter arcs required for the complete arc, viz. A=4*INT (G'*SQR
; Z/8)+4 (where G'=ABS G), or 252 if this expression exceeds 252 (as can happen
; with a large chord and a small angle). So A is a multiple of 4 from 4 to 252.
; The subroutine also stores in mem-0 to mem-4 the quantities G/A, SIN (G/2*A),
; 0, COS (G/A), SIN (G/A).
@label=DR_PRMS
*$23C1 CALL $247D    ; The subroutine is called.
; iii. Sets up the rest of the parameters as follow. The stack will hold these
; 4 items, reading up to the top: X0+X and Y0+Y as end of last arc; then X0 and
; Y0 as beginning of first arc. Mem-0 will hold X0 and mem-5 Y0. Mem-1 and
; mem-2 will hold the initial displacements for the first arc, U and V; and
; mem-3 and mem-4 will hold COS (G/A) and SIN (G/A) for use in the arc-drawing
; loop.
; .
; The formulae for U and V can be explained as follows. Instead of stepping
; along the final chord, of length L, say, with displacements X and Y, we want
; to step along an initial chord (which may be longer) of length L*W, where
; W=SIN (G/2*A)/SIN (G/2), with displacements X*W and Y*W, but turned through
; an angle (G/2-G/2*A), hence with true displacements:
; .
; #LIST
; { U=Y*W*SIN (G/2-G/2*A)+X*W*COS (G/2-G/2*A) }
; { Y=Y*W*COS (G/2-G/2*A)-X*W*SIN (G/2-G/2*A) }
; LIST#
; .
; These formulae can be checked from a diagram, using the normal expansion of
; COS (P-Q) and SIN (P-Q), where Q=G/2-G/2*A.
 $23C4 PUSH BC       ; Save the arc-counter in #REGb.
 $23C5 RST $28       ; X, Y, SIN(G/2), Z
 $23C6 DEFB $02      ; #R$33A1: X, Y, SIN(G/2)
 $23C7 DEFB $E1      ; #R$340F(get_mem_1): X, Y, SIN(G/2), SIN(G/2*A)
 $23C8 DEFB $01      ; #R$343C: X, Y, SIN(G/2*A), SIN(G/2)
 $23C9 DEFB $05      ; #R$31AF: X, Y, SIN(G/2*A)/SIN(G/2)=W
 $23CA DEFB $C1      ; #R$342D(st_mem_1): (W is copied to mem-1).
 $23CB DEFB $02      ; #R$33A1: X, Y
 $23CC DEFB $01      ; #R$343C: Y, X
 $23CD DEFB $31      ; #R$33C0: Y, X, X
 $23CE DEFB $E1      ; #R$340F(get_mem_1): Y, X, X, W
 $23CF DEFB $04      ; #R$30CA: Y, X, X*W
 $23D0 DEFB $C2      ; #R$342D(st_mem_2): (X*W is copied to mem-2).
 $23D1 DEFB $02      ; #R$33A1: Y, X
 $23D2 DEFB $01      ; #R$343C: X, Y
 $23D3 DEFB $31      ; #R$33C0: X, Y, Y
 $23D4 DEFB $E1      ; #R$340F(get_mem_1): X, Y, Y, W
 $23D5 DEFB $04      ; #R$30CA: X, Y, Y*W
 $23D6 DEFB $E2      ; #R$340F(get_mem_2): X, Y, Y*W, X*W
 $23D7 DEFB $E5      ; #R$340F(get_mem_5): X, Y, Y*W, X*W,G
 $23D8 DEFB $E0      ; #R$340F(get_mem_0): X, Y, Y*W, X*W, G, G/A
 $23D9 DEFB $03      ; #R$300F: X, Y, Y*W, X*W, G-G/A
 $23DA DEFB $A2      ; #R$341B(stk_half): X, Y, Y*W, X*W, G-G/A, 1/2
 $23DB DEFB $04      ; #R$30CA: X, Y, Y*W, X*W, G/2-G/2*A=F
 $23DC DEFB $31      ; #R$33C0: X, Y, Y*W, X*W, F, F
 $23DD DEFB $1F      ; #R$37B5: X, Y, Y*W, X*W, F, SIN F
 $23DE DEFB $C5      ; #R$342D(st_mem_5): (SIN F is copied to mem-5).
 $23DF DEFB $02      ; #R$33A1: X, Y, Y*W, X*W,F
 $23E0 DEFB $20      ; #R$37AA: X, Y, Y*W, X*W, COS F
 $23E1 DEFB $C0      ; #R$342D(st_mem_0): (COS F is copied to mem-0).
 $23E2 DEFB $02      ; #R$33A1: X, Y, Y*W, X*W
 $23E3 DEFB $C2      ; #R$342D(st_mem_2): (X*W is copied to mem-2).
 $23E4 DEFB $02      ; #R$33A1: X, Y, Y*W
 $23E5 DEFB $C1      ; #R$342D(st_mem_1): (Y*W is copied to mem-1).
 $23E6 DEFB $E5      ; #R$340F(get_mem_5): X, Y, Y*W, SIN F
 $23E7 DEFB $04      ; #R$30CA: X, Y, Y*W*SIN F
 $23E8 DEFB $E0      ; #R$340F(get_mem_0): X, Y, Y*W*SIN F, X*W
 $23E9 DEFB $E2      ; #R$340F(get_mem_2): X, Y, Y*W*SIN F, X*W, COS F
 $23EA DEFB $04      ; #R$30CA: X, Y, Y*W*SIN F, X*W*COS F
 $23EB DEFB $0F      ; #R$3014: X, Y, Y*W*SIN F+X*W*COS F=U
 $23EC DEFB $E1      ; #R$340F(get_mem_1): X, Y, U, Y*W
 $23ED DEFB $01      ; #R$343C: X, Y, Y*W, U
 $23EE DEFB $C1      ; #R$342D(st_mem_1): (U is copied to mem-1)
 $23EF DEFB $02      ; #R$33A1: X, Y, Y*W
 $23F0 DEFB $E0      ; #R$340F(get_mem_0): X, Y, Y*W, COS F
 $23F1 DEFB $04      ; #R$30CA: X, Y, Y*W*COS F
 $23F2 DEFB $E2      ; #R$340F(get_mem_2): X, Y, Y*W*COS F, X*W
 $23F3 DEFB $E5      ; #R$340F(get_mem_5): X, Y, Y*W*COS F, X*W, SIN F
 $23F4 DEFB $04      ; #R$30CA: X, Y, Y*W*COS F, X*W*SIN F
 $23F5 DEFB $03      ; #R$300F: X, Y, Y*W*COS F-X*W*SIN F=V
 $23F6 DEFB $C2      ; #R$342D(st_mem_2): (V is copied to mem-2).
 $23F7 DEFB $2A      ; #R$346A: X, Y, V' (V'=ABS V)
 $23F8 DEFB $E1      ; #R$340F(get_mem_1): X, Y, V', U
 $23F9 DEFB $2A      ; #R$346A: X, Y, V', U' (U'=ABS U)
 $23FA DEFB $0F      ; #R$3014: X, Y, U'+V'
 $23FB DEFB $02      ; #R$33A1: X, Y
 $23FC DEFB $38      ; #R$369B: (#REGde now points to U'+V').
 $23FD LD A,(DE)     ; Get exponent of U'+V'.
 $23FE CP $81        ; {If U'+V' is less than 1, just tidy the stack and draw
 $2400 POP BC        ; the line from X0, Y0 to X0+X, Y0+Y.
 $2401 JP C,$2477    ; }
 $2404 PUSH BC       ; {Otherwise, continue with the parameters: X, Y, on the
 $2405 RST $28       ; stack.}
 $2406 DEFB $01      ; #R$343C: Y, X
 $2407 DEFB $38      ; #R$369B
 $2408 LD A,($5C7D)  ; {Get X0 from #SYSVAR(COORDS) into #REGa and so on to the
 $240B CALL $2D28    ; stack.}
 $240E RST $28       ; Y, X, X0
 $240F DEFB $C0      ; #R$342D(st_mem_0): (X0 is copied to mem-0).
 $2410 DEFB $0F      ; #R$3014: Y, X0+X
 $2411 DEFB $01      ; #R$343C: X0+X, Y
 $2412 DEFB $38      ; #R$369B
@keep=$01
@ssub=LD A,($5C7D+$01)
 $2413 LD A,($5C7E)  ; {Get Y0 from #SYSVAR(COORDS) into #REGa and so on to the
 $2416 CALL $2D28    ; stack.}
 $2419 RST $28       ; X0+X, Y, Y0
 $241A DEFB $C5      ; #R$342D(st_mem_5): (Y0 is copied to mem-5).
 $241B DEFB $0F      ; #R$3014: X0+X, Y0+Y
 $241C DEFB $E0      ; #R$340F(get_mem_0): X0+X, Y0+Y, X0
 $241D DEFB $E5      ; #R$340F(get_mem_5): X0+X, Y0+Y, X0, Y0
 $241E DEFB $38      ; #R$369B
 $241F POP BC        ; Restore the arc-counter in #REGb.
; This entry point is used by the routine at #R$2320.
; .
; iv. The arc-drawing loop. This is entered at #R$2439 with the co-ordinates of
; the starting point on top of the stack, and the initial displacements for the
; first arc in mem-1 and mem-2. It uses simple trigonometry to ensure that all
; subsequent arcs will be drawn to points that lie on the same circle as the
; first two, subtending the same angle at the centre. It can be shown that if 2
; points X1, Y1 and X2, Y2 lie on a circle and subtend an angle N at the
; centre, which is also the origin of co-ordinates, then X2=X1*COS N-Y1*SIN N,
; and Y2=X1*SIN N+Y1*COS N. But because the origin is here at the increments,
; say Un=Xn+1-Xn and Vn=Yn+1-Yn, thus achieving the desired result. The stack
; is shown below on the (n+1)th pass through the loop, as Xn and Yn are
; incremented by Un and Vn, after these are obtained from Un-1 and Vn-1. The 4
; values on the top of the stack at #R$2425 are, in DRAW, reading upwards,
; X0+X, Y0+Y, Xn and Yn but to save space these are not shown until #R$2439.
; For the initial values in CIRCLE, see the end of CIRCLE, above. In CIRCLE
; too, the angle G must be taken to be 2#pi.
@label=DRW_STEPS
*$2420 DEC B         ; #REGb counts the passes through the loop.
 $2421 JR Z,$245F    ; Jump when #REGb has reached zero.
 $2423 JR $2439      ; Jump into the loop to start.
@label=ARC_LOOP
*$2425 RST $28       ; (See text above for the stack).
 $2426 DEFB $E1      ; #R$340F(get_mem_1): Un-1
 $2427 DEFB $31      ; #R$33C0: Un-1, Un-1
 $2428 DEFB $E3      ; #R$340F(get_mem_3): Un-1, Un-1, COS(G/A)
 $2429 DEFB $04      ; #R$30CA: Un-1, Un-1*COS(G/A)
 $242A DEFB $E2      ; #R$340F(get_mem_2): Un-1, Un-1*COS(G/A), Vn-1
 $242B DEFB $E4      ; #R$340F(get_mem_4): Un-1, Un-1*COS(G/A), Vn-1, SIN(G/A)
 $242C DEFB $04      ; #R$30CA: Un-1, Un-1*COS(G/A), Vn-1*SIN(G/A)
 $242D DEFB $03      ; #R$300F: Un-1, Un-1*COS(G/A)-Vn-1*SIN(G/A)=Un
 $242E DEFB $C1      ; #R$342D(st_mem_1): (Un is copied to mem-1).
 $242F DEFB $02      ; #R$33A1: Un-1
 $2430 DEFB $E4      ; #R$340F(get_mem_4): Un-1, SIN(G/A)
 $2431 DEFB $04      ; #R$30CA: Un-1*SIN(G/A)
 $2432 DEFB $E2      ; #R$340F(get_mem_2): Un-1*SIN(G/A), Vn-1
 $2433 DEFB $E3      ; #R$340F(get_mem_3): Un-1*SIN(G/A), Vn-1, COS(G/A)
 $2434 DEFB $04      ; #R$30CA: Un-1*SIN(G/A), Vn-1*COS(G/A)
 $2435 DEFB $0F      ; #R$3014: Un-1*SIN(G/A)+Vn-1*COS(G/A)=Vn
 $2436 DEFB $C2      ; #R$342D(st_mem_2): (Vn is copied to mem-2).
 $2437 DEFB $02      ; #R$33A1: (As noted in the text, the stack in fact holds
                     ; X0+X, Y0+Y, Xn and Yn).
 $2438 DEFB $38      ; #R$369B
@label=ARC_START
*$2439 PUSH BC       ; Save the arc-counter.
 $243A RST $28       ; X0+X, Y0+y, Xn, Yn
 $243B DEFB $C0      ; #R$342D(st_mem_0): (Yn is copied to mem-0).
 $243C DEFB $02      ; #R$33A1: X0+X, Y0+Y, Xn
 $243D DEFB $E1      ; #R$340F(get_mem_1): X0+X, Y0+Y, Xn, Un
 $243E DEFB $0F      ; #R$3014: X0+X, Y0+Y, Xn+Un=Xn+1
 $243F DEFB $31      ; #R$33C0: X0+X, Y0+Y, Xn+1, Xn+1
 $2440 DEFB $38      ; #R$369B
 $2441 LD A,($5C7D)  ; {Next Xn', the approximate value of Xn reached by the
 $2444 CALL $2D28    ; line-drawing subroutine is copied from #SYSVAR(COORDS)
                     ; to #REGa and hence to the stack.}
 $2447 RST $28       ; X0+X, Y0+Y, Xn+1, Xn'
 $2448 DEFB $03      ; #R$300F: X0+X, Y0+Y, Xn+1, Xn+1, Xn'-Xn'=Un'
 $2449 DEFB $E0      ; #R$340F(get_mem_0): X0+X, Y0+Y, Xn+1, Un', Yn
 $244A DEFB $E2      ; #R$340F(get_mem_2): X0+X, Y0+Y, Xn+1, Un', Yn, Vn
 $244B DEFB $0F      ; #R$3014: X0+X, Y0+Y, Xn+1, Un', Yn+Vn=Yn+1
 $244C DEFB $C0      ; #R$342D(st_mem_0): (Yn+1 is copied to mem-0).
 $244D DEFB $01      ; #R$343C: X0+X, Y0+Y, Xn+1, Yn+1, Un'
 $244E DEFB $E0      ; #R$340F(get_mem_0): X0+X, Y0+Y, Xn+1, Yn+1, Un', Yn+1
 $244F DEFB $38      ; #R$369B
@keep=$01
@ssub=LD A,($5C7D+$01)
 $2450 LD A,($5C7E)  ; {Yn', approximate like Xn', is copied from
 $2453 CALL $2D28    ; #SYSVAR(COORDS) to #REGa and hence to the stack.}
 $2456 RST $28       ; X0+X, Y0+Y, Xn+1, Yn+1, Un', Yn+1, Yn'
 $2457 DEFB $03      ; #R$300F: X0+X, Y0+Y, Xn+1, Yn+1, Un', Vn'
 $2458 DEFB $38      ; #R$369B
 $2459 CALL $24B7    ; The next 'arc' is drawn.
 $245C POP BC        ; The arc-counter is restored.
 $245D DJNZ $2425    ; {Jump if more arcs to draw.
@label=ARC_END
*$245F RST $28       ; }
 $2460 DEFB $02      ; {#R$33A1: The co-ordinates of the end of the last arc
 $2461 DEFB $02      ; that was drawn are now deleted from the stack.}
 $2462 DEFB $01      ; #R$343C: Y0+Y, X0+X
 $2463 DEFB $38      ; #R$369B
 $2464 LD A,($5C7D)  ; {The X-co-ordinate of the end of the last arc that was
 $2467 CALL $2D28    ; drawn, say Xz', is copied from #SYSVAR(COORDS) to the
                     ; stack.}
 $246A RST $28       ;
 $246B DEFB $03      ; #R$300F: Y0+Y, X0+X-Xz'
 $246C DEFB $01      ; #R$343C: X0+X-Xz', Y0+Y
 $246D DEFB $38      ; #R$369B
@keep=$01
@ssub=LD A,($5C7D+$01)
 $246E LD A,($5C7E)  ; {The Y-co-ordinate is obtained from #SYSVAR(COORDS) and
 $2471 CALL $2D28    ; stacked.}
 $2474 RST $28       ; X0+X-Xz', Y0+Y, Yz'
 $2475 DEFB $03      ; #R$300F: X0+X-Xz', Y0+Y-Yz'
 $2476 DEFB $38      ; #R$369B
@label=LINE_DRAW
*$2477 CALL $24B7    ; The final arc is drawn to reach X0+X, Y0+Y (or close the
                     ; circle).
 $247A JP $0D4D      ; Exit, setting temporary colours.

; THE 'INITIAL PARAMETERS' SUBROUTINE
;
; This subroutine is called by both #R$2320 and #R$2382 to set their initial
; parameters. It is called by #R$2320 with X, Y and the radius Z on the top of
; the stack, reading upwards. It is called by #R$2382 with its own X, Y, SIN
; (G/2) and Z, as defined in #R$2382 i., on the top of the stack. In what
; follows the stack is only shown from Z upwards.
; .
; The subroutine returns in #REGb the arc-count A as explained in both #R$2320
; and #R$2382, and in mem-0 to mem-5 the quantities G/A, SIN (G/2*A), 0, COS
; (G/A), SIN (G/A) and G. For a circle, G must be taken to be equal to 2#pi.
;
; O:B Arc count
@label=CD_PRMS1
c$247D RST $28       ; Z
 $247E DEFB $31      ; #R$33C0: Z, Z
 $247F DEFB $28      ; #R$384A: Z, SQR Z
 $2480 DEFB $34      ; {#R$33C6: Z, SQR Z, 2
 $2481 DEFB $32,$00  ; }
 $2483 DEFB $01      ; #R$343C: Z, 2, SQR Z
 $2484 DEFB $05      ; #R$31AF: Z, 2/SQR Z
 $2485 DEFB $E5      ; #R$340F(get_mem_5): Z, 2/SQR Z, G
 $2486 DEFB $01      ; #R$343C: Z, G, 2/SQR Z
 $2487 DEFB $05      ; #R$31AF: Z, G*SQR Z/2
 $2488 DEFB $2A      ; #R$346A: Z, G'*SQR Z/2 (G'=ABS G)
 $2489 DEFB $38      ; #R$369B: Z, G'*SQR Z/2=A1, say
 $248A CALL $2DD5    ; A1 to #REGa from the stack, if possible.
 $248D JR C,$2495    ; If A1 rounds to 256 or more, use 252.
 $248F AND $FC       ; 4*INT (A1/4) to #REGa.
 $2491 ADD A,$04     ; Add 4, giving the arc-count A.
 $2493 JR NC,$2497   ; Jump if still under 256.
@label=USE_252
*$2495 LD A,$FC      ; Here, just use 252.
@label=DRAW_SAVE
*$2497 PUSH AF       ; Now save the arc-count.
 $2498 CALL $2D28    ; Copy it to calculator stack too.
 $249B RST $28       ; Z, A
 $249C DEFB $E5      ; #R$340F(get_mem_5): Z, A, G
 $249D DEFB $01      ; #R$343C: Z, G, A
 $249E DEFB $05      ; #R$31AF: Z, G/A
 $249F DEFB $31      ; #R$33C0: Z, G/A, G/A
 $24A0 DEFB $1F      ; #R$37B5: Z, G/A, SIN (G/A)
 $24A1 DEFB $C4      ; #R$342D(st_mem_4): (SIN (G/A) is copied to mem-4)
 $24A2 DEFB $02      ; #R$33A1: Z, G/A
 $24A3 DEFB $31      ; #R$33C0: Z, G/A, G/A
 $24A4 DEFB $A2      ; #R$341B(stk_half): Z, G/A, G/A, 0.5
 $24A5 DEFB $04      ; #R$30CA: Z, G/A, G/2*A
 $24A6 DEFB $1F      ; #R$37B5: Z, G/A, SIN (G/2*A)
 $24A7 DEFB $C1      ; #R$342D(st_mem_1): (SIN (G/2*A) is copied to mem-1)
 $24A8 DEFB $01      ; #R$343C: Z, SIN (G/2*A), G/A
 $24A9 DEFB $C0      ; #R$342D(st_mem_0): (G/A is copied to mem-0)
 $24AA DEFB $02      ; #R$33A1: Z, SIN (G/2*A)=S
 $24AB DEFB $31      ; #R$33C0: Z, S, S
 $24AC DEFB $04      ; #R$30CA: Z, S*S
 $24AD DEFB $31      ; #R$33C0: Z, S*S, S*S
 $24AE DEFB $0F      ; #R$3014: Z, 2*S*S
 $24AF DEFB $A1      ; #R$341B(stk_one): Z, 2*S*S, 1
 $24B0 DEFB $03      ; #R$300F: Z, 2*S*S-1
 $24B1 DEFB $1B      ; #R$346E: Z, 1-2*S*S=COS (G/A)
 $24B2 DEFB $C3      ; #R$342D(st_mem_3): (COS (G/A) is copied to mem-3)
 $24B3 DEFB $02      ; #R$33A1: Z
 $24B4 DEFB $38      ; #R$369B
 $24B5 POP BC        ; Restore the arc-count to #REGb.
 $24B6 RET           ; Finished.

; THE 'LINE-DRAWING' SUBROUTINE
;
; This subroutine is called by #R$2382 to draw an approximation to a straight
; line from the point X0, Y0 held in #SYSVAR(COORDS) to the point X0+X, Y0+Y,
; where the increments X and Y are on the top of the calculator stack. The
; subroutine was originally intended for the ZX80 and ZX81 8K ROM, and it is
; described in a BASIC program on page 121 of the ZX81 manual.
; .
; The method is to intersperse as many horizontal or vertical steps as are
; needed among a basic set of diagonal steps, using an algorithm that spaces
; the horizontal or vertical steps as evenly as possible.
@label=DRAW_LINE
c$24B7 CALL $2307    ; ABS Y to #REGb; ABS X to #REGc; SGN Y to #REGd; SGN X to
                     ; #REGe.
 $24BA LD A,C        ; {Jump if ABS X is greater than or equal to ABS Y, so
 $24BB CP B          ; that the smaller goes to #REGl, and the larger (later)
 $24BC JR NC,$24C4   ; goes to #REGh.
 $24BE LD L,C        ; }
 $24BF PUSH DE       ; Save diagonal step (+/-1,+/-1) in #REGde.
 $24C0 XOR A         ; {Insert a vertical step (+/-1,0) into #REGde (#REGd
 $24C1 LD E,A        ; holds SGN Y).}
 $24C2 JR $24CB      ; Now jump to set #REGh.
@label=DL_X_GE_Y
*$24C4 OR C          ; {Return if ABS X and ABS Y are both zero.
 $24C5 RET Z         ; }
 $24C6 LD L,B        ; The smaller (ABS Y here) goes to #REGl.
 $24C7 LD B,C        ; ABS X to #REGb here, for #REGh.
 $24C8 PUSH DE       ; Save the diagonal step here too.
 $24C9 LD D,$00      ; Horizontal step (0,+/-1) to #REGde here.
@label=DL_LARGER
*$24CB LD H,B        ; Larger of ABS X, ABS Y to #REGh now.
; The algorithm starts here. The larger of ABS X and ABS Y, say #REGh, is put
; into #REGa and reduced to INT (#REGh/2). The #REGh-#REGl horizontal or
; vertical steps and #REGl diagonal steps are taken (where #REGl is the smaller
; of ABS X and ABS Y) in this way: #REGl is added to #REGa; if #REGa now equals
; or exceeds #REGh, it is reduced by #REGh and a diagonal step is taken;
; otherwise a horizontal or vertical step is taken. This is repeated #REGh
; times (#REGb also holds #REGh). Note that meanwhile the exchange registers
; #REGh' and #REGl' are used to hold #SYSVAR(COORDS).
 $24CC LD A,B        ; #REGb to #REGa as well as to #REGh.
 $24CD RRA           ; #REGa starts at INT (#REGh/2).
@label=D_L_LOOP
*$24CE ADD A,L       ; #REGl is added to #REGa.
 $24CF JR C,$24D4    ; If 256 or more, jump - diagonal step.
 $24D1 CP H          ; {If #REGa is less than #REGh, jump for horizontal or
 $24D2 JR C,$24DB    ; vertical step.}
@label=D_L_DIAG
*$24D4 SUB H         ; Reduce #REGa by #REGh.
 $24D5 LD C,A        ; Restore it to #REGc.
 $24D6 EXX           ; Now use the exchange resisters.
 $24D7 POP BC        ; Diagonal step to #REGbc'.
 $24D8 PUSH BC       ; Save it too.
 $24D9 JR $24DF      ; Jump to take the step.
@label=D_L_HR_VT
*$24DB LD C,A        ; Save #REGa (unreduced) in #REGc.
 $24DC PUSH DE       ; Step to stack briefly.
 $24DD EXX           ; Get exchange registers.
 $24DE POP BC        ; Step to #REGbc' now.
@label=D_L_STEP
*$24DF LD HL,($5C7D) ; Now take the step: first, #SYSVAR(COORDS) to #REGhl' as
                     ; the start point.
 $24E2 LD A,B        ; Y-step from #REGb' to #REGa.
 $24E3 ADD A,H       ; Add in #REGh'.
 $24E4 LD B,A        ; Result to #REGb'.
 $24E5 LD A,C        ; {Now the X-step; it will be tested for range (Y will be
 $24E6 INC A         ; tested in #R$22DC).}
 $24E7 ADD A,L       ; {Add #REGl' to #REGc' in #REGa, jump on carry for
 $24E8 JR C,$24F7    ; further test.}
 $24EA JR Z,$24F9    ; Zero after no carry denotes X-position -1, out of range.
@label=D_L_PLOT
*$24EC DEC A         ; Restore true value to #REGa.
 $24ED LD C,A        ; Value to #REGc' for plotting.
 $24EE CALL $22E5    ; Plot the step.
 $24F1 EXX           ; Restore main registers.
 $24F2 LD A,C        ; #REGc back to #REGa to continue algorithm.
 $24F3 DJNZ $24CE    ; Loop back for #REGb steps (i.e. #REGh steps).
 $24F5 POP DE        ; Clear machine stack.
 $24F6 RET           ; Finished.
@label=D_L_RANGE
*$24F7 JR Z,$24EC    ; Zero after carry denotes X-position 255, in range.
; This entry point is used by the routines at #R$22AA and #R$2314.
; .
; Report B - Integer out of range.
@label=REPORT_B_3
*$24F9 RST $08       ; {Call the error handling routine.
 $24FA DEFB $0A      ; }

; THE 'SCANNING' SUBROUTINE
;
; Used by the routines at #R$04AA, #R$1C56, #R$1C79, #R$1E27, #R$1F60, #R$1FFC,
; #R$25E8, #R$27BD and #R$35DE.
; .
; This subroutine is used to produce an evaluation result of the 'next
; expression'.
; .
; The result is returned as the 'last value' on the calculator stack. For a
; numerical result, the last value will be the actual floating point number.
; However, for a string result the last value will consist of a set of
; parameters. The first of the five bytes is unspecified, the second and third
; bytes hold the address of the start of the string and the fourth and fifth
; bytes hold the length of the string.
; .
; Bit 6 of #SYSVAR(FLAGS) is set for a numeric result and reset for a string
; result.
; .
; When a next expression consists of only a single operand (e.g. 'A', 'RND',
; 'A$(4,3 TO 7)'), then the last value is simply the value that is obtained
; from evaluating the operand.
; .
; However when the next expression contains a function and an operand (e.g.
; 'CHR$ A', 'NOT A', 'SIN 1'), the operation code of the function is stored on
; the machine stack until the last value of the operand has been calculated.
; This last value is then subjected to the appropriate operation to give a new
; last value.
; .
; In the case of there being an arithmetic or logical operation to be performed
; (e.g. 'A+B', 'A*B', 'A=B'), then both the last value of the first argument
; and the operation code have to be kept until the last value of the second
; argument has been found. Indeed the calculation of the last value of the
; second argument may also involve the storing of last values and operation
; codes whilst the calculation is being performed.
; .
; It can therefore be shown that as a complex expression is evaluated (e.g.
; 'CHR$ (T+A-26*INT ((T+A)/26)+65)'), a hierarchy of operations yet to be
; performed is built up until the point is reached from which it must be
; dismantled to produce the final last value.
; .
; Each operation code has associated with it an appropriate priority code and
; operations of higher priority are always performed before those of lower
; priority.
; .
; The subroutine begins with the #REGa register being set to hold the first
; character of the expression and a starting priority marker - zero - being put
; on the machine stack.
@label=SCANNING
c$24FB RST $18       ; The first character is fetched.
 $24FC LD B,$00      ; The starting priority marker.
 $24FE PUSH BC       ; It is stacked.
; This entry point is used by the routines at #R$25AF and #R$26C9.
@label=S_LOOP_1
*$24FF LD C,A        ; The main re-entry point.
 $2500 LD HL,$2596   ; {Index into the #R$2596(scanning function table) with
 $2503 CALL $16DC    ; the code in #REGc.}
 $2506 LD A,C        ; Restore the code to #REGa.
 $2507 JP NC,$2684   ; Jump if code not found in table.
 $250A LD B,$00      ; {Use the entry found in the table to build up the
 $250C LD C,(HL)     ; required address in #REGhl, and jump to it.
 $250D ADD HL,BC     ;
 $250E JP (HL)       ; }

; THE 'SCANNING QUOTES' SUBROUTINE
;
; This subroutine is used by #R$25B3 to check that every string quote is
; matched by another one.
;
;   BC Current string length counter
; O:BC Updated string length counter
; O:F Zero flag set if two consecutive '"' characters are found
@label=S_QUOTE_S
c$250F CALL $0074    ; Point to the next character.
 $2512 INC BC        ; Increase the length count by one.
 $2513 CP $0D        ; Is it a carriage return?
 $2515 JP Z,$1C8A    ; Report the error if so.
 $2518 CP "\""       ; Is it another '"'?
 $251A JR NZ,$250F   ; Loop back if it is not.
 $251C CALL $0074    ; Point to next character.
 $251F CP "\""       ; Set zero flag if it is another '"'.
 $2521 RET           ; Finished.

; THE 'SCANNING TWO CO-ORDINATES' SUBROUTINE
;
; This subroutine is called by #R$2668, #R$2672 and #R$267B to make sure the
; required two co-ordinates are given in their proper form.
;
; O:F Zero flag set if checking syntax
@label=S_2_COORD
c$2522 RST $20       ; Fetch the next character.
 $2523 CP "("        ; Is it a '('?
 $2525 JR NZ,$252D   ; Report the error if it is not.
 $2527 CALL $1C79    ; Co-ordinates to calculator stack.
 $252A RST $18       ; Fetch the current character.
 $252B CP ")"        ; Is it a ')'?
@label=S_RPORT_C
*$252D JP NZ,$1C8A   ; Report the error if it is not.
; This routine continues into #R$2530.

; THE 'SYNTAX-Z' SUBROUTINE
;
; Used by the routines at #R$0605, #R$17F9, #R$1BB3, #R$1BEE, #R$1C22, #R$1CBE,
; #R$1CDE, #R$1CF0, #R$1DEC, #R$1E27, #R$1F60, #R$1FC3, #R$1FC9, #R$204E,
; #R$2089, #R$21B9, #R$25B3, #R$25F8, #R$2627, #R$268D, #R$26C9, #R$27BD,
; #R$28B2, #R$2A52, #R$2ACC, #R$2AF4 and #R$2C02.
; .
; The routine at #R$2522 continues here.
; .
; This subroutine is called 31 times, with a saving of just one byte each call.
; A simple test of bit 7 of #SYSVAR(FLAGS) will give the zero flag reset during
; execution and set during syntax checking.
;
; O:F Zero flag set if checking syntax
@label=SYNTAX_Z
c$2530 BIT 7,(IY+$01) ; Test bit 7 of #SYSVAR(FLAGS).
 $2534 RET            ; Finished.

; THE 'SCANNING SCREEN$' SUBROUTINE
;
; Used by the routine at #R$2668.
; .
; This subroutine is used to find the character that appears at line x, column
; y of the screen. It only searches the character set 'pointed to' by
; #SYSVAR(CHARS).
; .
; Note: this is normally the characters &20 (space) to &7F (#CHR(169)) although
; the user can alter #SYSVAR(CHARS) to match for other characters, including
; user-defined graphics.
@label=S_SCRN_S
@label=S_SCRN_S
c$2535 CALL $2307    ; x to #REGc, y to #REGb; 0<=x<=23; 0<=y<=31.
 $2538 LD HL,($5C36) ; {#SYSVAR(CHARS) plus &0100 gives #REGhl pointing to the
@keep
 $253B LD DE,$0100   ; character set.
 $253E ADD HL,DE     ; }
 $253F LD A,C        ; x is copied to #REGa.
 $2540 RRCA          ; {The number 32*(x mod 8)+y is formed in #REGa and copied
 $2541 RRCA          ; to #REGe. This is the low byte of the required screen
 $2542 RRCA          ; address.
 $2543 AND $E0       ;
 $2545 XOR B         ;
 $2546 LD E,A        ; }
 $2547 LD A,C        ; x is copied to #REGa again.
 $2548 AND $18       ; {Now the number 64+8*INT (x/8) is inserted into #REGd.
 $254A XOR $40       ; #REGde now holds the screen address.
 $254C LD D,A        ; }
 $254D LD B,$60      ; #REGb counts the 96 characters.
@label=S_SCRN_LP
*$254F PUSH BC       ; Save the count.
 $2550 PUSH DE       ; And the screen pointer.
 $2551 PUSH HL       ; And the character set pointer.
 $2552 LD A,(DE)     ; Get first row of screen character.
 $2553 XOR (HL)      ; Match with row from character set.
 $2554 JR Z,$255A    ; Jump if direct match found.
 $2556 INC A         ; Now test for match with inverse character (get &00 in
                     ; #REGa from &FF).
 $2557 JR NZ,$2573   ; Jump if neither match found.
 $2559 DEC A         ; Restore &FF to #REGa.
@label=S_SC_MTCH
*$255A LD C,A        ; Inverse status (&00 or &FF) to #REGc.
 $255B LD B,$07      ; #REGb counts through the other 7 rows.
@label=S_SC_ROWS
*$255D INC D         ; Move #REGde to next row (add &0100).
 $255E INC HL        ; Move #REGhl to next row (i.e. next byte).
 $255F LD A,(DE)     ; Get the screen row.
 $2560 XOR (HL)      ; Match with row from the ROM.
 $2561 XOR C         ; Include the inverse status.
 $2562 JR NZ,$2573   ; Jump if row fails to match.
 $2564 DJNZ $255D    ; Jump back till all rows done.
 $2566 POP BC        ; Discard character set pointer.
 $2567 POP BC        ; And screen pointer.
 $2568 POP BC        ; Final count to #REGbc.
 $2569 LD A,$80      ; Last character code in set plus one.
 $256B SUB B         ; #REGa now holds required code.
@keep
 $256C LD BC,$0001   ; One space is now needed in the work space.
 $256F RST $30       ; Make the space.
 $2570 LD (DE),A     ; Put the character into it.
@bfix=|RET           ;
@bfix=|NOP
 $2571 JR $257D      ; Jump to stack the character.
@label=S_SCR_NXT
*$2573 POP HL        ; Restore character set pointer.
@keep
 $2574 LD DE,$0008   ; {Move it on 8 bytes, to the next character in the set.
 $2577 ADD HL,DE     ; }
 $2578 POP DE        ; Restore the screen pointer.
 $2579 POP BC        ; And the counter.
 $257A DJNZ $254F    ; Loop back for the 96 characters.
@bfix=RET            ;
 $257C LD C,B        ; Stack the empty string (length zero).
@label=S_SCR_STO
@bfix=/:DEFB $00,$00,$00 ;
*$257D JP $2AB2      ; Jump to stack the matching character, or the null string
                     ; if no match is found.
; #IF({fix}<2)||Note: this exit, via #R$2AB2, is a
; #BUG#anythingEqualsSCREEN$xy(mistake) as it leads to 'double storing' of the
; string result (see #R$25DB). The instruction line should be '#S/RET/'.||

; THE 'SCANNING ATTRIBUTES' SUBROUTINE
;
; Used by the routine at #R$2672.
@label=S_ATTR_S
c$2580 CALL $2307    ; x to #REGc, y to #REGb. Again, 0<=x<=23; 0<=y<=31.
 $2583 LD A,C        ; {x is copied to #REGa and the number 32*(x mod 8)+y is
 $2584 RRCA          ; formed in #REGa. 32*(x mod 8)+INT (x/8) is also copied
 $2585 RRCA          ; to #REGc.
 $2586 RRCA          ;
 $2587 LD C,A        ;
 $2588 AND $E0       ;
 $258A XOR B         ; }
 $258B LD L,A        ; #REGl holds low byte of attribute address.
 $258C LD A,C        ; 32*(x mod 8)+INT (x/8) is copied to #REGa.
 $258D AND $03       ; {88+INT (x/8) is formed in #REGa.
 $258F XOR $58       ; }
 $2591 LD H,A        ; #REGh holds high byte of attribute address.
 $2592 LD A,(HL)     ; The attribute byte is copied to #REGa.
 $2593 JP $2D28      ; Exit, stacking the required byte.

; THE SCANNING FUNCTION TABLE
;
; Used by the routine at #R$24FB.
; .
; This table contains 8 functions and 4 operators. It thus incorporates 5 new
; Spectrum functions and provides a neat way of accessing some functions and
; operators which already existed on the ZX81.
@label=SCANFUNC
b$2596 DEFB "\"",$1C ; #R$25B3
 $2598 DEFB "(",$4F  ; #R$25E8
 $259A DEFB ".",$F2  ; #R$268D
 $259C DEFB "+",$12  ; #R$25AF
 $259E DEFB $A8,$56  ; #R$25F5
 $25A0 DEFB $A5,$57  ; #R$25F8
 $25A2 DEFB $A7,$84  ; #R$2627
 $25A4 DEFB $A6,$8F  ; #R$2634
 $25A6 DEFB $C4,$E6  ; #R$268D
 $25A8 DEFB $AA,$BF  ; #R$2668
 $25AA DEFB $AB,$C7  ; #R$2672
 $25AC DEFB $A9,$CE  ; #R$267B
 $25AE DEFB $00      ; End marker.

; THE 'SCANNING UNARY PLUS' ROUTINE
;
; The address of this routine is derived from an offset found in the
; #R$2596(scanning function table).
@refs=$24FB
@label=S_U_PLUS
c$25AF RST $20       ; {For unary plus, simply move on to the next character
 $25B0 JP $24FF      ; and jump back to the main re-entry of #R$24FB.}

; THE 'SCANNING QUOTE' ROUTINE
;
; The address of this routine is derived from an offset found in the
; #R$2596(scanning function table).
; .
; This routine deals with string quotes, whether simple like "name" or more
; complex like "a ""white"" lie" or the seemingly redundant VAL$ """a""".
@refs=$24FB
@label=S_QUOTE
c$25B3 RST $18       ; Fetch the current character.
 $25B4 INC HL        ; Point to the start of the string.
 $25B5 PUSH HL       ; Save the start address.
@keep
 $25B6 LD BC,$0000   ; Set the length to zero.
 $25B9 CALL $250F    ; Call the "matching" subroutine.
 $25BC JR NZ,$25D9   ; Jump if zero reset - no more quotes.
@label=S_Q_AGAIN
*$25BE CALL $250F    ; Call it again for a third quote.
 $25C1 JR Z,$25BE    ; And again for the fifth, seventh etc.
 $25C3 CALL $2530    ; {If testing syntax, jump to reset bit 6 of
 $25C6 JR Z,$25D9    ; #SYSVAR(FLAGS) and to continue scanning.}
 $25C8 RST $30       ; Make space in the work space for the string and the
                     ; terminating quote.
 $25C9 POP HL        ; Get the pointer to the start.
 $25CA PUSH DE       ; Save the pointer to the first space.
@label=S_Q_COPY
*$25CB LD A,(HL)     ; Get a character from the string.
 $25CC INC HL        ; Point to the next one.
 $25CD LD (DE),A     ; Copy last one to work space.
 $25CE INC DE        ; Point to the next space.
 $25CF CP "\""       ; Is last character a '"'?
 $25D1 JR NZ,$25CB   ; If not, jump to copy next one.
 $25D3 LD A,(HL)     ; {But if it was, do not copy next one; if next one is a
 $25D4 INC HL        ; '"', jump to copy the one after it; otherwise, finished
 $25D5 CP "\""       ; with copying.
 $25D7 JR Z,$25CB    ; }
@label=S_Q_PRMS
*$25D9 DEC BC        ; Get true length to #REGbc.
; Note that the first quote was not counted into the length; the final quote
; was, and is discarded now. Inside the string, the first, third, fifth, etc.,
; quotes were counted in but the second, fourth, etc., were not.
 $25DA POP DE        ; Restore start of copied string.
; This entry point is used by the routine at #R$2668.
@label=S_STRING
*$25DB LD HL,$5C3B   ; {This is #SYSVAR(FLAGS); this entry point is used
 $25DE RES 6,(HL)    ; whenever bit 6 is to be reset and a string stacked if
 $25E0 BIT 7,(HL)    ; executing a line. This is done now.
 $25E2 CALL NZ,$2AB2 ; }
 $25E5 JP $2712      ; Jump to continue scanning the line.
; Note that in copying the string to the work space, every two pairs of string
; quotes inside the string ("") have been reduced to one pair of string
; quotes(").

; THE 'SCANNING BRACKET' ROUTINE
;
; The address of this routine is derived from an offset found in the
; #R$2596(scanning function table).
@refs=$24FB
@label=S_BRACKET
c$25E8 RST $20       ; {This routine simply gets the character and calls
 $25E9 CALL $24FB    ; #R$24FB recursively.}
 $25EC CP ")"        ; {Report the error if no matching bracket.
 $25EE JP NZ,$1C8A   ; }
 $25F1 RST $20       ; {Continue scanning.
 $25F2 JP $2712      ; }

; THE 'SCANNING FN' ROUTINE
;
; The address of this routine is derived from an offset found in the
; #R$2596(scanning function table).
; .
; This routine, for user-defined functions, just jumps to the #R$27BD('scanning
; FN' subroutine).
@refs=$24FB
@label=S_FN
c$25F5 JP $27BD      ;

; THE 'SCANNING RND' ROUTINE
;
; The address of this routine is derived from an offset found in the
; #R$2596(scanning function table).
@refs=$24FB
@label=S_RND
c$25F8 CALL $2530               ; {Unless syntax is being checked, jump to
 $25FB JR Z,$2625               ; calculate a random number.}
 $25FD LD BC,($5C76)            ; Fetch the current value of #SYSVAR(SEED).
 $2601 CALL $2D2B               ; Put it on the calculator stack.
 $2604 RST $28                  ; Now use the calculator.
 $2605 DEFB $A1                 ; #R$341B(stk_one)
 $2606 DEFB $0F                 ; #R$3014: The 'last value' is now
                                ; #SYSVAR(SEED)+1.
 $2607 DEFB $34                 ; {#R$33C6: Put the number 75 on the calculator
 $2608 DEFB $37,$16             ; stack.}
 $260A DEFB $04                 ; #R$30CA: 'last value' (#SYSVAR(SEED)+1)*75.
 $260B DEFB $34                 ; {#R$33C6: Put the number 65537 on the
 $260C DEFB $80,$41,$00,$00,$80 ; calculator stack.}
 $2611 DEFB $32                 ; #R$36A0: Divide (#SYSVAR(SEED)+1)*75 by 65537
                                ; to give a 'remainder' and an 'answer'.
 $2612 DEFB $02                 ; #R$33A1: Discard the 'answer'.
 $2613 DEFB $A1                 ; #R$341B(stk_one)
 $2614 DEFB $03                 ; #R$300F: The 'last value' is now 'remainder'
                                ; - 1.
 $2615 DEFB $31                 ; #R$33C0: Make a copy of the 'last value'.
 $2616 DEFB $38                 ; #R$369B: The calculation is finished.
 $2617 CALL $2DA2               ; {Use the 'last value' to give the new value
 $261A LD ($5C76),BC            ; for #SYSVAR(SEED).}
 $261E LD A,(HL)                ; Fetch the exponent of 'last value'.
 $261F AND A                    ; {Jump forward if the exponent is zero.
 $2620 JR Z,$2625               ; }
 $2622 SUB $10                  ; {Reduce the exponent, i.e. divide 'last
 $2624 LD (HL),A                ; value' by 65536 to give the required 'last
                                ; value'.}
@label=S_RND_END
*$2625 JR $2630                 ; Jump past the #R$2627 routine.

; THE 'SCANNING PI' ROUTINE
;
; The address of this routine is derived from an offset found in the
; #R$2596(scanning function table).
; .
; Unless syntax is being checked the value of 'PI' is calculated and forms the
; 'last value' on the calculator stack.
@refs=$24FB
@label=S_PI
c$2627 CALL $2530    ; Test for syntax checking.
 $262A JR Z,$2630    ; Jump if required.
 $262C RST $28       ; Now use the calculator.
 $262D DEFB $A3      ; #R$341B(stk_pi_2): The value of #pi/2 is put on the
                     ; calculator stack as the 'last value'.
 $262E DEFB $38      ; #R$369B
 $262F INC (HL)      ; The exponent is incremented thereby doubling the 'last
                     ; value' giving #pi.
; This entry point is used by the routine at #R$25F8.
@label=S_PI_END
*$2630 RST $20       ; Move on to the next character.
 $2631 JP $26C3      ; Jump forward.

; THE' SCANNING INKEY$' ROUTINE
;
; The address of this routine is derived from an offset found in the
; #R$2596(scanning function table).
@refs=$24FB
@keep
@label=S_INKEY
c$2634 LD BC,$105A   ; {Priority &10, operation code &5A for the 'read-in'
 $2637 RST $20       ; subroutine.}
 $2638 CP "#"        ; {If next char. is '#', jump. There will be a numerical
 $263A JP Z,$270D    ; argument.}
 $263D LD HL,$5C3B   ; This is #SYSVAR(FLAGS).
 $2640 RES 6,(HL)    ; Reset bit 6 for a string result.
 $2642 BIT 7,(HL)    ; Test for syntax checking.
 $2644 JR Z,$2665    ; Jump if required.
 $2646 CALL $028E    ; Fetch a key-value in #REGde.
 $2649 LD C,$00      ; {Prepare empty string; stack it if too many keys
 $264B JR NZ,$2660   ; pressed.}
 $264D CALL $031E    ; {Test the key value; stack empty string if
 $2650 JR NC,$2660   ; unsatisfactory.}
 $2652 DEC D         ; &FF to #REGd for 'L' mode (bit 3 set).
 $2653 LD E,A        ; Key-value to #REGe for decoding.
 $2654 CALL $0333    ; Decode the key-value.
 $2657 PUSH AF       ; Save the ASCII value briefly.
@keep
 $2658 LD BC,$0001   ; One space is needed in the work space.
 $265B RST $30       ; Make it now.
 $265C POP AF        ; Restore the ASCII value.
 $265D LD (DE),A     ; Prepare to stack it as a string.
 $265E LD C,$01      ; Its length is one.
@label=S_IK_STK
*$2660 LD B,$00      ; Complete the length parameter.
 $2662 CALL $2AB2    ; Stack the required string.
@label=S_INK_EN
*$2665 JP $2712      ; Jump forward.

; THE 'SCANNING SCREEN$' ROUTINE
;
; The address of this routine is derived from an offset found in the
; #R$2596(scanning function table).
@refs=$24FB
@label=S_SCREEN
c$2668 CALL $2522    ; Check that 2 co-ordinates are given.
 $266B CALL NZ,$2535 ; Call the subroutine unless checking syntax.
 $266E RST $20       ; {Then get the next character and jump back.
 $266F JP $25DB      ; }

; THE 'SCANNING ATTR' ROUTINE
;
; The address of this routine is derived from an offset found in the
; #R$2596(scanning function table).
@refs=$24FB
@label=S_ATTR
c$2672 CALL $2522    ; Check that 2 co-ordinates are given.
 $2675 CALL NZ,$2580 ; Call the subroutine unless checking syntax.
 $2678 RST $20       ; {Then get the next character and jump forward.
 $2679 JR $26C3      ; }

; THE 'SCANNING POINT' ROUTINE
;
; The address of this routine is derived from an offset found in the
; #R$2596(scanning function table).
@refs=$24FB
@label=S_POINT
c$267B CALL $2522    ; Check that 2 co-ordinates are given.
 $267E CALL NZ,$22CB ; Call the subroutine unless checking syntax.
 $2681 RST $20       ; {Then get the next character and jump forward.
 $2682 JR $26C3      ; }

; THE 'SCANNING ALPHANUMERIC' ROUTINE
;
; Used by the routine at #R$24FB.
;
; A Code of the current character
@label=S_ALPHNUM
c$2684 CALL $2C88    ; Is the character alphanumeric?
 $2687 JR NC,$26DF   ; Jump if not a letter or a digit.
 $2689 CP "A"        ; {Now jump if it is a letter; otherwise continue on into
 $268B JR NC,$26C9   ; #R$268D.}

; THE 'SCANNING DECIMAL' ROUTINE
;
; The address of this routine is derived from an offset found in the
; #R$2596(scanning function table).
; .
; The routine at #R$2684 continues here.
; .
; This routine deals with a decimal point or a number that starts with a digit.
; It also takes care of the expression 'BIN', which is dealt with in the
; 'decimal to floating-point' subroutine.
;
; A Code of the first character in the number
@refs=$24FB
@label=S_DECIMAL
c$268D CALL $2530     ; {Jump forward if a line is being executed.
 $2690 JR NZ,$26B5    ; }
; The action taken is now very different for syntax checking and line
; execution. If syntax is being checked then the floating-point form has to be
; calculated and copied into the actual BASIC line. However when a line is
; being executed the floating-point form will always be available so it is
; copied to the calculator stack to form a 'last value'.
; .
; During syntax checking:
 $2692 CALL $2C9B     ; The floating-point form is found.
 $2695 RST $18        ; Set #REGhl to point one past the last digit.
@keep
 $2696 LD BC,$0006    ; Six locations are required.
 $2699 CALL $1655     ; Make the room in the BASIC line.
 $269C INC HL         ; Point to the first free space.
 $269D LD (HL),$0E    ; Enter the number marker code.
 $269F INC HL         ; Point to the second location.
 $26A0 EX DE,HL       ; This pointer is wanted in #REGde.
 $26A1 LD HL,($5C65)  ; Fetch the 'old' #SYSVAR(STKEND).
 $26A4 LD C,$05       ; There are 5 bytes to move.
 $26A6 AND A          ; Clear the carry flag.
 $26A7 SBC HL,BC      ; {The 'new' #SYSVAR(STKEND)='old' #SYSVAR(STKEND) minus
 $26A9 LD ($5C65),HL  ; 5.}
 $26AC LDIR           ; Move the floating-point number from the calculator
                      ; stack to the line.
 $26AE EX DE,HL       ; Put the line pointer in #REGhl.
 $26AF DEC HL         ; Point to the last byte added.
 $26B0 CALL $0077     ; This sets #SYSVAR(CH-ADD).
 $26B3 JR $26C3       ; Jump forward.
; During line execution:
@label=S_STK_DEC
*$26B5 RST $18        ; Get the current character.
@label=S_SD_SKIP
*$26B6 INC HL         ; {Now move on to the next character in turn until the
 $26B7 LD A,(HL)      ; number marker code (&0E) is found.
 $26B8 CP $0E         ;
 $26BA JR NZ,$26B6    ; }
 $26BC INC HL         ; Point to the first byte of the number.
 $26BD CALL $33B4     ; Move the floating-point number.
 $26C0 LD ($5C5D),HL  ; Set #SYSVAR(CH-ADD).
; This entry point is used by the routines at #R$2627, #R$2672 and #R$267B.
; .
; A numeric result has now been identified, coming from RND, PI, ATTR, POINT or
; a decimal number, therefore bit 6 of #SYSVAR(FLAGS) must be set.
@label=S_NUMERIC
*$26C3 SET 6,(IY+$01) ; Set the numeric marker flag (bit 6 of #SYSVAR(FLAGS)).
 $26C7 JR $26DD       ; Jump forward.

; THE 'SCANNING VARIABLE' ROUTINE
;
; Used by the routine at #R$2684.
; .
; When a variable name has been identified a call is made to #R$28B2 which
; looks through those variables that already exist in the variables area (or in
; the program area at DEF FN statements for a user-defined function FN). If an
; appropriate numeric value is found then it is copied to the calculator stack
; using #R$33B4. However a string or string array entry has to have the
; appropriate parameters passed to the calculator stack by #R$2996 (or in the
; case of a user-defined function, by #R$2951 as called from #R$28B2).
@label=S_LETTER
c$26C9 CALL $28B2     ; Look in the existing variables for the matching entry.
 $26CC JP C,$1C2E     ; An error is reported if there is no existing entry.
 $26CF CALL Z,$2996   ; Stack the parameters of the string entry/return numeric
                      ; element base address.
 $26D2 LD A,($5C3B)   ; Fetch #SYSVAR(FLAGS).
 $26D5 CP $C0         ; Test bits 6 and 7 together.
 $26D7 JR C,$26DD     ; Jump if one or both bits are reset.
 $26D9 INC HL         ; A numeric value is to be stacked.
 $26DA CALL $33B4     ; Move the number.
; This entry point is used by the routine at #R$268D.
@label=S_CONT_1
*$26DD JR $2712       ; Jump forward.
; This entry point is used by the routine at #R$2684.
; .
; The character is tested against the code for '-', thus identifying the 'unary
; minus' operation.
; .
; Before the actual test the #REGb register is set to hold the priority &09 and
; the #REGc register the operation code &DB that are required for this
; operation.
@keep
@label=S_NEGATE
*$26DF LD BC,$09DB    ; Priority &09, operation code &DB.
 $26E2 CP "-"         ; Is it a '-'?
 $26E4 JR Z,$270D     ; Jump forward if it is 'unary minus'.
; Next the character is tested against the code for 'VAL$', with priority &10
; and operation code &18.
@keep
 $26E6 LD BC,$1018    ; Priority &10, operation code &18.
 $26E9 CP $AE         ; Is it 'VAL$'?
 $26EB JR Z,$270D     ; Jump forward if it is 'VAL$'.
; The present character must now represent one of the functions CODE to NOT,
; with codes &AF to &C3.
 $26ED SUB $AF        ; The range of the functions is changed from &AF to &C3
                      ; to range &00 to &14.
 $26EF JP C,$1C8A     ; Report an error if out of range.
; The function 'NOT' is identified and dealt with separately from the others.
@keep
 $26F2 LD BC,$04F0    ; Priority &04, operation code &F0.
 $26F5 CP $14         ; Is it the function 'NOT'?
 $26F7 JR Z,$270D     ; Jump if it is so.
 $26F9 JP NC,$1C8A    ; Check the range again.
; The remaining functions have priority &10. The operation codes for these
; functions are now calculated. Functions that operate on strings need bit 6
; reset and functions that give string results need bit 7 reset in their
; operation codes.
 $26FC LD B,$10       ; Priority &10.
 $26FE ADD A,$DC      ; The function range is now &DC to &EF.
 $2700 LD C,A         ; Transfer the operation code.
 $2701 CP $DF         ; {Separate CODE, VAL and LEN which operate on strings to
 $2703 JR NC,$2707    ; give numerical results.
 $2705 RES 6,C        ; }
@label=S_NO_TO_S
*$2707 CP $EE         ; {Separate STR$ and CHR$ which operate on numbers to
 $2709 JR C,$270D     ; give string results.}
 $270B RES 7,C        ; Mark the operation codes. The other operation codes
                      ; have bits 6 and 7 both set.
; This entry point is used by the routine at #R$2634.
; .
; The priority code and the operation code for the function being considered
; are now pushed on to the machine stack. A hierarchy of operations is thereby
; built up.
@label=S_PUSH_PO
*$270D PUSH BC        ; {Stack the priority and operation codes before moving
 $270E RST $20        ; on to consider the next part of the expression.
 $270F JP $24FF       ; }
; This entry point is used by the routines at #R$25B3, #R$25E8, #R$2634 and
; #R$27BD.
; .
; The scanning of the line now continues. The present argument may be followed
; by a '(', a binary operator or, if the end of the expression has been
; reached, then e.g. a carriage return character or a colon, a separator or a
; 'THEN'.
@label=S_CONT_2
*$2712 RST $18        ; Fetch the present character.
@label=S_CONT_3
*$2713 CP "("         ; {Jump forward if it is not a '(', which indicates a
 $2715 JR NZ,$2723    ; parenthesised expression.}
; If the 'last value' is numeric then the parenthesised expression is a true
; sub-expression and must be evaluated by itself. However if the 'last value'
; is a string then the parenthesised expression represents an element of an
; array or a slice of a string. A call to #R$2A52 modifies the parameters of
; the string as required.
 $2717 BIT 6,(IY+$01) ; {Jump forward if dealing with a numeric parenthesised
 $271B JR NZ,$2734    ; expression (bit 6 of #SYSVAR(FLAGS) set).}
 $271D CALL $2A52     ; Modify the parameters of the 'last value'.
 $2720 RST $20        ; {Move on to consider the next character.
 $2721 JR $2713       ; }
; If the present character is indeed a binary operator it will be given an
; operation code in the range &C3 to &CF, and the appropriate priority code.
@label=S_OPERTR
*$2723 LD B,$00       ; {Original code to #REGbc to index into the
 $2725 LD C,A         ; #R$2795(table of operators).}
 $2726 LD HL,$2795    ; The pointer to the table.
 $2729 CALL $16DC     ; Index into the table.
 $272C JR NC,$2734    ; Jump forward if no operation found.
 $272E LD C,(HL)      ; Get required code from the table.
@nowarn
@ssub=LD HL,$27B0-$C3
 $272F LD HL,$26ED    ; The pointer to the priority table (#h26ED+#hC3 gives
                      ; #R$27B0 as the first address).
 $2732 ADD HL,BC      ; Index into the table.
 $2733 LD B,(HL)      ; Fetch the appropriate priority.
; The main loop of this subroutine is now entered. At this stage there are:
; .
; #LIST
; { i. A 'last value' on the calculator stack. }
; { ii. The starting priority marker on the machine stack below a hierarchy, of
; unknown size, of function and binary operation codes. This hierarchy may be
; null. }
; { iii. The #REGbc register pair holding the 'present' operation and priority,
; which if the end of an expression has been reached will be priority zero. }
; LIST#
; .
; Initially the 'last' operation and priority are taken off the machine stack
; and compared against the 'present' operation and priority.
@label=S_LOOP
*$2734 POP DE         ; Get the 'last' operation and priority.
 $2735 LD A,D         ; The priority goes to the #REGa register.
 $2736 CP B           ; Compare 'last' against 'present'.
 $2737 JR C,$2773     ; Exit to wait for the argument.
 $2739 AND A          ; Are both priorities zero?
 $273A JP Z,$0018     ; Exit via #R$0018 thereby making 'last value' the
                      ; required result.
; Before the 'last' operation is performed, the 'USR' function is separated
; into 'USR number' and 'USR string' according as bit 6 of #SYSVAR(FLAGS) was
; set or reset when the argument of the function was stacked as the 'last
; value'.
 $273D PUSH BC        ; Stack the 'present' values.
 $273E LD HL,$5C3B    ; This is #SYSVAR(FLAGS).
 $2741 LD A,E         ; {The 'last' operation is compared with the code for
 $2742 CP $ED         ; USR, which will give 'USR number' unless modified; jump
 $2744 JR NZ,$274C    ; if not 'USR'.}
 $2746 BIT 6,(HL)     ; Test bit 6 of #SYSVAR(FLAGS).
 $2748 JR NZ,$274C    ; Jump if it is set ('USR number').
 $274A LD E,$99       ; Modify the 'last' operation code: 'offset' &19, plus
                      ; &80 for string input and numerical result ('USR
                      ; string').
@label=S_STK_LST
*$274C PUSH DE        ; Stack the 'last' values briefly.
 $274D CALL $2530     ; {Do not perform the actual operation if syntax is being
 $2750 JR Z,$275B     ; checked.}
 $2752 LD A,E         ; The 'last' operation code.
 $2753 AND $3F        ; {Strip off bits 6 and 7 to convert the operation code
 $2755 LD B,A         ; to a calculator offset.}
 $2756 RST $28        ; Now use the calculator.
 $2757 DEFB $3B       ; #R$33A2: (perform the actual operation)
 $2758 DEFB $38       ; #R$369B
 $2759 JR $2764       ; Jump forward.
; An important part of syntax checking involves the testing of the operation to
; ensure that the nature of the 'last value' is of the correct type for the
; operation under consideration.
@label=S_SYNTEST
*$275B LD A,E         ; Get the 'last' operation code.
 $275C XOR (IY+$01)   ; {This tests the nature of the 'last value' (bit 6 of
 $275F AND $40        ; #SYSVAR(FLAGS)) against the requirement of the
                      ; operation. They are to be the same for correct syntax.}
@label=S_RPORT_C_2
*$2761 JP NZ,$1C8A    ; Jump if syntax fails.
; Before jumping back to go round the loop again the nature of the 'last value'
; must be recorded in #SYSVAR(FLAGS).
@label=S_RUNTEST
*$2764 POP DE         ; Get the 'last' operation code.
 $2765 LD HL,$5C3B    ; This is #SYSVAR(FLAGS).
 $2768 SET 6,(HL)     ; Assume result to be numeric.
 $276A BIT 7,E        ; {Jump forward if the nature of 'last value' is numeric.
 $276C JR NZ,$2770    ; }
 $276E RES 6,(HL)     ; It is a string.
@label=S_LOOPEND
*$2770 POP BC         ; Get the 'present' values into #REGbc.
 $2771 JR $2734       ; Jump back.
; Whenever the 'present' operation binds tighter, the 'last' and the 'present'
; values go back on the machine stack. However if the 'present' operation
; requires a string as its operand then the operation code is modified to
; indicate this requirement.
@label=S_TIGHTER
*$2773 PUSH DE        ; The 'last' values go on the stack.
 $2774 LD A,C         ; Get the 'present' operation code.
 $2775 BIT 6,(IY+$01) ; {Do not modify the operation code if dealing with a
 $2779 JR NZ,$2790    ; numeric operand (bit 6 of #SYSVAR(FLAGS) set).}
 $277B AND $3F        ; Clear bits 6 and 7.
 $277D ADD A,$08      ; Increase the code by &08.
 $277F LD C,A         ; Return the code to the #REGc register.
 $2780 CP $10         ; Is the operation 'AND'?
 $2782 JR NZ,$2788    ; Jump if it is not so.
 $2784 SET 6,C        ; 'AND' requires a numeric operand.
 $2786 JR $2790       ; Jump forward.
@label=S_NOT_AND
*$2788 JR C,$2761     ; The operations -, *, /, #power and OR are not possible
                      ; between strings.
 $278A CP $17         ; Is the operation a '+'?
 $278C JR Z,$2790     ; Jump if it is so.
 $278E SET 7,C        ; The other operations yield a numeric result.
@label=S_NEXT
*$2790 PUSH BC        ; The 'present' values go on the machine stack.
 $2791 RST $20        ; Consider the next character.
 $2792 JP $24FF       ; Go around the loop again.

; THE TABLE OF OPERATORS
;
; Used by the routine at #R$26C9. Each entry in this table points to an entry
; in the #R$27B0(table of priorities).
@label=OPERATORS
b$2795 DEFB "+",$CF  ; +
 $2797 DEFB "-",$C3  ; -
 $2799 DEFB "*",$C4  ; *
 $279B DEFB "/",$C5  ; /
 $279D DEFB $5E,$C6  ; #power
 $279F DEFB "=",$CE  ; =
 $27A1 DEFB ">",$CC  ; >
 $27A3 DEFB "<",$CD  ; <
 $27A5 DEFB $C7,$C9  ; <=
 $27A7 DEFB $C8,$CA  ; >=
 $27A9 DEFB $C9,$CB  ; <>
 $27AB DEFB $C5,$C7  ; OR
 $27AD DEFB $C6,$C8  ; AND
 $27AF DEFB $00      ; End marker.

; THE TABLE OF PRIORITIES
;
; Used by the routine at #R$26C9. Each entry in this table is pointed to by an
; entry in the #R$2795(table of operators).
@label=PRIORITIES
b$27B0 DEFB $06      ; -
 $27B1 DEFB $08      ; *
 $27B2 DEFB $08      ; /
 $27B3 DEFB $0A      ; #power
 $27B4 DEFB $02      ; OR
 $27B5 DEFB $03      ; AND
 $27B6 DEFB $05      ; <=
 $27B7 DEFB $05      ; >=
 $27B8 DEFB $05      ; <>
 $27B9 DEFB $05      ; >
 $27BA DEFB $05      ; <
 $27BB DEFB $05      ; =
 $27BC DEFB $06      ; +

; THE 'SCANNING FUNCTION' SUBROUTINE
;
; Used by the routine at #R$25F5.
; .
; This subroutine evaluates a user defined function which occurs in a BASIC
; line. The subroutine can be considered in four stages:
; .
; #LIST
; { i. The syntax of the FN statement is checked during syntax checking. }
; { ii. During line execution, a search is made of the program area for a DEF
; FN statement, and the names of the functions are compared, until a match is
; found - or an error is reported. }
; { iii. The arguments of the FN are evaluated by calls to #R$24FB. }
; { iv. The function itself is evaluated by calling #R$24FB, which in turn
; calls #R$28B2 and so #R$2951. }
; LIST#
@label=S_FN_SBRN
c$27BD CALL $2530    ; {Unless syntax is being checked, a jump is made to
 $27C0 JR NZ,$27F7   ; #R$27F7.}
 $27C2 RST $20       ; Get the first character of the name.
 $27C3 CALL $2C8D    ; {If it is not alphabetic, then report the error.
 $27C6 JP NC,$1C8A   ; }
 $27C9 RST $20       ; Get the next character.
 $27CA CP "$"        ; Is it a '$'?
 $27CC PUSH AF       ; Save the zero flag on the stack.
 $27CD JR NZ,$27D0   ; Jump if it was not a '$'.
 $27CF RST $20       ; But get the next character if it was.
@label=SF_BRKT_1
*$27D0 CP "("        ; {If the character is not a '(', then report the error.
 $27D2 JR NZ,$27E6   ; }
 $27D4 RST $20       ; Get the next character.
 $27D5 CP ")"        ; Is it a ')'?
 $27D7 JR Z,$27E9    ; Jump if it is; there are no arguments.
@label=SF_ARGMTS
*$27D9 CALL $24FB    ; Within the loop, call #R$24FB to check the syntax of
                     ; each argument and to insert floating-point numbers.
 $27DC RST $18       ; {Get the character which follows the argument; if it is
 $27DD CP ","        ; not a ',' then jump - no more arguments.
 $27DF JR NZ,$27E4   ; }
 $27E1 RST $20       ; Get the first character in the next argument.
 $27E2 JR $27D9      ; Loop back to consider this argument.
@label=SF_BRKT_2
*$27E4 CP ")"        ; Is the current character a ')'?
@label=SF_RPRT_C
*$27E6 JP NZ,$1C8A   ; Report the error if it is not.
@label=SF_FLAG_6
*$27E9 RST $20       ; Point to the next character in the BASIC line.
 $27EA LD HL,$5C3B   ; {Assume a string-valued function and reset bit 6 of
 $27ED RES 6,(HL)    ; #SYSVAR(FLAGS).}
 $27EF POP AF        ; {Restore the zero flag, jump if the FN is indeed
 $27F0 JR Z,$27F4    ; string-valued.}
 $27F2 SET 6,(HL)    ; Otherwise, set bit 6 of #SYSVAR(FLAGS).
@label=SF_SYN_EN
*$27F4 JP $2712      ; Jump back to continue scanning the line.
; ii. During line execution, a search must first be made for a DEF FN
; statement.
@label=SF_RUN
*$27F7 RST $20       ; Get the first character of the name.
 $27F8 AND $DF       ; Reset bit 5 for upper case.
 $27FA LD B,A        ; Copy the name to #REGb.
 $27FB RST $20       ; Get the next character.
 $27FC SUB "$"       ; Subtract &24, the code for '$'.
 $27FE LD C,A        ; Copy the result to #REGc (zero for a string, non-zero
                     ; for a numerical function).
 $27FF JR NZ,$2802   ; Jump if non-zero: numerical function.
 $2801 RST $20       ; Get the next character, the '('.
@label=SF_ARGMT1
*$2802 RST $20       ; Get 1st character of 1st argument.
 $2803 PUSH HL       ; Save the pointer to it on the stack.
 $2804 LD HL,($5C53) ; Point to the start of the program (#SYSVAR(PROG)).
 $2807 DEC HL        ; Go back one location.
@keep
@label=SF_FND_DF
*$2808 LD DE,$00CE   ; The search will be for 'DEF FN'.
 $280B PUSH BC       ; Save the name and 'string status'.
 $280C CALL $1D86    ; Search the program now.
 $280F POP BC        ; Restore the name and status.
 $2810 JR NC,$2814   ; Jump if a DEF FN statement found.
; Report P - FN without DEF.
 $2812 RST $08       ; {Call the error handling routine.
 $2813 DEFB $18      ; }
; When a DEF FN statement is found, the name and status of the two functions
; are compared; if they do not match, the search is resumed.
@label=SF_CP_DEF
*$2814 PUSH HL       ; Save the pointer to the DEF FN character in case the
                     ; search has to be resumed.
 $2815 CALL $28AB    ; Get the name of the DEF FN function.
 $2818 AND $DF       ; Reset bit 5 for upper case.
 $281A CP B          ; Does it match the FN name?
 $281B JR NZ,$2825   ; Jump if it does not match.
 $281D CALL $28AB    ; Get the next character in the DEF FN.
 $2820 SUB "$"       ; Subtract &24, the code for '$'.
 $2822 CP C          ; Compare the status with that of FN.
 $2823 JR Z,$2831    ; Jump if complete match now found.
@label=SF_NOT_FD
*$2825 POP HL        ; Restore the pointer to the 'DEF FN'.
 $2826 DEC HL        ; Step back one location.
@keep
 $2827 LD DE,$0200   ; {Use the search routine to find the end of the DEF FN
 $282A PUSH BC       ; statement, preparing for the next search; save the name
 $282B CALL $198B    ; and status meanwhile.
 $282E POP BC        ; }
 $282F JR $2808      ; Jump back for a further search.
; iii. The correct DEF FN statement has now been found. The arguments of the FN
; statement will be evaluated by repeated calls of #R$24FB, and their 5 byte
; values (or parameters, for strings) will be inserted into the DEF FN
; statement in the spaces made there at syntax checking. #REGhl will be used to
; point along the DEF FN statement (calling #R$28AB as needed) while
; #SYSVAR(CH-ADD) points along the FN statement (calling #R$0020 as needed).
@label=SF_VALUES
*$2831 AND A         ; {If #REGhl is now pointing to a '$', move on to the '('.
 $2832 CALL Z,$28AB  ; }
 $2835 POP DE        ; Discard the pointer to 'DEF FN'.
 $2836 POP DE        ; {Get the pointer to the first argument of FN, and copy
 $2837 LD ($5C5D),DE ; it to #SYSVAR(CH-ADD).}
 $283B CALL $28AB    ; Move past the '(' now.
 $283E PUSH HL       ; Save this pointer on the stack.
 $283F CP ")"        ; Is it pointing to a ')'?
 $2841 JR Z,$2885    ; If so, jump: FN has no arguments.
@label=SF_ARG_LP
*$2843 INC HL        ; Point to the next code.
 $2844 LD A,(HL)     ; Put the code into #REGa.
 $2845 CP $0E        ; Is it the 'number marker' code, &0E?
 $2847 LD D,$40      ; Set bit 6 of #REGd for a numerical argument.
 $2849 JR Z,$2852    ; Jump on zero: numerical argument.
 $284B DEC HL        ; {Now ensure that #REGhl is pointing to the '$' character
 $284C CALL $28AB    ; (not e.g. to a control code).}
 $284F INC HL        ; #REGhl now points to the 'number marker'.
 $2850 LD D,$00      ; Bit 6 of #REGd is reset: string argument.
@label=SF_ARG_VL
*$2852 INC HL        ; Point to the 1st of the 5 bytes in DEF FN.
 $2853 PUSH HL       ; Save this pointer on the stack.
 $2854 PUSH DE       ; Save the 'string status' of the argument.
 $2855 CALL $24FB    ; Now evaluate the argument.
 $2858 POP AF        ; Get the no./string flag into #REGa.
 $2859 XOR (IY+$01)  ; {Test bit 6 of it against the result of #R$24FB (bit 6
 $285C AND $40       ; of #SYSVAR(FLAGS)).}
 $285E JR NZ,$288B   ; Give report Q if they did not match.
 $2860 POP HL        ; {Get the pointer to the first of the 5 spaces in DEF FN
 $2861 EX DE,HL      ; into #REGde.}
 $2862 LD HL,($5C65) ; Point #REGhl at #SYSVAR(STKEND).
@keep
 $2865 LD BC,$0005   ; #REGbc will count 5 bytes to be moved.
 $2868 SBC HL,BC     ; {First, decrease #SYSVAR(STKEND) by 5, so deleting the
 $286A LD ($5C65),HL ; 'last value' from the stack.}
 $286D LDIR          ; Copy the 5 bytes into the spaces in DEF FN.
 $286F EX DE,HL      ; Point #REGhl at the next code.
 $2870 DEC HL        ; {Ensure that #REGhl points to the character after the 5
 $2871 CALL $28AB    ; bytes.}
 $2874 CP ")"        ; Is it a ')'?
 $2876 JR Z,$2885    ; Jump if it is: no more arguments in the DEF FN
                     ; statement.
 $2878 PUSH HL       ; It is a ',': save the pointer to it.
 $2879 RST $18       ; Get the character after the last argument that was
                     ; evaluated from FN.
 $287A CP ","        ; {If it is not a ',' jump: mismatched arguments of FN and
 $287C JR NZ,$288B   ; DEF FN.}
 $287E RST $20       ; Point #SYSVAR(CH-ADD) to the next argument of FN.
 $287F POP HL        ; Point #REGhl to the ',' in DEF FN again.
 $2880 CALL $28AB    ; Move #REGhl on to the next argument in DEF FN.
 $2883 JR $2843      ; Jump back to consider this argument.
@label=SF_R_BR_2
*$2885 PUSH HL       ; Save the pointer to the ')' in DEF FN.
 $2886 RST $18       ; Get the character after the last argument in FN.
 $2887 CP ")"        ; Is it a ')'?
 $2889 JR Z,$288D    ; If so, jump to evaluate the function; but if not, give
                     ; report Q.
; Report Q - Parameter error.
@label=REPORT_Q
*$288B RST $08       ; {Call the error handling routine.
 $288C DEFB $19      ; }
; iv. Finally, the function itself is evaluated by calling #R$24FB, after first
; setting #SYSVAR(DEFADD) to hold the address of the arguments as they occur in
; the DEF FN statement. This ensures that #R$28B2, when called by #R$24FB, will
; first search these arguments for the required values, before making a search
; of the variables area.
@label=SF_VALUE
*$288D POP DE        ; Restore pointer to ')' in DEF FN.
 $288E EX DE,HL      ; Get this pointer into #REGhl.
 $288F LD ($5C5D),HL ; Insert it into #SYSVAR(CH-ADD).
 $2892 LD HL,($5C0B) ; Get the old value of #SYSVAR(DEFADD).
 $2895 EX (SP),HL    ; {Stack it, and get the start address of the arguments
 $2896 LD ($5C0B),HL ; area of DEF FN into #SYSVAR(DEFADD).}
 $2899 PUSH DE       ; Save address of ')' in FN.
 $289A RST $20       ; {Move #SYSVAR(CH-ADD) on past ')' and '=' to the start
 $289B RST $20       ; of the expression for the function in DEF FN.}
 $289C CALL $24FB    ; Now evaluate the function.
 $289F POP HL        ; Restore the address of ')' in FN.
 $28A0 LD ($5C5D),HL ; Store it in #SYSVAR(CH-ADD).
 $28A3 POP HL        ; Restore original value of #SYSVAR(DEFADD).
 $28A4 LD ($5C0B),HL ; Put it back into #SYSVAR(DEFADD).
 $28A7 RST $20       ; Get the next character in the BASIC line.
 $28A8 JP $2712      ; Jump back to continue scanning.

; THE 'FUNCTION SKIPOVER' SUBROUTINE
;
; This subroutine is used by #R$27BD and by #R$2951 to move #REGhl along the
; DEF FN statement while leaving #SYSVAR(CH-ADD) undisturbed, as it points
; along the FN statement.
;
;   HL Address of the current character
; O:A Code of next non-control, non-space character
; O:HL Address of that character
@label=FN_SKPOVR
c$28AB INC HL        ; Point to the next code in the statement.
 $28AC LD A,(HL)     ; Copy the code to #REGa.
 $28AD CP $21        ; {Jump back to skip over it if it is a control code or a
 $28AF JR C,$28AB    ; space.}
 $28B1 RET           ; Finished.

; THE 'LOOK-VARS' SUBROUTINE
;
; Used by the routines at #R$0605, #R$1C1F, #R$1C6C, #R$26C9 and #R$2C02.
; .
; This subroutine is called whenever a search of the variables area or of the
; arguments of a DEF FN statement is required. The subroutine is entered with
; the system variable #SYSVAR(CH-ADD) pointing to the first letter of the name
; of the variable whose location is being sought. The name will be in the
; program area or the work space. The subroutine initially builds up a
; discriminator byte, in the #REGc register, that is based on the first letter
; of the variable's name. Bits 5 and 6 of this byte indicate the type of the
; variable that is being handled.
; .
; The #REGb register is used as a bit register to hold flags.
;
; O:C Bits 0-4: Code of the variable's name (if executing)
; O:C Bit 5: Set if the variable is numeric, reset if it's a string
; O:C Bit 6: Set if the variable is simple, reset if it's an array
; O:C Bit 7: Set if checking syntax, reset if executing
; O:HL Address of the last letter of the variable's name (in the variables
; .    area, if found)
; O:F Carry flag reset if the variable already exists or if checking syntax
; O:F Zero flag reset if the variable is simple (not an array) and does not
; .   exist
@label=LOOK_VARS
c$28B2 SET 6,(IY+$01) ; Presume a numeric variable (set bit 6 of
                      ; #SYSVAR(FLAGS)).
 $28B6 RST $18        ; Get the first character into #REGa.
 $28B7 CALL $2C8D     ; Is it alphabetic?
 $28BA JP NC,$1C8A    ; Give an error report if it is not so.
 $28BD PUSH HL        ; Save the pointer to the first letter.
 $28BE AND $1F        ; {Transfer bits 0 to 4 of the letter to the #REGc
 $28C0 LD C,A         ; register; bits 5 and 7 are always reset.}
 $28C1 RST $20        ; Get the second character into #REGa.
 $28C2 PUSH HL        ; Save this pointer also.
 $28C3 CP "("         ; Is the second character a '('?
 $28C5 JR Z,$28EF     ; Separate arrays of numbers.
 $28C7 SET 6,C        ; Now set bit 6.
 $28C9 CP "$"         ; Is the second character a '$'?
 $28CB JR Z,$28DE     ; Separate all the strings.
 $28CD SET 5,C        ; Now set bit 5.
 $28CF CALL $2C88     ; {If the variable's name has only one character then
 $28D2 JR NC,$28E3    ; jump forward.}
; Now find the end character of a name that has more than one character.
@label=V_CHAR
*$28D4 CALL $2C88     ; Is the character alphanumeric?
 $28D7 JR NC,$28EF    ; Jump out of the loop when the end of the name is found.
 $28D9 RES 6,C        ; Mark the discriminator byte.
 $28DB RST $20        ; Get the next character.
 $28DC JR $28D4       ; Go back to test it.
; Simple strings and arrays of strings require that bit 6 of #SYSVAR(FLAGS) is
; reset.
@label=V_STR_VAR
*$28DE RST $20        ; Step #SYSVAR(CH-ADD) past the '$'.
 $28DF RES 6,(IY+$01) ; Reset bit 6 of #SYSVAR(FLAGS) to indicate a string.
; If #SYSVAR(DEFADD-hi) is non-zero, indicating that a 'function' (a 'FN') is
; being evaluated, and if in 'run-time', a search will be made of the arguments
; in the DEF FN statement.
@label=V_TEST_FN
@keep=$01
@ssub=LD A,($5C0B+$01)
*$28E3 LD A,($5C0C)   ; {Is #SYSVAR(DEFADD-hi) zero?
 $28E6 AND A          ; }
 $28E7 JR Z,$28EF     ; If so, jump forward.
 $28E9 CALL $2530     ; In 'run-time'?
 $28EC JP NZ,$2951    ; If so, jump forward to search the DEF FN statement.
; This entry point is used by the routine at #R$2951.
; .
; Otherwise (or if the variable was not found in the DEF FN statement) a search
; of variables area will be made, unless syntax is being checked.
@label=V_RUN_SYN
*$28EF LD B,C         ; Copy the discriminator byte to the #REGb register.
 $28F0 CALL $2530     ; {Jump forward if in 'run-time'.
 $28F3 JR NZ,$28FD    ; }
 $28F5 LD A,C         ; Move the discriminator to #REGa.
 $28F6 AND $E0        ; Drop the character code part.
 $28F8 SET 7,A        ; Indicate syntax by setting bit 7.
 $28FA LD C,A         ; Restore the discriminator.
 $28FB JR $2934       ; Jump forward to continue.
; A BASIC line is being executed so make a search of the variables area.
@label=V_RUN
*$28FD LD HL,($5C4B)  ; Pick up the #SYSVAR(VARS) pointer.
; Now enter a loop to consider the names of the existing variables.
@label=V_EACH
*$2900 LD A,(HL)      ; The first letter of each existing variable.
 $2901 AND $7F        ; Match on bits 0 to 6.
 $2903 JR Z,$2932     ; Jump when the '&80-byte' is reached.
 $2905 CP C           ; The actual comparison.
 $2906 JR NZ,$292A    ; Jump forward if the first characters do not match.
 $2908 RLA            ; {Rotate #REGa leftwards and then double it to test bits
 $2909 ADD A,A        ; 5 and 6.}
 $290A JP P,$293F     ; Strings and array variables.
 $290D JR C,$293F     ; Simple numeric and FOR-NEXT variables.
; Long names are required to be matched fully.
 $290F POP DE         ; {Take a copy of the pointer to the second character.
 $2910 PUSH DE        ; }
 $2911 PUSH HL        ; Save the first letter pointer.
@label=V_MATCHES
*$2912 INC HL         ; Consider the next character.
@label=V_SPACES
*$2913 LD A,(DE)      ; Fetch each character in turn.
 $2914 INC DE         ; Point to the next character.
 $2915 CP " "         ; Is the character a 'space'?
 $2917 JR Z,$2913     ; Ignore the spaces.
 $2919 OR $20         ; Set bit 5 so as to match lower and upper case letters.
 $291B CP (HL)        ; Make the comparison.
 $291C JR Z,$2912     ; Back for another character if it does match.
 $291E OR $80         ; Will it match with bit 7 set?
 $2920 CP (HL)        ; Try it.
 $2921 JR NZ,$2929    ; Jump forward if the 'last characters' do not match.
 $2923 LD A,(DE)      ; {Check that the end of the name has been reached before
 $2924 CALL $2C88     ; jumping forward.
 $2927 JR NC,$293E    ; }
; In all cases where the names fail to match the #REGhl register pair has to be
; made to point to the next variable in the variables area.
@label=V_GET_PTR
*$2929 POP HL         ; Fetch the pointer.
@label=V_NEXT
*$292A PUSH BC        ; Save #REGb and #REGc briefly.
 $292B CALL $19B8     ; #REGde is made to point to the next variable.
 $292E EX DE,HL       ; Switch the two pointers.
 $292F POP BC         ; Get #REGb and #REGc back.
 $2930 JR $2900       ; Go around the loop again.
; Come here if no entry was found with the correct name.
@label=V_80_BYTE
*$2932 SET 7,B        ; Signal 'variable not found'.
; Come here if checking syntax.
@label=V_SYNTAX
*$2934 POP DE         ; Drop the pointer to the second character.
 $2935 RST $18        ; Fetch the present character.
 $2936 CP "("         ; Is it a '('?
 $2938 JR Z,$2943     ; Jump forward if so.
 $293A SET 5,B        ; {Indicate not dealing with an array and jump forward.
 $293C JR $294B       ; }
; Come here when an entry with the correct name was found.
@label=V_FOUND_1
*$293E POP DE         ; Drop the saved variable pointer.
@label=V_FOUND_2
*$293F POP DE         ; Drop the second character pointer.
 $2940 POP DE         ; Drop the first letter pointer.
 $2941 PUSH HL        ; Save the 'last' letter pointer.
 $2942 RST $18        ; Fetch the current character.
; If the matching variable name has more than a single letter then the other
; characters must be passed over.
; .
; Note: this appears to have been done already at #R$28D4.
@label=V_PASS
*$2943 CALL $2C88     ; Is it alphanumeric?
 $2946 JR NC,$294B    ; Jump when the end of the name has been found.
 $2948 RST $20        ; Fetch the next character.
 $2949 JR $2943       ; Go back and test it.
; The exit-parameters are now set.
@label=V_END
*$294B POP HL         ; #REGhl holds the pointer to the letter of a short name
                      ; or the 'last' character of a long name.
 $294C RL B           ; Rotate the whole register.
 $294E BIT 6,B        ; Specify the state of bit 6.
 $2950 RET            ; Finished.
; The exit-parameters for the subroutine can be summarised as follows.
; .
; The system variable #SYSVAR(CH-ADD) points to the first location after the
; name of the variable as it occurs in the BASIC line.
; .
; When 'variable not found':
; .
; #LIST
; { The carry flag is set. }
; { The zero flag is set only when the search was for an array variable. }
; { The #REGhl register pair points to the first letter of the name of the
; variable as it occurs in the BASIC line. }
; LIST#
; .
; When 'variable found':
; .
; #LIST
; { The carry flag is reset. }
; { The zero flag is set for both simple string variables and all array
; variables. }
; { The #REGhl register pair points to the letter of a 'short' name, or the
; last character of a 'long' name, of the existing entry that was found in the
; variables area. }
; LIST#
; .
; In all cases bits 5 and 6 of the #REGc register indicate the type of variable
; being handled. Bit 7 is the complement of the SYNTAX/RUN flag. But only when
; the subroutine is used in 'runtime' will bits 0 to 4 hold the code of the
; variable's letter.
; .
; In syntax time the return is always made with the carry flag reset. The zero
; flag is set for arrays and reset for all other variables, except that a
; simple string name incorrectly followed by a '$' sets the zero flag and, in
; the case of SAVE "name" DATA a$(), passes syntax as well.

; THE 'STACK FUNCTION ARGUMENT' SUBROUTINE
;
@ignoreua
; This subroutine is called by #R$28B2 when #SYSVAR(DEFADD-hi) is non-zero, to
; make a search of the arguments area of a DEF FN statement, before searching
; in the variables area. If the variable is found in the DEF FN statement, then
; the parameters of a string variable are stacked and a signal is given that
; there is no need to call #R$2996. But it is left to #R$26C9 to stack the
; value of a numerical variable at #R$26DA(#h26DA) in the usual way.
@label=STK_F_ARG
c$2951 LD HL,($5C0B) ; {Point to the first character in the arguments area
 $2954 LD A,(HL)     ; (#SYSVAR(DEFADD)) and put it into #REGa.}
 $2955 CP ")"        ; Is it a ')'?
 $2957 JP Z,$28EF    ; Jump to search the variables area.
@label=SFA_LOOP
*$295A LD A,(HL)     ; Get the next argument in the loop.
 $295B OR $60        ; {Set bits 5 and 6, assuming a simple numeric variable;
 $295D LD B,A        ; copy it to #REGb.}
 $295E INC HL        ; Point to the next code.
 $295F LD A,(HL)     ; Put it into the #REGa register.
 $2960 CP $0E        ; Is it the 'number marker' code, &0E?
 $2962 JR Z,$296B    ; Jump if so: numeric variable.
 $2964 DEC HL        ; {Ensure that #REGhl points to the character, not to a
 $2965 CALL $28AB    ; space or control code.}
 $2968 INC HL        ; #REGhl now points to the 'number marker'.
 $2969 RES 5,B       ; Reset bit 5 of #REGb: string variable.
@label=SFA_CP_VR
*$296B LD A,B        ; Get the variable name into #REGa.
 $296C CP C          ; Is it the one we are looking for?
 $296D JR Z,$2981    ; Jump if it matches.
 $296F INC HL        ; {Now pass over the 5 bytes of the floating-point number
 $2970 INC HL        ; or string parameters to get to the next argument.
 $2971 INC HL        ;
 $2972 INC HL        ;
 $2973 INC HL        ; }
 $2974 CALL $28AB    ; Pass on to the next character.
 $2977 CP ")"        ; Is it a ')'?
 $2979 JP Z,$28EF    ; If so, jump to search the variables area.
 $297C CALL $28AB    ; Point to the next argument.
 $297F JR $295A      ; Jump back to consider it.
; A match has been found. The parameters of a string variable are stacked,
; avoiding the need to call #R$2996.
@label=SFA_MATCH
*$2981 BIT 5,C       ; Test for a numeric variable.
 $2983 JR NZ,$2991   ; Jump if the variable is numeric; #R$24FB will stack it.
 $2985 INC HL        ; Point to the first of the 5 bytes to be stacked.
 $2986 LD DE,($5C65) ; Point #REGde to #SYSVAR(STKEND).
 $298A CALL $33C0    ; Stack the 5 bytes.
 $298D EX DE,HL      ; {Point #REGhl to the new position of #SYSVAR(STKEND),
 $298E LD ($5C65),HL ; and reset the system variable.}
@label=SFA_END
*$2991 POP DE        ; {Discard the #R$28B2 pointers (second and first
 $2992 POP DE        ; character pointers).}
 $2993 XOR A         ; {Return from the search with both the carry and zero
 $2994 INC A         ; flags reset - signalling that a call #R$2996 is not
                     ; required.}
 $2995 RET           ; Finished.

; THE 'STK-VAR' SUBROUTINE
;
; Used by the routines at #R$1C22, #R$26C9 and #R$2C02.
; .
; This subroutine is used either to find the parameters that define an existing
; string entry in the variables area, or to return in the #REGhl register pair
; the base address of a particular element or an array of numbers. When called
; from #R$2C02 the subroutine only checks the syntax of the BASIC statement.
; .
; Note that the parameters that define a string may be altered by calling
; #R$2A52 if this should be specified.
; .
; Initially the #REGa and the #REGb registers are cleared and bit 7 of the
; #REGc register is tested to determine whether syntax is being checked.
;
; C Bit 5: Set if the variable is numeric, reset if it's a string
; C Bit 6: Set if the variable is simple, reset if it's an array
; C Bit 7: Set if checking syntax, reset if executing
; HL Address of the last letter of the variable's name (in the variables area)
@label=STK_VAR
c$2996 XOR A          ; Clear the array flag.
 $2997 LD B,A         ; Clear the #REGb register for later.
 $2998 BIT 7,C        ; {Jump forward if syntax is being checked.
 $299A JR NZ,$29E7    ; }
; Next, simple strings are separated from array variables.
 $299C BIT 7,(HL)     ; {Jump forward if dealing with an array variable.
 $299E JR NZ,$29AE    ; }
; The parameters for a simple string are readily found.
 $29A0 INC A          ; Signal 'a simple string'.
@label=SV_SIMPLE
*$29A1 INC HL         ; Move along the entry.
 $29A2 LD C,(HL)      ; Pick up the low length counter.
 $29A3 INC HL         ; Advance the pointer.
 $29A4 LD B,(HL)      ; Pick up the high length pointer.
 $29A5 INC HL         ; Advance the pointer.
 $29A6 EX DE,HL       ; Transfer the pointer to the actual string.
 $29A7 CALL $2AB2     ; Pass these parameters to the calculator stack.
 $29AA RST $18        ; {Fetch the present character and jump forward to see if
 $29AB JP $2A49       ; a 'slice' is required.}
; The base address of an element in an array is now found. Initially the
; 'number of dimensions' is collected.
@label=SV_ARRAYS
*$29AE INC HL         ; {Step past the length bytes.
 $29AF INC HL         ;
 $29B0 INC HL         ; }
 $29B1 LD B,(HL)      ; Collect the 'number of dimensions'.
 $29B2 BIT 6,C        ; {Jump forward if handling an array of numbers.
 $29B4 JR Z,$29C0     ; }
; If an array of strings has its 'number of dimensions' equal to '1' then such
; an array can be handled as a simple string.
 $29B6 DEC B          ; {Decrease the 'number of dimensions' and jump if the
 $29B7 JR Z,$29A1     ; number is now zero.}
; Next a check is made to ensure that in the BASIC line the variable is
; followed by a subscript.
 $29B9 EX DE,HL       ; Save the pointer in #REGde.
 $29BA RST $18        ; Get the present character.
 $29BB CP "("         ; Is it a '('?
 $29BD JR NZ,$2A20    ; Report the error if it is not so.
 $29BF EX DE,HL       ; Restore the pointer.
; For both numeric arrays and arrays of strings the variable pointer is
; transferred to the #REGde register pair before the subscript is evaluated.
@label=SV_PTR
*$29C0 EX DE,HL       ; Pass the pointer to #REGde.
 $29C1 JR $29E7       ; Jump forward.
; The following loop is used to find the parameters of a specified element
; within an array. The loop is entered at the mid-point - #R$29E7 - where the
; element count is set to zero.
; .
; The loop is accessed #REGb times, this being, for a numeric array, equal to
; the number of dimensions that are being used, but for an array of strings
; #REGb is one less than the number of dimensions in use as the last subscript
; is used to specify a 'slice' of the string.
@label=SV_COMMA
*$29C3 PUSH HL        ; Save the counter.
 $29C4 RST $18        ; Get the present character.
 $29C5 POP HL         ; Restore the counter.
 $29C6 CP ","         ; Is the present character a ','?
 $29C8 JR Z,$29EA     ; Jump forward to consider another subscript.
 $29CA BIT 7,C        ; {If a line is being executed then there is an error.
 $29CC JR Z,$2A20     ; }
 $29CE BIT 6,C        ; {Jump forward if dealing with an array of strings.
 $29D0 JR NZ,$29D8    ; }
 $29D2 CP ")"         ; Is the present character a ')'?
 $29D4 JR NZ,$2A12    ; Report an error if not so.
 $29D6 RST $20        ; Advance #SYSVAR(CH-ADD).
 $29D7 RET            ; Return as the syntax is correct.
; For an array of strings the present subscript may represent a 'slice', or the
; subscript for a 'slice' may yet be present in the BASIC line.
@label=SV_CLOSE
*$29D8 CP ")"         ; Is the present character a ')'?
 $29DA JR Z,$2A48     ; Jump forward and check whether there is another
                      ; subscript.
 $29DC CP $CC         ; Is the present character a 'TO'?
 $29DE JR NZ,$2A12    ; It must not be otherwise.
@label=SV_CH_ADD
*$29E0 RST $18        ; Get the present character.
 $29E1 DEC HL         ; {Point to the preceding character and set
 $29E2 LD ($5C5D),HL  ; #SYSVAR(CH-ADD).}
 $29E5 JR $2A45       ; Evaluate the 'slice'.
; Enter the loop here.
@keep
@label=SV_COUNT
*$29E7 LD HL,$0000    ; Set the counter to zero.
@label=SV_LOOP
*$29EA PUSH HL        ; Save the counter briefly.
 $29EB RST $20        ; Advance #SYSVAR(CH-ADD).
 $29EC POP HL         ; Restore the counter.
 $29ED LD A,C         ; Fetch the discriminator byte.
 $29EE CP $C0         ; {Jump unless checking the syntax for an array of
 $29F0 JR NZ,$29FB    ; strings.}
 $29F2 RST $18        ; Get the present character.
 $29F3 CP ")"         ; Is it a ')'?
 $29F5 JR Z,$2A48     ; Jump forward as finished counting elements.
 $29F7 CP $CC         ; Is to 'TO'?
 $29F9 JR Z,$29E0     ; Jump back if dealing with a 'slice'.
@label=SV_MULT
*$29FB PUSH BC        ; Save the dimension-number counter and the discriminator
                      ; byte.
 $29FC PUSH HL        ; Save the element-counter.
 $29FD CALL $2AEE     ; Get a dimension-size into #REGde.
 $2A00 EX (SP),HL     ; The counter moves to #REGhl and the variable pointer is
                      ; stacked.
 $2A01 EX DE,HL       ; The counter moves to #REGde and the dimension-size to
                      ; #REGhl.
 $2A02 CALL $2ACC     ; Evaluate the next subscript.
 $2A05 JR C,$2A20     ; Give an error if out of range.
 $2A07 DEC BC         ; The result of the evaluation is decremented as the
                      ; counter is to count the elements occurring before the
                      ; specified element.
 $2A08 CALL $2AF4     ; Multiply the counter by the dimension-size.
 $2A0B ADD HL,BC      ; Add the result of #R$2ACC to the present counter.
 $2A0C POP DE         ; Fetch the variable pointer.
 $2A0D POP BC         ; Fetch the dimension-number and the discriminator byte.
 $2A0E DJNZ $29C3     ; Keep going round the loop until #REGb equals zero.
; The SYNTAX/RUN flag is checked before arrays of strings are separated from
; arrays of numbers.
 $2A10 BIT 7,C        ; {Report an error if checking syntax at this point.
@label=SV_RPT_C
*$2A12 JR NZ,$2A7A    ; }
 $2A14 PUSH HL        ; Save the counter.
 $2A15 BIT 6,C        ; {Jump forward if handling an array of strings.
 $2A17 JR NZ,$2A2C    ; }
; When dealing with an array of numbers the present character must be a ')'.
 $2A19 LD B,D         ; {Transfer the variable pointer to the #REGbc register
 $2A1A LD C,E         ; pair.}
 $2A1B RST $18        ; Fetch the present character.
 $2A1C CP ")"         ; Is it a ')'?
 $2A1E JR Z,$2A22     ; Jump past the error report unless it is needed.
; This entry point is used by the routines at #R$2A52 and #R$2C02.
; .
; Report 3 - Subscript out of range.
@label=REPORT_3
*$2A20 RST $08        ; {Call the error handling routine.
 $2A21 DEFB $02       ; }
; The address of the location before the actual floating-point form can now be
; calculated.
@label=SV_NUMBER
*$2A22 RST $20        ; Advance #SYSVAR(CH-ADD).
 $2A23 POP HL         ; Fetch the counter.
@keep
 $2A24 LD DE,$0005    ; There are 5 bytes to each element in an array of
                      ; numbers.
 $2A27 CALL $2AF4     ; Compute the total number of bytes before the required
                      ; element.
 $2A2A ADD HL,BC      ; Make #REGhl point to the location before the required
                      ; element.
 $2A2B RET            ; Return with this address.
; When dealing with an array of strings the length of an element is given by
; the last 'dimension-size'. The appropriate parameters are calculated and then
; passed to the calculator stack.
@label=SV_ELEM
*$2A2C CALL $2AEE     ; Fetch the last dimension-size.
 $2A2F EX (SP),HL     ; The variable pointer goes on the stack and the counter
                      ; to #REGhl.
 $2A30 CALL $2AF4     ; Multiply 'counter' by 'dimension-size'.
 $2A33 POP BC         ; Fetch the variable pointer.
 $2A34 ADD HL,BC      ; This gives #REGhl pointing to the location before the
                      ; string.
 $2A35 INC HL         ; So point to the actual 'start'.
 $2A36 LD B,D         ; {Transfer the last dimension-size to #REGbc to form the
 $2A37 LD C,E         ; 'length'.}
 $2A38 EX DE,HL       ; Move the 'start' to #REGde.
 $2A39 CALL $2AB1     ; Pass these parameters to the calculator stack. Note:
                      ; the first parameter is zero indicating a string from an
                      ; 'array of strings' and hence the existing entry is not
                      ; to be reclaimed.
; There are three possible forms of the last subscript:
; .
; #LIST
; { A$(2,4 TO 8) }
; { A$(2)(4 TO 8) }
; { A$(2) }
; LIST#
; .
; The last of these is the default form and indicates that the whole string is
; required.
 $2A3C RST $18        ; Get the present character.
 $2A3D CP ")"         ; Is it a ')'?
 $2A3F JR Z,$2A48     ; Jump if it is so.
 $2A41 CP ","         ; Is it a ','?
 $2A43 JR NZ,$2A20    ; Report the error if not so.
@label=SV_SLICE
*$2A45 CALL $2A52     ; Use #R$2A52 to modify the set of parameters.
@label=SV_DIM
*$2A48 RST $20        ; Fetch the next character.
@label=SV_SLICE2
*$2A49 CP "("         ; Is It a '('?
 $2A4B JR Z,$2A45     ; Jump back if there is a 'slice' to be considered.
; When finished considering the last subscript a return can be made.
 $2A4D RES 6,(IY+$01) ; Signal - string result (reset bit 6 of #SYSVAR(FLAGS)).
 $2A51 RET            ; Return with the parameters of the required string
                      ; forming a 'last value' on the calculator stack.

; THE 'SLICING' SUBROUTINE
;
; Used by the routines at #R$26C9 and #R$2996.
; .
; The present string can be sliced using this subroutine. The subroutine is
; entered with the parameters of the string being present on the top of the
; calculator stack and in the registers #REGa, #REGb, #REGc, #REGd and #REGe.
; Initially the SYNTAX/RUN flag is tested and the parameters of the string are
; fetched only if a line is being executed.
;
; BC Length of the string
; DE Address of the first character in the string
@label=SLICING
c$2A52 CALL $2530     ; Check the flag.
 $2A55 CALL NZ,$2BF1  ; Take the parameters off the stack in 'run-time'.
; The possibility of the 'slice' being '()' has to be considered.
 $2A58 RST $20        ; Get the next character.
 $2A59 CP ")"         ; Is it a ')'?
 $2A5B JR Z,$2AAD     ; Jump forward if it is so.
; Before proceeding the registers are manipulated as follows:
 $2A5D PUSH DE        ; The 'start' goes on the machine stack.
 $2A5E XOR A          ; {The #REGa register is cleared and saved.
 $2A5F PUSH AF        ; }
 $2A60 PUSH BC        ; The 'length' is saved briefly.
@keep
 $2A61 LD DE,$0001    ; Presume that the 'slice' is to begin with the first
                      ; character.
 $2A64 RST $18        ; Get the first character.
 $2A65 POP HL         ; Pass the 'length' to #REGhl.
; The first parameter of the 'slice' is now evaluated.
 $2A66 CP $CC         ; Is the present character a 'TO'?
 $2A68 JR Z,$2A81     ; The first parameter, by default, will be '1' if the
                      ; jump is taken.
 $2A6A POP AF         ; At this stage #REGa is zero.
 $2A6B CALL $2ACD     ; #REGbc is made to hold the first parameter. #REGa will
                      ; hold &FF if there has been an 'out of range' error.
 $2A6E PUSH AF        ; Save the value anyway.
 $2A6F LD D,B         ; {Transfer the first parameter to #REGde.
 $2A70 LD E,C         ; }
 $2A71 PUSH HL        ; Save the 'length' briefly.
 $2A72 RST $18        ; Get the present character.
 $2A73 POP HL         ; Restore the 'length'.
 $2A74 CP $CC         ; Is the present character a 'TO'?
 $2A76 JR Z,$2A81     ; {Jump forward to consider the second parameter if it is
 $2A78 CP ")"         ; so; otherwise show that there is a closing bracket.}
; This entry point is used by the routine at #R$2996.
@label=SL_RPT_C
*$2A7A JP NZ,$1C8A    ;
; At this point a 'slice' of a single character has been identified. e.g.
; A$(4).
 $2A7D LD H,D         ; {The last character of the 'slice' is also the first
 $2A7E LD L,E         ; character.}
 $2A7F JR $2A94       ; Jump forward.
; The second parameter of a 'slice' is now evaluated.
@label=SL_SECOND
*$2A81 PUSH HL        ; Save the 'length' briefly.
 $2A82 RST $20        ; Get the next character.
 $2A83 POP HL         ; Restore the 'length'.
 $2A84 CP ")"         ; Is the present character a ')'?
 $2A86 JR Z,$2A94     ; Jump if there is not a second parameter.
 $2A88 POP AF         ; If the first parameter was in range #REGa will hold
                      ; zero, otherwise &FF.
 $2A89 CALL $2ACD     ; Make #REGbc hold the second parameter.
 $2A8C PUSH AF        ; Save the 'error register'.
 $2A8D RST $18        ; Get the present character.
 $2A8E LD H,B         ; {Pass the result obtained from #R$2ACD to the #REGhl
 $2A8F LD L,C         ; register pair.}
 $2A90 CP ")"         ; {Check that there is a closing bracket now.
 $2A92 JR NZ,$2A7A    ; }
; The 'new' parameters are now defined.
@label=SL_DEFINE
*$2A94 POP AF         ; Fetch the 'error register'.
 $2A95 EX (SP),HL     ; The second parameter goes on the stack and the 'start'
                      ; goes to #REGhl.
 $2A96 ADD HL,DE      ; The first parameter is added to the 'start'.
 $2A97 DEC HL         ; Go back a location to get it correct.
 $2A98 EX (SP),HL     ; The 'new start' goes on the stack and the second
                      ; parameter goes to #REGhl.
 $2A99 AND A          ; {Subtract the first parameters from the second to find
 $2A9A SBC HL,DE      ; the length of the 'slice'.}
@keep
 $2A9C LD BC,$0000    ; Initialise the 'new length'.
 $2A9F JR C,$2AA8     ; A negative 'slice' is a 'null string' rather than an
                      ; error condition.
 $2AA1 INC HL         ; Allow for the inclusive byte.
 $2AA2 AND A          ; Only now test the 'error register'.
 $2AA3 JP M,$2A20     ; Jump if either parameter was out of range for the
                      ; string.
 $2AA6 LD B,H         ; {Transfer the 'new length' to #REGbc.
 $2AA7 LD C,L         ; }
@label=SL_OVER
*$2AA8 POP DE         ; Get the 'new start'.
 $2AA9 RES 6,(IY+$01) ; Ensure that a string is still indicated (reset bit 6 of
                      ; #SYSVAR(FLAGS)).
@label=SL_STORE
*$2AAD CALL $2530     ; {Return at this point if checking syntax; otherwise
 $2AB0 RET Z          ; continue into #R$2AB1.}

; THE 'STK-STORE' SUBROUTINE
;
; Used by the routine at #R$2996.
; .
; The routine at #R$2A52 continues here.
; .
; This subroutine passes the values held in the #REGa, #REGb, #REGc, #REGd and
; #REGe registers to the calculator stack. The stack thereby grows in size by 5
; bytes with every call to this subroutine.
; .
; The subroutine is normally used to transfer the parameters of strings but it
; is also used by #R$2D2B and #R$2DC1 to transfer 'small integers' to the
; stack.
; .
; Note that when storing the parameters of a string the first value stored
; (coming from the #REGa register) will be a zero if the string comes from an
; array of strings or is a 'slice' of a string. The value will be '1' for a
; complete simple string. This 'flag' is used in the #R$2AFF command routine
; when the '1' signals that the old copy of the string is to be 'reclaimed'.
;
;   A First byte (when entering at #R$2AB2 or #R$2AB6)
;   B Fifth byte
;   C Fourth byte
;   D Third byte
;   E Second byte
; O:HL The new value of #SYSVAR(STKEND)
@label=STK_ST_0
c$2AB1 XOR A          ; Signal - a string from an array of strings or a
                      ; 'sliced' string.
; This entry point is used by the routines at #R$2089, #R$2535, #R$25B3,
; #R$2634, #R$2996, #R$359C, #R$35C9, #R$361F and #R$3645.
@label=STK_STO
*$2AB2 RES 6,(IY+$01) ; Ensure the flag indicates a string result (reset bit 6
                      ; of #SYSVAR(FLAGS)).
; This entry point is used by the routines at #R$2D2B and #R$2DC1.
@label=STK_STORE
*$2AB6 PUSH BC        ; Save #REGb and #REGc briefly.
 $2AB7 CALL $33A9     ; Is there room for 5 bytes? Do not return here unless
                      ; there is room available.
 $2ABA POP BC         ; Restore #REGb and #REGc.
 $2ABB LD HL,($5C65)  ; Fetch the address of the first location above the
                      ; present stack (#SYSVAR(STKEND)).
 $2ABE LD (HL),A      ; Transfer the first byte.
 $2ABF INC HL         ; Step on.
 $2AC0 LD (HL),E      ; {Transfer the second and third bytes; for a string
 $2AC1 INC HL         ; these will be the 'start'.
 $2AC2 LD (HL),D      ; }
 $2AC3 INC HL         ; Step on.
 $2AC4 LD (HL),C      ; {Transfer the fourth and fifth bytes; for a string
 $2AC5 INC HL         ; these will be the 'length'.
 $2AC6 LD (HL),B      ; }
 $2AC7 INC HL         ; Step on so as to point to the location above the stack.
 $2AC8 LD ($5C65),HL  ; {Save this address in #SYSVAR(STKEND) and return.
 $2ACB RET            ; }

; THE 'INT-EXP' SUBROUTINE
;
; Used by the routines at #R$2996 and #R$2C02.
; .
; This subroutine returns the result of evaluating the 'next expression' as an
; integer value held in the #REGbc register pair. The subroutine also tests
; this result against a limit-value supplied in the #REGhl register pair. The
; carry flag becomes set if there is an 'out of range' error.
; .
; The #REGa register is used as an 'error register' and holds &00 if there is
; no 'previous error' and &FF if there has been one.
;
;   HL Limit value
; O:BC Expression value
; O:F Carry flag set if this value is out of range
@label=INT_EXP1
c$2ACC XOR A         ; Clear the 'error register'.
; This entry point is used by the routine at #R$2A52.
@label=INT_EXP2
*$2ACD PUSH DE       ; {Save both the #REGde and #REGhl register pairs
 $2ACE PUSH HL       ; throughout.}
 $2ACF PUSH AF       ; Save the 'error register' briefly.
 $2AD0 CALL $1C82    ; The 'next expression' is evaluated to give a 'last
                     ; value' on the calculator stack.
 $2AD3 POP AF        ; Restore the 'error register'.
 $2AD4 CALL $2530    ; {Jump forward if checking syntax.
 $2AD7 JR Z,$2AEB    ; }
 $2AD9 PUSH AF       ; Save the error register again.
 $2ADA CALL $1E99    ; The 'last value' is compressed Into #REGbc.
 $2ADD POP DE        ; Error register to #REGd.
 $2ADE LD A,B        ; {A 'next expression' that gives zero is always in error
 $2ADF OR C          ; so jump forward if it is so.
 $2AE0 SCF           ;
 $2AE1 JR Z,$2AE8    ; }
 $2AE3 POP HL        ; {Take a copy of the limit-value. This will be a
 $2AE4 PUSH HL       ; 'dimension-size', a 'DIM-limit' or a 'string length'.}
 $2AE5 AND A         ; {Now compare the result of evaluating the expression
 $2AE6 SBC HL,BC     ; against the limit.}
; The state of the carry flag and the value held in the #REGd register are now
; manipulated so as to give the appropriate value for the 'error register'.
@label=I_CARRY
*$2AE8 LD A,D        ; Fetch the 'old error value'.
 $2AE9 SBC A,$00     ; Form the 'new error value': &00 if no error at any time,
                     ; &FF or less if an 'out of range' error on this pass or
                     ; on previous ones.
; Restore the registers before returning.
@label=I_RESTORE
*$2AEB POP HL        ; {Restore #REGhl and #REGde.
 $2AEC POP DE        ; }
 $2AED RET           ; Return; 'error register' is the #REGa register.

; THE 'DE,(DE+1)' SUBROUTINE
;
; Used by the routine at #R$2996.
; .
; This subroutine performs the construction '#S/LD DE,(DE+1)/' and returns
; #REGhl pointing to '#REGde+2'.
;
;   DE Target address minus one
; O:DE Word at the target address
; O:HL Target address plus one
@label=DE_DE_1
c$2AEE EX DE,HL      ; Use #REGhl for the construction.
 $2AEF INC HL        ; Point to '#REGde+1'.
 $2AF0 LD E,(HL)     ; In effect - #S/LD E,(DE+1)/.
 $2AF1 INC HL        ; Point to '#REGde+2'.
 $2AF2 LD D,(HL)     ; In effect - #S/LD D,(DE+2)/.
 $2AF3 RET           ; Finished.

; THE 'GET-HL*DE' SUBROUTINE
;
; Used by the routines at #R$2996 and #R$2C02.
; .
; Unless syntax is being checked this subroutine calls #R$30A9 which performs
; the implied construction.
; .
; Overflow of the 16 bits available in the #REGhl register pair gives the
; report 'out of memory'. This is not exactly the true situation but it implies
; that the memory is not large enough for the task envisaged by the programmer.
;
;   DE First number (M)
;   HL Second number (N)
; O:HL M*N (if not checking syntax)
@label=GET_HLxDE
c$2AF4 CALL $2530    ; {Return directly if syntax is being checked.
 $2AF7 RET Z         ; }
 $2AF8 CALL $30A9    ; Perform the multiplication.
 $2AFB JP C,$1F15    ; Report 'Out of memory'.
 $2AFE RET           ; Finished.

; THE 'LET' COMMAND ROUTINE
;
; Used by the routines at #R$1C56, #R$1D03 and #R$2089.
; .
; This is the actual assignment routine for the LET, READ and INPUT commands.
; .
; When the destination variable is a 'newly declared variable' then
; #SYSVAR(DEST) will point to the first letter of the variable's name as it
; occurs in the BASIC line. Bit 1 of #SYSVAR(FLAGX) will be set.
; .
; However if the destination variable 'exists already' then bit 1 of
; #SYSVAR(FLAGX) will be reset and #SYSVAR(DEST) will point for a numeric
; variable to the location before the five bytes of the 'old number', and for a
; string variable to the first location of the 'old string'. The use of
; #SYSVAR(DEST) in this manner applies to simple variables and to elements of
; arrays.
; .
; Bit 0 of #SYSVAR(FLAGX) is set if the destination variable is a 'complete'
; simple string variable. (Signalling - delete the old copy.) Initially the
; current value of #SYSVAR(DEST) is collected and bit 1 of #SYSVAR(FLAGS)
; tested.
@label=LET
c$2AFF LD HL,($5C4D)  ; Fetch the present address in #SYSVAR(DEST).
 $2B02 BIT 1,(IY+$37) ; {Jump if handling a variable that 'exists already' (bit
 $2B06 JR Z,$2B66     ; 1 of #SYSVAR(FLAGX) reset).}
; A 'newly declared variable' is being used. So first the length of its name is
; found.
@keep
 $2B08 LD BC,$0005    ; Presume dealing with a numeric variable - 5 bytes.
; Enter a loop to deal with the characters of a long name. Any spaces or colour
; codes in the name are ignored.
@label=L_EACH_CH
*$2B0B INC BC         ; Add '1' to the counter for each character of a name.
@label=L_NO_SP
*$2B0C INC HL         ; Move along the variable's name.
 $2B0D LD A,(HL)      ; Fetch the 'present code'.
 $2B0E CP " "         ; {Jump back if it is a 'space', thereby ignoring spaces.
 $2B10 JR Z,$2B0C     ; }
 $2B12 JR NC,$2B1F    ; Jump forward if the code is &21 to &FF.
 $2B14 CP $10         ; {Accept, as a final code, those in the range &00 to
 $2B16 JR C,$2B29     ; &0F.}
 $2B18 CP $16         ; {Also accept the range &16 to &1F.
 $2B1A JR NC,$2B29    ; }
 $2B1C INC HL         ; Step past the control code after any of INK to OVER.
 $2B1D JR $2B0C       ; Jump back as these control codes are treated as spaces.
; Separate 'numeric' and 'string' names.
@label=L_TEST_CH
*$2B1F CALL $2C88     ; Is the code alphanumeric?
 $2B22 JR C,$2B0B     ; If It is so then accept it as a character of a 'long'
                      ; name.
 $2B24 CP "$"         ; Is the present code a '$'?
 $2B26 JP Z,$2BC0     ; Jump forward as handling a 'newly declared' simple
                      ; string.
; The 'newly declared numeric variable' presently being handled will require
; #REGbc spaces in the variables area for its name and its value. The room is
; made available and the name of the variable is copied over with the
; characters being 'marked' as required.
@label=L_SPACES
*$2B29 LD A,C         ; Copy the 'length' to #REGa.
 $2B2A LD HL,($5C59)  ; {Make #REGhl point to the '&80-byte' at the end of the
 $2B2D DEC HL         ; variables area (#SYSVAR(E-LINE)-1).}
 $2B2E CALL $1655     ; Now open up the variables area. Note: in effect #REGbc
                      ; spaces are made before the displaced '&80-byte'.
 $2B31 INC HL         ; Point to the first 'new' byte.
 $2B32 INC HL         ; {Make #REGde point to the second 'new' byte.
 $2B33 EX DE,HL       ; }
 $2B34 PUSH DE        ; Save this pointer.
 $2B35 LD HL,($5C4D)  ; Fetch the pointer to the start of the name
                      ; (#SYSVAR(DEST)).
 $2B38 DEC DE         ; Make #REGde point to the first 'new' byte.
 $2B39 SUB $06        ; {Make #REGb hold the 'number of extra letters' that are
 $2B3B LD B,A         ; found in a 'long name'.}
 $2B3C JR Z,$2B4F     ; Jump forward if dealing with a variable with a 'short
                      ; name'.
; The 'extra' codes of a long name are passed to the variables area.
@label=L_CHAR
*$2B3E INC HL         ; Point to each 'extra' code.
 $2B3F LD A,(HL)      ; Fetch the code.
 $2B40 CP $21         ; {Accept codes from &21 to &FF; ignore codes &00 to &20.
 $2B42 JR C,$2B3E     ; }
 $2B44 OR $20         ; Set bit 5, as for lower case letters.
 $2B46 INC DE         ; {Transfer the codes in turn to the 2nd 'new' byte
 $2B47 LD (DE),A      ; onwards.}
 $2B48 DJNZ $2B3E     ; Go round the loop for all the 'extra' codes.
; The last code of a 'long' name has to be #S/OR/ed with &80.
 $2B4A OR $80         ; {Mark the code as required and overwrite the last code.
 $2B4C LD (DE),A      ; }
; The first letter of the name of the variable being handled is now considered.
 $2B4D LD A,$C0       ; Prepare to mark the letter of a 'long' name.
@label=L_SINGLE
*$2B4F LD HL,($5C4D)  ; Fetch the pointer to the letter (#SYSVAR(DEST)).
 $2B52 XOR (HL)       ; #REGa holds &00 for a 'short' name and &C0 for a 'long'
                      ; name.
 $2B53 OR $20         ; Set bit 5, as for lower case letters.
 $2B55 POP HL         ; Drop the pointer now.
; The subroutine #R$2BEA is now called to enter the 'letter' into its
; appropriate location.
 $2B56 CALL $2BEA     ; Enter the letter and return with #REGhl pointing to
                      ; 'new &80-byte'.
; The 'last value' can now be transferred to the variables area. Note that at
; this point #REGhl always points to the location after the five locations
; allotted to the number.
; .
; A 'RST #o28' instruction is used to call the calculator and the 'last value'
; is deleted. However this value is not overwritten.
@label=L_NUMERIC
*$2B59 PUSH HL        ; Save the 'destination' pointer.
 $2B5A RST $28        ; Use the calculator to move #SYSVAR(STKEND) back five
                      ; bytes.
 $2B5B DEFB $02       ; #R$33A1
 $2B5C DEFB $38       ; #R$369B
 $2B5D POP HL         ; Restore the pointer.
@keep
 $2B5E LD BC,$0005    ; Give the number a 'length' of five bytes.
 $2B61 AND A          ; {Make #REGhl point to the first of the five locations
 $2B62 SBC HL,BC      ; and jump forward to make the actual transfer.
 $2B64 JR $2BA6       ; }
; Come here if considering a variable that 'exists already'. First bit 6 of
; #SYSVAR(FLAGS) is tested so as to separate numeric variables from string or
; array of string variables.
@label=L_EXISTS
*$2B66 BIT 6,(IY+$01) ; {Jump forward if handling any kind of string variable
 $2B6A JR Z,$2B72     ; (bit 6 of #SYSVAR(FLAGS) reset).}
; For numeric variables the 'new' number overwrites the 'old' number. So first
; #REGhl has to be made to point to the location after the five bytes of the
; existing entry. At present #REGhl points to the location before the five
; bytes.
@keep
 $2B6C LD DE,$0006    ; The five bytes of a number + 1.
 $2B6F ADD HL,DE      ; #REGhl now points 'after'.
 $2B70 JR $2B59       ; Jump back to make the actual transfer.
; The parameters of the string variable are fetched and complete simple strings
; separated from 'sliced' strings and array strings.
@label=L_DELETE
*$2B72 LD HL,($5C4D)  ; Fetch the 'start' (#SYSVAR(DEST)). Note: this line is
                      ; redundant.
 $2B75 LD BC,($5C72)  ; Fetch the 'length' (#SYSVAR(STRLEN)).
 $2B79 BIT 0,(IY+$37) ; {Jump if dealing with a complete simple string (bit 0
 $2B7D JR NZ,$2BAF    ; of #SYSVAR(FLAGX) set); the old string will need to be
                      ; 'deleted' in this case only.}
; When dealing with a 'slice' of an existing simple string, a 'slice' of a
; string from an array of strings or a complete string from an array of strings
; there are two distinct stages involved. The first is to build up the 'new'
; string in the work space, lengthening or shortening it as required. The
; second stage is then to copy the 'new' string to its allotted room in the
; variables area.
; .
; However do nothing if the string has no 'length'.
 $2B7F LD A,B         ; {Return if the string is a null string.
 $2B80 OR C           ;
 $2B81 RET Z          ; }
; Then make the required number of spaces available in the work space.
 $2B82 PUSH HL        ; Save the 'start' (#SYSVAR(DEST)).
 $2B83 RST $30        ; Make the necessary amount of room in the work space.
 $2B84 PUSH DE        ; Save the pointer to the first location.
 $2B85 PUSH BC        ; Save the 'length' for use later on.
 $2B86 LD D,H         ; {Make #REGde point to the last location.
 $2B87 LD E,L         ; }
 $2B88 INC HL         ; Make #REGhl point 'one past' the new locations.
 $2B89 LD (HL)," "    ; Enter a 'space' character.
 $2B8B LDDR           ; Copy this character into all the new locations. Finish
                      ; with #REGhl pointing to the first new location.
; The parameters of the string being handled are now fetched from the
; calculator stack.
 $2B8D PUSH HL        ; Save the pointer briefly.
 $2B8E CALL $2BF1     ; Fetch the 'new' parameters.
 $2B91 POP HL         ; Restore the pointer.
; Note: at this point the required amount of room has been made available in
; the work space for the 'variable in assignment'; e.g. for the statement 'LET
; A$(4 TO 8)="abcdefg"' five locations have been made.
; .
; The parameters fetched above as a 'last value' represent the string that is
; to be copied into the new locations with Procrustean lengthening or
; shortening as required.
; .
; The length of the 'new' string is compared to the length of the room made
; available for it.
 $2B92 EX (SP),HL     ; 'Length' of new area to #REGhl. 'Pointer' to new area
                      ; to stack.
 $2B93 AND A          ; {Compare the two 'lengths' and jump forward if the
 $2B94 SBC HL,BC      ; 'new' string will fit into the room, i.e. no shortening
 $2B96 ADD HL,BC      ; required.
 $2B97 JR NC,$2B9B    ; }
 $2B99 LD B,H         ; {However modify the 'new' length if it is too long.
 $2B9A LD C,L         ; }
@label=L_LENGTH
*$2B9B EX (SP),HL     ; 'Length' of new area to stack. 'Pointer' to new area to
                      ; #REGhl.
; As long as the new string is not a 'null string' it is copied into the work
; space. Procrustean lengthening is achieved automatically if the 'new' string
; is shorter than the room available for it.
 $2B9C EX DE,HL       ; 'Start' of new string to #REGhl. 'Pointer' to new area
                      ; to #REGde.
 $2B9D LD A,B         ; {Jump forward if the 'new' string is a 'null' string.
 $2B9E OR C           ;
 $2B9F JR Z,$2BA3     ; }
 $2BA1 LDIR           ; Otherwise move the 'new' string to the work space.
; The values that have been saved on the machine stack are restored.
@label=L_IN_W_S
*$2BA3 POP BC         ; 'Length' of new area.
 $2BA4 POP DE         ; 'Pointer' to new area.
 $2BA5 POP HL         ; The start - the pointer to the 'variable in assignment'
                      ; which was originally in #SYSVAR(DEST). #R$2BA6 is now
                      ; used to pass the 'new' string to the variables area.
; The following short subroutine is used to pass either a numeric value from
; the calculator stack, or a string from the work space, to its appropriate
; position in the variables area.
; .
; The subroutine is therefore used for all except 'newly declared' simple
; strings and 'complete and existing' simple strings.
@label=L_ENTER
*$2BA6 EX DE,HL       ; Change the pointers over.
 $2BA7 LD A,B         ; {Check once again that the length is not zero.
 $2BA8 OR C           ;
 $2BA9 RET Z          ; }
 $2BAA PUSH DE        ; Save the destination pointer.
 $2BAB LDIR           ; Move the numeric value or the string.
 $2BAD POP HL         ; {Return with the #REGhl register pair pointing to the
 $2BAE RET            ; first byte of the numeric value or the string.}
; When handling a 'complete and existing' simple string the new string is
; entered as if it were a 'newly declared' simple string before the existing
; version is 'reclaimed'.
@label=L_ADD
*$2BAF DEC HL         ; {Make #REGhl point to the letter of the variable's
 $2BB0 DEC HL         ; name, i.e. #SYSVAR(DEST)-3.
 $2BB1 DEC HL         ; }
 $2BB2 LD A,(HL)      ; Pick up the letter.
 $2BB3 PUSH HL        ; Save the pointer to the 'existing version'.
 $2BB4 PUSH BC        ; Save the 'length' of the 'existing string'.
 $2BB5 CALL $2BC6     ; Use #R$2BC6 to add the new string to the variables
                      ; area.
 $2BB8 POP BC         ; Restore the 'length'.
 $2BB9 POP HL         ; Restore the pointer.
 $2BBA INC BC         ; {Allow one byte for the letter and two bytes for the
 $2BBB INC BC         ; length.
 $2BBC INC BC         ; }
 $2BBD JP $19E8       ; Exit by jumping to #R$19E8 which will reclaim the whole
                      ; of the existing version.
; 'Newly declared' simple strings are handled as follows:
@label=L_NEW
*$2BC0 LD A,$DF       ; Prepare for the marking of the variable's letter.
 $2BC2 LD HL,($5C4D)  ; Fetch the pointer to the letter (#SYSVAR(DEST)).
 $2BC5 AND (HL)       ; Mark the letter as required. #R$2BC6 is now used to add
                      ; the new string to the variables area.
; The parameters of the 'new' string are fetched, sufficient room is made
; available for it and the string is then transferred.
@label=L_STRING
*$2BC6 PUSH AF        ; Save the variable's letter.
 $2BC7 CALL $2BF1     ; Fetch the 'start' and the 'length' of the 'new' string.
 $2BCA EX DE,HL       ; Move the 'start' to #REGhl.
 $2BCB ADD HL,BC      ; Make #REGhl point one past the string.
 $2BCC PUSH BC        ; Save the 'length'.
 $2BCD DEC HL         ; Make #REGhl point to the end of the string.
 $2BCE LD ($5C4D),HL  ; Save the pointer briefly in #SYSVAR(DEST).
 $2BD1 INC BC         ; {Allow one byte for the letter and two bytes for the
 $2BD2 INC BC         ; length.
 $2BD3 INC BC         ; }
 $2BD4 LD HL,($5C59)  ; {Make #REGhl point to the '&80-byte' at the end of the
 $2BD7 DEC HL         ; variables area (#SYSVAR(E-LINE)-1).}
 $2BD8 CALL $1655     ; Now open up the variables area. Note: in effect #REGbc
                      ; spaces are made before the displaced '&80-byte'.
 $2BDB LD HL,($5C4D)  ; Restore the pointer to the end of the 'new' string from
                      ; #SYSVAR(DEST).
 $2BDE POP BC         ; {Make a copy of the length of the 'new' string.
 $2BDF PUSH BC        ; }
 $2BE0 INC BC         ; Add one to the length in case the 'new' string is a
                      ; 'null' string.
 $2BE1 LDDR           ; Now copy the 'new' string + one byte.
 $2BE3 EX DE,HL       ; {Make #REGhl point to the byte that is to hold the
 $2BE4 INC HL         ; high-length.}
 $2BE5 POP BC         ; Fetch the 'length'.
 $2BE6 LD (HL),B      ; Enter the high-length.
 $2BE7 DEC HL         ; Back one.
 $2BE8 LD (HL),C      ; Enter the low-length.
 $2BE9 POP AF         ; Fetch the variable's letter.
; The following subroutine is entered with the letter of the variable, suitably
; marked, in the #REGa register. The letter overwrites the 'old &80-byte' in
; the variables area. The subroutine returns with the #REGhl register pair
; pointing to the 'new &80-byte'.
@label=L_FIRST
*$2BEA DEC HL         ; Make #REGhl point to the 'old &80-byte'.
 $2BEB LD (HL),A      ; It is overwritten with the letter of the variable.
 $2BEC LD HL,($5C59)  ; {Make #REGhl point to the 'new &80-byte'
 $2BEF DEC HL         ; (#SYSVAR(E-LINE)-1).}
 $2BF0 RET            ; Finished with all the 'newly declared variables'.

; THE 'STK-FETCH' SUBROUTINE
;
; Used by the routines at #R$04AA, #R$0605, #R$175D, #R$1C22, #R$1FFC, #R$2A52,
; #R$2AFF, #R$34BC, #R$353B, #R$359C, #R$35DE, #R$3669 and #R$3674.
; .
; This important subroutine collects the 'last value' from the calculator
; stack. The five bytes can be either a floating-point number, in 'short' or
; 'long' form, or a set of parameters that define a string.
;
; O:A First byte
; O:B Fifth byte
; O:C Fourth byte
; O:D Third byte
; O:E Second byte
@label=STK_FETCH
c$2BF1 LD HL,($5C65) ; Get #SYSVAR(STKEND).
 $2BF4 DEC HL        ; Back one.
 $2BF5 LD B,(HL)     ; The fifth value.
 $2BF6 DEC HL        ; Back one.
 $2BF7 LD C,(HL)     ; The fourth value.
 $2BF8 DEC HL        ; Back one.
 $2BF9 LD D,(HL)     ; The third value.
 $2BFA DEC HL        ; Back one.
 $2BFB LD E,(HL)     ; The second value.
 $2BFC DEC HL        ; Back one.
 $2BFD LD A,(HL)     ; The first value.
 $2BFE LD ($5C65),HL ; Reset #SYSVAR(STKEND) to its new position.
 $2C01 RET           ; Finished.

; THE 'DIM' COMMAND ROUTINE
;
; The address of this routine is found in the #R$1AA2(parameter table).
; .
; This routine establishes new arrays in the variables area. The routine starts
; by searching the existing variables area to determine whether there is an
; existing array with the same name. If such an array is found then it is
; 'reclaimed' before the new array is established.
; .
; A new array will have all its elements set to zero if it is a numeric array,
; or to 'spaces' if it is an array of strings.
@refs=$1C0D
@label=DIM
c$2C02 CALL $28B2    ; Search the variables area.
@label=D_RPORT_C
*$2C05 JP NZ,$1C8A   ; Give report C as there has been an error.
 $2C08 CALL $2530    ; {Jump forward if in 'run time'.
 $2C0B JR NZ,$2C15   ; }
 $2C0D RES 6,C       ; Test the syntax for string arrays as if they were
                     ; numeric.
 $2C0F CALL $2996    ; Check the syntax of the parenthesised expression.
 $2C12 CALL $1BEE    ; Move on to consider the next statement as the syntax was
                     ; satisfactory.
; An 'existing array' is reclaimed.
@label=D_RUN
*$2C15 JR C,$2C1F    ; Jump forward if there is no 'existing array'.
 $2C17 PUSH BC       ; Save the discriminator byte.
 $2C18 CALL $19B8    ; Find the start of the next variable.
 $2C1B CALL $19E8    ; Reclaim the 'existing array'.
 $2C1E POP BC        ; Restore the discriminator byte.
; The initial parameters of the new array are found.
@label=D_LETTER
*$2C1F SET 7,C       ; Set bit 7 in the discriminator byte.
 $2C21 LD B,$00      ; Make the dimension counter zero.
 $2C23 PUSH BC       ; Save the counter and the discriminator byte.
@keep
 $2C24 LD HL,$0001   ; {The #REGhl register pair is to hold the size of the
 $2C27 BIT 6,C       ; elements in the array: '1' for a string array, '5' for a
 $2C29 JR NZ,$2C2D   ; numeric array.
 $2C2B LD L,$05      ; }
@label=D_SIZE
*$2C2D EX DE,HL      ; Element size to #REGde.
; The following loop is accessed for each dimension that is specified in the
; parenthesised expression of the DIM statement. The total number of bytes
; required for the elements of the array is built up in the #REGde register
; pair.
@label=D_NO_LOOP
*$2C2E RST $20       ; Advance #SYSVAR(CH-ADD) on each pass.
 $2C2F LD H,$FF      ; Set a 'limit value'.
 $2C31 CALL $2ACC    ; Evaluate a parameter.
 $2C34 JP C,$2A20    ; Give an error if 'out of range'.
 $2C37 POP HL        ; Fetch the dimension counter and the discriminator byte.
 $2C38 PUSH BC       ; Save the parameter on each pass through the loop.
 $2C39 INC H         ; Increase the dimension counter on each pass also.
 $2C3A PUSH HL       ; Restack the dimension counter and the discriminator
                     ; byte.
 $2C3B LD H,B        ; {The parameter is moved to the #REGhl register pair.
 $2C3C LD L,C        ; }
 $2C3D CALL $2AF4    ; {The byte total is built up in #REGhl and then
 $2C40 EX DE,HL      ; transferred to #REGde.}
 $2C41 RST $18       ; {Get the present character and go around the loop again
 $2C42 CP ","        ; if there is another dimension.
 $2C44 JR Z,$2C2E    ; }
; At this point the #REGde register pair indicates the number of bytes required
; for the elements of the new array and the size of each dimension is stacked,
; on the machine stack.
; .
; Now check that there is indeed a closing bracket to the parenthesised
; expression.
 $2C46 CP ")"        ; Is it a ')'?
 $2C48 JR NZ,$2C05   ; Jump back if not so.
 $2C4A RST $20       ; Advance #SYSVAR(CH-ADD) past it.
; Allowance is now made for the dimension sizes.
 $2C4B POP BC        ; Fetch the dimension counter and the discriminator byte.
 $2C4C LD A,C        ; Pass the discriminator byte to the #REGa register for
                     ; later.
 $2C4D LD L,B        ; Move the counter to #REGl.
 $2C4E LD H,$00      ; Clear the #REGh register.
 $2C50 INC HL        ; {Increase the dimension counter by two and double the
 $2C51 INC HL        ; result and form the correct overall length for the
 $2C52 ADD HL,HL     ; variable by adding the element byte total.
 $2C53 ADD HL,DE     ; }
 $2C54 JP C,$1F15    ; Give the report 'Out of memory' if required.
 $2C57 PUSH DE       ; Save the element byte total.
 $2C58 PUSH BC       ; Save the dimension counter and the discriminator byte.
 $2C59 PUSH HL       ; Save the overall length also.
 $2C5A LD B,H        ; {Move the overall length to #REGbc.
 $2C5B LD C,L        ; }
; The required amount of room is made available for the new array at the end of
; the variables area.
 $2C5C LD HL,($5C59) ; {Make the #REGhl register pair point to the '&80-byte'
 $2C5F DEC HL        ; (#SYSVAR(E-LINE)-1).}
 $2C60 CALL $1655    ; The room is made available.
 $2C63 INC HL        ; #REGhl is made to point to the first new location.
; The parameters are now entered.
 $2C64 LD (HL),A     ; The letter, suitably marked, is entered first.
 $2C65 POP BC        ; {The overall length is fetched and decreased by '3'.
 $2C66 DEC BC        ;
 $2C67 DEC BC        ;
 $2C68 DEC BC        ; }
 $2C69 INC HL        ; Advance #REGhl.
 $2C6A LD (HL),C     ; Enter the low length.
 $2C6B INC HL        ; Advance #REGhl.
 $2C6C LD (HL),B     ; Enter the high length.
 $2C6D POP BC        ; Fetch the dimension counter.
 $2C6E LD A,B        ; Move it to the #REGa register.
 $2C6F INC HL        ; Advance #REGhl.
 $2C70 LD (HL),A     ; Enter the dimension count.
; The elements of the new array are now 'cleared'.
 $2C71 LD H,D        ; {#REGhl is made to point to the last location of the
 $2C72 LD L,E        ; array and #REGde to the location before that one.
 $2C73 DEC DE        ; }
 $2C74 LD (HL),$00   ; {Enter a zero into the last location but overwrite it
 $2C76 BIT 6,C       ; with 'space' if dealing with an array of strings.
 $2C78 JR Z,$2C7C    ;
 $2C7A LD (HL)," "   ; }
@label=DIM_CLEAR
*$2C7C POP BC        ; Fetch the element byte total.
 $2C7D LDDR          ; Clear the array + one extra location.
; The 'dimension sizes' are now entered.
@label=DIM_SIZES
*$2C7F POP BC        ; Get a dimension size.
 $2C80 LD (HL),B     ; Enter the high byte.
 $2C81 DEC HL        ; Back one.
 $2C82 LD (HL),C     ; Enter the low byte.
 $2C83 DEC HL        ; Back one.
 $2C84 DEC A         ; Decrease the dimension counter.
 $2C85 JR NZ,$2C7F   ; {Repeat the operation until all the dimensions have been
 $2C87 RET           ; considered; then return.}

; THE 'ALPHANUM' SUBROUTINE
;
; Used by the routines at #R$2684, #R$28B2 and #R$2AFF.
; .
; This subroutine returns with the carry flag set if the present value of the
; #REGa register denotes a valid digit or letter.
;
;   A Character code
; O:F Carry flag set if the character is alphanumeric
@label=ALPHANUM
c$2C88 CALL $2D1B    ; Test for a digit; carry will be reset for a digit.
 $2C8B CCF           ; Complement the carry flag.
 $2C8C RET C         ; Return if a digit; otherwise continue on into #R$2C8D.

; THE 'ALPHA' SUBROUTINE
;
; Used by the routines at #R$1F60, #R$2089, #R$27BD, #R$28B2 and #R$34BC.
; .
; The routine at #R$2C88 continues here.
; .
; This subroutine returns with the carry flag set if the present value of the
; #REGa register denotes a valid letter of the alphabet.
;
;   A Character code
; O:F Carry flag set if the character is a letter (A-Z, a-z)
@label=ALPHA
c$2C8D CP "A"        ; Test against &41, the code for 'A'.
 $2C8F CCF           ; Complement the carry flag.
 $2C90 RET NC        ; Return if not a valid character code.
 $2C91 CP $5B        ; Test against &5B, 1 more than the code for 'Z'.
 $2C93 RET C         ; Return if an upper case letter.
 $2C94 CP "a"        ; Test against &61, the code for 'a'.
 $2C96 CCF           ; Complement the carry flag.
 $2C97 RET NC        ; Return if not a valid character code.
 $2C98 CP $7B        ; Test against &7B, 1 more than the code for 'z'.
 $2C9A RET           ; Finished.

; THE 'DECIMAL TO FLOATING POINT' SUBROUTINE
;
; Used by the routine at #R$268D.
; .
; As part of syntax checking decimal numbers that occur in a BASIC line are
; converted to their floating-point forms. This subroutine reads the decimal
; number digit by digit and gives its result as a 'last value' on the
; calculator stack. But first it deals with the alternative notation BIN, which
; introduces a sequence of 0's and 1's giving the binary representation of the
; required number.
;
; A Code of the first character in the number
@label=DEC_TO_FP
c$2C9B CP $C4        ; Is the character a 'BIN'?
 $2C9D JR NZ,$2CB8   ; Jump if it is not 'BIN'.
@keep
 $2C9F LD DE,$0000   ; Initialise result to zero in #REGde.
@label=BIN_DIGIT
*$2CA2 RST $20       ; Get the next character.
 $2CA3 SUB "1"       ; Subtract the character code for '1'.
 $2CA5 ADC A,$00     ; 0 now gives 0 with carry set; 1 gives 0 with carry
                     ; reset.
 $2CA7 JR NZ,$2CB3   ; Any other character causes a jump to #R$2CB3 and will be
                     ; checked for syntax during or after scanning.
 $2CA9 EX DE,HL      ; Result so far to #REGhl now.
 $2CAA CCF           ; Complement the carry flag.
 $2CAB ADC HL,HL     ; Shift the result left, with the carry going to bit 0.
 $2CAD JP C,$31AD    ; Report overflow if more than 65535.
 $2CB0 EX DE,HL      ; Return the result so far to #REGde.
 $2CB1 JR $2CA2      ; Jump back for next 0 or 1.
@label=BIN_END
*$2CB3 LD B,D        ; {Copy result to #REGbc for stacking.
 $2CB4 LD C,E        ; }
 $2CB5 JP $2D2B      ; Jump forward to stack the result.
; For other numbers, first any integer part is converted; if the next character
; is a decimal, then the decimal fraction is considered.
@label=NOT_BIN
*$2CB8 CP "."        ; Is the first character a '.'?
 $2CBA JR Z,$2CCB    ; If so, jump forward.
 $2CBC CALL $2D3B    ; Otherwise, form a 'last value' of the integer.
 $2CBF CP "."        ; Is the next character a '.'?
 $2CC1 JR NZ,$2CEB   ; Jump forward to see if it is an 'E'.
 $2CC3 RST $20       ; Get the next character.
 $2CC4 CALL $2D1B    ; Is it a digit?
 $2CC7 JR C,$2CEB    ; Jump if not (e.g. 1.E4 is allowed).
 $2CC9 JR $2CD5      ; Jump forward to deal with the digits after the decimal
                     ; point.
@label=DECIMAL
*$2CCB RST $20       ; {If the number started with a decimal, see if the next
 $2CCC CALL $2D1B    ; character is a digit.}
@label=DEC_RPT_C
*$2CCF JP C,$1C8A    ; Report the error if it is not.
 $2CD2 RST $28       ; Use the calculator to stack zero as the integer part of
                     ; such numbers.
 $2CD3 DEFB $A0      ; #R$341B(stk_zero)
 $2CD4 DEFB $38      ; #R$369B
@label=DEC_STO_1
*$2CD5 RST $28       ; Use the calculator to copy the number 1 to mem-0.
 $2CD6 DEFB $A1      ; #R$341B(stk_one)
 $2CD7 DEFB $C0      ; #R$342D(st_mem_0)
 $2CD8 DEFB $02      ; #R$33A1
 $2CD9 DEFB $38      ; #R$369B
; For each passage of the following loop, the number (N) saved in the memory
; area mem-0 is fetched, divided by 10 and restored, i.e. N goes from 1 to .1
; to .01 to .001 etc. The present digit (D) is multiplied by N/10 and added to
; the 'last value' (V), giving V+D*N/10.
@label=NXT_DGT_1
*$2CDA RST $18       ; Get the present character.
 $2CDB CALL $2D22    ; If it is a digit (D) then stack it.
 $2CDE JR C,$2CEB    ; If not jump forward.
 $2CE0 RST $28       ; Now use the calculator.
 $2CE1 DEFB $E0      ; #R$340F(get_mem_0): V, D, N
 $2CE2 DEFB $A4      ; #R$341B(stk_ten): V, D, N, 10
 $2CE3 DEFB $05      ; #R$31AF: V, D, N/10
 $2CE4 DEFB $C0      ; #R$342D(st_mem_0): V, D, N/10 (N/10 is copied to mem-0)
 $2CE5 DEFB $04      ; #R$30CA: V, D*N/10
 $2CE6 DEFB $0F      ; #R$3014: V+D*N/10
 $2CE7 DEFB $38      ; #R$369B
 $2CE8 RST $20       ; Get the next character.
 $2CE9 JR $2CDA      ; Jump back (one more byte than needed) to consider it.
; Next consider any 'E notation', i.e. the form xEm or xem where m is a
; positive or negative integer.
@label=E_FORMAT
*$2CEB CP "E"        ; Is the present character an 'E'?
 $2CED JR Z,$2CF2    ; Jump forward if it is.
 $2CEF CP "e"        ; Is it an 'e'?
 $2CF1 RET NZ        ; Finished unless it is so.
@label=SIGN_FLAG
*$2CF2 LD B,$FF      ; Use #REGb as a sign flag, &FF for '+'.
 $2CF4 RST $20       ; Get the next character.
 $2CF5 CP "+"        ; Is it a '+'?
 $2CF7 JR Z,$2CFE    ; Jump forward.
 $2CF9 CP "-"        ; Is it a '-'?
 $2CFB JR NZ,$2CFF   ; Jump if neither '+' nor '-'.
 $2CFD INC B         ; Change the sign of the flag.
@label=SIGN_DONE
*$2CFE RST $20       ; Point to the first digit.
@label=ST_E_PART
*$2CFF CALL $2D1B    ; Is it indeed a digit?
 $2D02 JR C,$2CCF    ; Report the error if not.
 $2D04 PUSH BC       ; Save the flag in #REGb briefly.
 $2D05 CALL $2D3B    ; Stack ABS m, where m is the exponent.
 $2D08 CALL $2DD5    ; Transfer ABS m to #REGa.
 $2D0B POP BC        ; Restore the sign flag to #REGb.
 $2D0C JP C,$31AD    ; {Report the overflow now if ABS m is greater than 255 or
 $2D0F AND A         ; indeed greater than 127 (other values greater than about
 $2D10 JP M,$31AD    ; 39 will be detected later).}
 $2D13 INC B         ; Test the sign flag in #REGb; '+' (i.e. &FF) will now set
                     ; the zero flag.
 $2D14 JR Z,$2D18    ; Jump if sign of m is '+'.
 $2D16 NEG           ; Negate m if sign is '-'.
@label=E_FP_JUMP
*$2D18 JP $2D4F      ; Jump to assign to the 'last value' the result of
                     ; x*10#powerm.

; THE 'NUMERIC' SUBROUTINE
;
; Used by the routines at #R$1925, #R$2C88, #R$2C9B and #R$2D22.
; .
; This subroutine returns with the carry flag reset if the present value of the
; #REGa register denotes a valid digit.
;
;   A Character code
; O:F Carry flag reset if the character is a digit (0-9)
@label=NUMERIC
c$2D1B CP "0"        ; Test against &30, the code for '0'.
 $2D1D RET C         ; Return if not a valid character code.
 $2D1E CP $3A        ; Test against the upper limit.
 $2D20 CCF           ; Complement the carry flag.
 $2D21 RET           ; Finished.

; THE 'STK-DIGIT' SUBROUTINE
;
; Used by the routines at #R$2C9B and #R$2D3B.
; .
; This subroutine simply returns if the current value held in the #REGa
; register does not represent a digit but if it does then the floating-point
; form for the digit becomes the 'last value' on the calculator stack.
;
;   A Character code
; O:F Carry flag reset if the character is a digit (0-9)
@label=STK_DIGIT
c$2D22 CALL $2D1B    ; Is the character a digit?
 $2D25 RET C         ; Return if not.
 $2D26 SUB "0"       ; Replace the code by the actual digit.
; This routine continues into #R$2D28.

; THE 'STACK-A' SUBROUTINE
;
; Used by the routines at #R$22CB, #R$2382, #R$247D, #R$2580, #R$34AC, #R$3669
; and #R$3713.
; .
; The routine at #R$2D22 continues here.
; .
; This subroutine gives the floating-point form for the absolute binary value
; currently held in the #REGa register.
;
; A Value to stack
@label=STACK_A
c$2D28 LD C,A        ; Transfer the value to the #REGc register.
 $2D29 LD B,$00      ; Clear the #REGb register.
; This routine continues into #R$2D2B.

; THE 'STACK-BC' SUBROUTINE
;
; Used by the routines at #R$25F8, #R$2C9B, #R$34BC and #R$3674.
; .
; The routine at #R$2D28 continues here.
; .
; This subroutine gives the floating-point form for the absolute binary value
; currently held in the #REGbc register pair.
; .
; The form used in this and hence in the two previous subroutines as well is
; the one reserved in the Spectrum for small integers n, where
; -65535<=n<=65535. The first and fifth bytes are zero; the third and fourth
; bytes are the less significant and more significant bytes of the 16 bit
; integer n in two's complement form (if n is negative, these two bytes hold
; 65536+n); and the second byte is a sign byte, &00 for '+' and &FF for '-'.
;
; BC Value to stack
@label=STACK_BC
c$2D2B LD IY,$5C3A   ; Re-initialise #REGiy to #SYSVAR(ERR-NR).
 $2D2F XOR A         ; Clear the #REGa register.
 $2D30 LD E,A        ; And the #REGe register, to indicate '+'.
 $2D31 LD D,C        ; Copy the less significant byte to #REGd.
 $2D32 LD C,B        ; And the more significant byte to #REGc.
 $2D33 LD B,A        ; Clear the #REGb register.
 $2D34 CALL $2AB6    ; Now stack the number.
 $2D37 RST $28       ; Use the calculator to make #REGhl point to
                     ; #SYSVAR(STKEND)-5.
 $2D38 DEFB $38      ; #R$369B
 $2D39 AND A         ; Clear the carry flag.
 $2D3A RET           ; Finished.

; THE 'INTEGER TO FLOATING-POINT' SUBROUTINE
;
; Used by the routines at #R$19FB and #R$2C9B.
; .
; This subroutine returns a 'last value' on the calculator stack that is the
; result of converting an integer in a BASIC line, i.e. the integer part of the
; decimal number or the line number, to its floating-point form.
; .
; Repeated calls to #R$0074 fetch each digit of the integer in turn. An exit is
; made when a code that does not represent a digit has been fetched.
;
;   A Code of the current character
; O:A Code of the next non-digit character
@label=INT_TO_FP
c$2D3B PUSH AF       ; Save the first digit - in #REGa.
 $2D3C RST $28       ; Use the calculator.
 $2D3D DEFB $A0      ; #R$341B(stk_zero): (the 'last value' is now zero)
 $2D3E DEFB $38      ; #R$369B
 $2D3F POP AF        ; Restore the first digit.
; Now a loop is set up. As long as the code represents a digit then the
; floating-point form is found and stacked under the 'last value' (V, initially
; zero). V is then multiplied by 10 and added to the 'digit' to form a new
; 'last value' which is carried back to the start of the loop.
@label=NXT_DGT_2
*$2D40 CALL $2D22    ; {If the code represents a digit (D) then stack the
 $2D43 RET C         ; floating-point form; otherwise return.}
 $2D44 RST $28       ; Use the calculator.
 $2D45 DEFB $01      ; #R$343C: D, V
 $2D46 DEFB $A4      ; #R$341B(stk_ten): D, V, 10
 $2D47 DEFB $04      ; #R$30CA: D, 10*V
 $2D48 DEFB $0F      ; #R$3014: D+10*V
 $2D49 DEFB $38      ; #R$369B: D+10*V (this is 'V' for the next pass through
                     ; the loop)
 $2D4A CALL $0074    ; The next code goes into #REGa.
 $2D4D JR $2D40      ; Loop back with this code.

; THE 'E-FORMAT TO FLOATING-POINT' SUBROUTINE (offset &3C)
;
; Used by the routines at #R$2C9B and #R$2DE3.
; .
; The address of this routine is found in the #R$32D7(table of addresses).
; .
; This subroutine gives a 'last value' on the top of the calculator stack that
; is the result of converting a number given in the form xEm, where m is a
; positive or negative integer. The subroutine is entered with x at the top of
; the calculator stack and m in the #REGa register.
; .
; The method used is to find the absolute value of m, say p, and to multiply or
; divide x by 10#powerp according to whether m is positive or negative.
; .
; To achieve this, p is shifted right until it is zero, and x is multiplied or
; divided by 10#power(2#powern) for each set bit b(n) of p. Since p is never
; much more than 39, bits 6 and 7 of p will not normally be set.
;
; A Exponent (m)
@refs=$335B
@label=e_to_fp
c$2D4F RLCA          ; {Test the sign of m by rotating bit 7 of #REGa into the
 $2D50 RRCA          ; carry without changing #REGa.}
 $2D51 JR NC,$2D55   ; Jump if m is positive.
 $2D53 CPL           ; {Negate m in #REGa without disturbing the carry flag.
 $2D54 INC A         ; }
@label=E_SAVE
*$2D55 PUSH AF       ; Save m in #REGa briefly.
 $2D56 LD HL,$5C92   ; {This is #SYSVAR(MEMBOT); a sign flag is now stored in
 $2D59 CALL $350B    ; the first byte of mem-0, i.e. 0 for '+' and 1 for '-'.}
 $2D5C RST $28       ; The stack holds x.
 $2D5D DEFB $A4      ; #R$341B(stk_ten): x, 10
 $2D5E DEFB $38      ; #R$369B: x, 10
 $2D5F POP AF        ; Restore m in #REGa.
@label=E_LOOP
*$2D60 SRL A         ; {In the loop, shift out the next bit of m, modifying the
 $2D62 JR NC,$2D71   ; carry and zero flags appropriately; jump if carry reset.
                     ; }
 $2D64 PUSH AF       ; Save the rest of m and the flags.
 $2D65 RST $28       ; The stack holds x' and 10#power(2#powern), where x' is
                     ; an interim stage in the multiplication of x by
                     ; 10#powerm, and n=0, 1, 2, 3, 4 or 5.
 $2D66 DEFB $C1      ; #R$342D(st_mem_1): (10#power(2#powern) is copied to
                     ; mem-1)
 $2D67 DEFB $E0      ; #R$340F(get_mem_0): x', 10#power(2#powern), (1/0)
 $2D68 DEFB $00      ; {#R$368F to #R$2D6D: x', 10#power(2#powern)
 $2D69 DEFB $04      ; }
 $2D6A DEFB $04      ; #R$30CA: x'*10#power(2#powern)=x"
 $2D6B DEFB $33      ; {#R$3686 to #R$2D6E: x''
 $2D6C DEFB $02      ; }
@label=E_DIVSN
 $2D6D DEFB $05      ; #R$31AF: x/10#power(2#powern)=x'' (x'' is
                     ; x'*10#power(2#powern) or x'/10#power(2#powern) according
                     ; as m is '+' or '-')
@label=E_FETCH
 $2D6E DEFB $E1      ; #R$340F(get_mem_1): x'', 10#power(2#powern)
 $2D6F DEFB $38      ; #R$369B: x'', 10#power(2#powern)
 $2D70 POP AF        ; Restore the rest of m in #REGa, and the flags.
@label=E_TST_END
*$2D71 JR Z,$2D7B    ; Jump if m has been reduced to zero.
 $2D73 PUSH AF       ; Save the rest of m in #REGa.
 $2D74 RST $28       ; x'', 10#power(2#powern)
 $2D75 DEFB $31      ; #R$33C0: x'', 10#power(2#powern), 10#power(2#powern)
 $2D76 DEFB $04      ; #R$30CA: x'', 10#power(2#power(n+1))
 $2D77 DEFB $38      ; #R$369B: x'', 10#power(2#power(n+1))
 $2D78 POP AF        ; Restore the rest of m in #REGa.
 $2D79 JR $2D60      ; Jump back for all bits of m.
@label=E_END
*$2D7B RST $28       ; Use the calculator to delete the final power of 10
                     ; reached leaving the 'last value' x*10#powerm on the
                     ; stack.
 $2D7C DEFB $02      ; #R$33A1
 $2D7D DEFB $38      ; #R$369B
 $2D7E RET           ;

; THE 'INT-FETCH' SUBROUTINE
;
; Used by the routines at #R$2DA2, #R$2DE3, #R$30CA, #R$3297 and #R$346E.
; .
; This subroutine collects in #REGde a small integer n (-65535<=n<=65535) from
; the location addressed by #REGhl, i.e. n is normally the first (or second)
; number at the top of the calculator stack; but #REGhl can also access (by
; exchange with #REGde) a number which has been deleted from the stack.
; .
; The subroutine does not itself delete the number from the stack or from
; memory; it returns #REGhl pointing to the fourth byte of the number in its
; original position.
;
;   HL Address of the first byte of the value on the calculator stack
; O:C Sign byte
; O:DE The value
; O:HL Address of the fourth byte of the value
@label=INT_FETCH
c$2D7F INC HL        ; Point to the sign byte of the number.
 $2D80 LD C,(HL)     ; Copy the sign byte to #REGc.
; The following mechanism will two's complement the number if it is negative
; (#REGc is &FF) but leave it unaltered if it is positive (#REGc is &00).
 $2D81 INC HL        ; Point to the less significant byte.
 $2D82 LD A,(HL)     ; Collect the byte in #REGa.
 $2D83 XOR C         ; One's complement it if negative.
 $2D84 SUB C         ; This adds 1 for negative numbers; it sets the carry
                     ; unless the byte was 0.
 $2D85 LD E,A        ; Less significant byte to #REGe now.
 $2D86 INC HL        ; Point to the more significant byte.
 $2D87 LD A,(HL)     ; Collect it in #REGa.
 $2D88 ADC A,C       ; {Finish two's complementing in the case of a negative
 $2D89 XOR C         ; number; note that the carry is always left reset.}
 $2D8A LD D,A        ; More significant byte to #REGd now.
 $2D8B RET           ; Finished.

; THE 'POSITIVE-INT-STORE' SUBROUTINE
@label=P_INT_STO
u$2D8C LD C,$00      ; This (unused) entry point would store a number known to
                     ; be positive.
; This routine continues into #R$2D8E.

; THE 'INT-STORE' SUBROUTINE
;
; Used by the routines at #R$30CA, #R$3214, #R$346E and #R$3492.
; .
; This subroutine stores a small integer n (-65535<=n<=65535) in the location
; addressed by #REGhl and the four following locations, i.e. n replaces the
; first (or second) number at the top of the calculator stack. The subroutine
; returns #REGhl pointing to the first byte of n on the stack.
;
; C Sign byte
; DE Value to store
; HL Address of the first byte of the slot on the calculator stack
@label=INT_STORE
c$2D8E PUSH HL       ; The pointer to the first location is saved.
 $2D8F LD (HL),$00   ; The first byte is set to zero.
 $2D91 INC HL        ; Point to the second location.
 $2D92 LD (HL),C     ; Enter the second byte.
; The same mechanism is now used as in #R$2D7F to two's complement negative
; numbers. This is needed e.g. before and after the multiplication of small
; integers. Addition is however performed without any further two's
; complementing before or afterwards.
 $2D93 INC HL        ; Point to the third location.
 $2D94 LD A,E        ; Collect the less significant byte.
 $2D95 XOR C         ; {Two's complement it if the number is negative.
 $2D96 SUB C         ; }
 $2D97 LD (HL),A     ; Store the byte.
 $2D98 INC HL        ; Point to the fourth location.
 $2D99 LD A,D        ; Collect the more significant byte.
 $2D9A ADC A,C       ; {Two's complement it if the number is negative.
 $2D9B XOR C         ; }
 $2D9C LD (HL),A     ; Store the byte.
 $2D9D INC HL        ; Point to the fifth location.
 $2D9E LD (HL),$00   ; The fifth byte is set to zero.
 $2DA0 POP HL        ; {Return with #REGhl pointing to the first byte of n on
 $2DA1 RET           ; the stack.}

; THE 'FLOATING-POINT TO BC' SUBROUTINE
;
; Used by the routines at #R$19FB, #R$1E94, #R$25F8 and #R$2DD5.
; .
; This subroutine is used to compress the floating-point 'last value' on the
; calculator stack into the #REGbc register pair. If the result is too large,
; i.e. greater than 65536, then the subroutine returns with the carry flag set.
; If the 'last value' is negative then the zero flag is reset. The low byte of
; the result is also copied to the #REGa register.
;
; O:A LSB of the value (same as #REGc)
; O:BC Last value from the calculator stack
; O:F Carry flag set on overflow
; O:F Zero flag set if the value is positive, reset if negative
@label=FP_TO_BC
c$2DA2 RST $28       ; Use the calculator to make #REGhl point to
                     ; #SYSVAR(STKEND)-5.
 $2DA3 DEFB $38      ; #R$369B
 $2DA4 LD A,(HL)     ; {Collect the exponent byte of the 'last value'; jump if
 $2DA5 AND A         ; it is zero, indicating a 'small integer'.
 $2DA6 JR Z,$2DAD    ; }
 $2DA8 RST $28       ; Now use the calculator to round the 'last value' (V) to
                     ; the nearest integer, which also changes it to 'small
                     ; integer' form on the calculator stack if that is
                     ; possible, i.e. if -65535.5<=V<65535.5.
 $2DA9 DEFB $A2      ; #R$341B(stk_half): V, 0.5
 $2DAA DEFB $0F      ; #R$3014: V+0.5
 $2DAB DEFB $27      ; #R$36AF: INT (V+0.5)
 $2DAC DEFB $38      ; #R$369B
@label=FP_DELETE
*$2DAD RST $28       ; Use the calculator to delete the integer from the stack;
                     ; #REGde still points to it in memory (at
                     ; #SYSVAR(STKEND)).
 $2DAE DEFB $02      ; #R$33A1
 $2DAF DEFB $38      ; #R$369B
 $2DB0 PUSH HL       ; {Save both stack pointers.
 $2DB1 PUSH DE       ; }
 $2DB2 EX DE,HL      ; #REGhl now points to the number.
 $2DB3 LD B,(HL)     ; Copy the first byte to #REGb.
 $2DB4 CALL $2D7F    ; Copy bytes 2, 3 and 4 to #REGc, #REGe and #REGd.
 $2DB7 XOR A         ; Clear the #REGa register.
 $2DB8 SUB B         ; This sets the carry unless #REGb is zero.
 $2DB9 BIT 7,C       ; This sets the zero flag if the number is positive (NZ
                     ; denotes negative).
 $2DBB LD B,D        ; Copy the high byte to #REGb.
 $2DBC LD C,E        ; And the low byte to #REGc.
 $2DBD LD A,E        ; Copy the low byte to #REGa too.
 $2DBE POP DE        ; {Restore the stack pointers.
 $2DBF POP HL        ; }
 $2DC0 RET           ; Finished.

; THE 'LOG(2#powerA)' SUBROUTINE
;
; Used by the routine at #R$2DE3.
; .
; This subroutine calculates the approximate number of digits before the
; decimal in x, the number to be printed, or, if there are no digits before the
; decimal, then the approximate number of leading zeros after the decimal. It
; is entered with the #REGa register containing e', the true exponent of x, or
; e'-2, and calculates z=log to the base 10 of (2#power#REGa). It then sets
; #REGa equal to ABS INT (z+0.5), as required, using #R$2DD5 for this purpose.
;
;   A e' (true exponent) or e'-2
; O:A INT log (2#power#REGa)
@label=LOG_2_A
c$2DC1 LD D,A                   ; {The integer #REGa is stacked, either as 00
 $2DC2 RLA                      ; 00 #REGa 00 00 (for positive #REGa) or as 00
 $2DC3 SBC A,A                  ; #S/FF/ #REGa #S/FF/ 00 (for negative #REGa).}
 $2DC4 LD E,A                   ; {These bytes are first loaded into #REGa,
 $2DC5 LD C,A                   ; #REGe, #REGd, #REGc, #REGb and then #R$2AB6
 $2DC6 XOR A                    ; is called to put the number on the calculator
 $2DC7 LD B,A                   ; stack.
 $2DC8 CALL $2AB6               ; }
 $2DCB RST $28                  ; The calculator is used.
 $2DCC DEFB $34                 ; {#R$33C6: log 2 to the base 10 is now stacked
 $2DCD DEFB $EF,$1A,$20,$9A,$85 ; }
 $2DD2 DEFB $04                 ; #R$30CA: #REGa*log 2 i.e. log (2#power#REGa)
 $2DD3 DEFB $27                 ; #R$36AF: INT log (2#power#REGa)
 $2DD4 DEFB $38                 ; #R$369B
; The subroutine continues into #R$2DD5 to complete the calculation.

; THE 'FLOATING-POINT TO A' SUBROUTINE
;
; Used by the routines at #R$1E85, #R$1E94, #R$2314, #R$247D, #R$2C9B, #R$2DE3,
; #R$35C9 and #R$36C4.
; .
; The routine at #R$2DC1 continues here.
; .
; This short but vital subroutine is called at least 8 times for various
; purposes. It uses #R$2DA2 to get the 'last value' into the #REGa register
; where this is possible. It therefore tests whether the modulus of the number
; rounds to more than 255 and if it does the subroutine returns with the carry
; flag set. Otherwise it returns with the modulus of the number, rounded to the
; nearest integer, in the #REGa register, and the zero flag set to imply that
; the number was positive, or reset to imply that it was negative.
;
; O:A Last value from the calculator stack
; O:F Carry flag set on overflow
; O:F Zero flag set if the value is positive, reset if negative
@label=FP_TO_A
c$2DD5 CALL $2DA2    ; Compress the 'last value' into #REGbc.
 $2DD8 RET C         ; Return if out of range already.
 $2DD9 PUSH AF       ; Save the result and the flags.
 $2DDA DEC B         ; {Again it will be out of range if the #REGb register
 $2DDB INC B         ; does not hold zero.}
 $2DDC JR Z,$2DE1    ; Jump if in range.
 $2DDE POP AF        ; Fetch the result and the flags.
 $2DDF SCF           ; Signal the result is out of range.
 $2DE0 RET           ; Finished - unsuccessful.
@label=FP_A_END
*$2DE1 POP AF        ; Fetch the result and the flags.
 $2DE2 RET           ; Finished - successful.

; THE 'PRINT A FLOATING-POINT NUMBER' SUBROUTINE
;
; Used by the routines at #R$1FFC and #R$361F.
; .
; This subroutine prints x, the 'last value' on the calculator stack. The print
; format never occupies more than 14 spaces.
; .
; The 8 most significant digits of x, correctly rounded, are stored in an ad
; hoc print buffer in mem-3 and mem-4. Small numbers, numerically less than 1,
; and large numbers, numerically greater than 2#power27, are dealt with
; separately. The former are multiplied by 10#powern, where n is the
; approximate number of leading zeros after the decimal, while the latter are
; divided by 10#power(n-7), where n is the approximate number of digits before
; the decimal. This brings all numbers into the middle range, and the number of
; digits required before the decimal is built up in the second byte of mem-5.
; Finally the printing is done, using E-format if there are more than 8 digits
; before the decimal or, for small numbers, more than 4 leading zeros after the
; decimal.
; .
; The following program shows the range of print formats:
; .
; 10 FOR a=-11 TO 12: PRINT SGN a*9#powera,: NEXT a
; .
; i. First the sign of x is taken care of:
; .
; #LIST
; { If x is negative, the subroutine jumps to #R$2DF2, takes ABS x and prints
; the minus sign. }
; { If x is zero, x is deleted from the calculator stack, a '0' is printed and
; a return is made from the subroutine. }
; { If x is positive, the subroutine just continues. }
; LIST#
@label=PRINT_FP
c$2DE3 RST $28          ; Use the calculator.
 $2DE4 DEFB $31         ; #R$33C0: x, x
 $2DE5 DEFB $36         ; #R$3506: x, (1/0) Logical value of x.
 $2DE6 DEFB $00,$0B     ; #R$368F to #R$2DF2: x
 $2DE8 DEFB $31         ; #R$33C0: x, x
 $2DE9 DEFB $37         ; #R$34F9: x, (1/0) Logical value of x.
 $2DEA DEFB $00,$0D     ; #R$368F to #R$2DF8: x Hereafter x'=ABS x.
 $2DEC DEFB $02         ; #R$33A1: -
 $2DED DEFB $38         ; #R$369B: -
 $2DEE LD A,"0"         ; Enter the character code for '0'.
 $2DF0 RST $10          ; Print the '0'.
 $2DF1 RET              ; Finished as the 'last value' is zero.
@label=PF_NEGTVE
 $2DF2 DEFB $2A         ; #R$346A: x' x'=ABS x.
 $2DF3 DEFB $38         ; #R$369B: x'
 $2DF4 LD A,"-"         ; Enter the character code for '-'.
 $2DF6 RST $10          ; Print the '-'.
 $2DF7 RST $28          ; Use the calculator again.
@label=PF_POSTVE
 $2DF8 DEFB $A0         ; {#R$341B(stk_zero): The 15 bytes of mem-3, mem-4 and
 $2DF9 DEFB $C3,$C4,$C5 ; mem-5 are now initialised to zero to be used for a
                        ; print buffer and two counters.}
 $2DFC DEFB $02         ; #R$33A1: The stack is cleared, except for x'.
 $2DFD DEFB $38         ; #R$369B: x'
 $2DFE EXX              ; {#REGhl', which is used to hold calculator offsets
 $2DFF PUSH HL          ; (e.g. for 'STR$'), is saved on the machine stack.
 $2E00 EXX              ; }
; ii. This is the start of a loop which deals with large numbers. Every number
; x is first split into its integer part i and the fractional part f. If i is a
; small integer, i.e. if -65535<=i<=65535, it is stored in #REGde' for
; insertion into the print buffer.
@label=PF_LOOP
*$2E01 RST $28          ; Use the calculator again.
 $2E02 DEFB $31         ; #R$33C0: x', x'
 $2E03 DEFB $27         ; #R$36AF: x', INT (x')=i
 $2E04 DEFB $C2         ; #R$342D(st_mem_2): (i is stored in mem-2).
 $2E05 DEFB $03         ; #R$300F: x'-i=f
 $2E06 DEFB $E2         ; #R$340F(get_mem_2): f, i
 $2E07 DEFB $01         ; #R$343C: i, f
 $2E08 DEFB $C2         ; #R$342D(st_mem_2): (f is stored in mem-2).
 $2E09 DEFB $02         ; #R$33A1: i
 $2E0A DEFB $38         ; #R$369B: i
 $2E0B LD A,(HL)        ; {Is i a small integer (first byte zero) i.e. is ABS
 $2E0C AND A            ; i<=65535?}
 $2E0D JR NZ,$2E56      ; Jump if it is not.
 $2E0F CALL $2D7F       ; i is copied to #REGde (i, like x', >=0).
 $2E12 LD B,$10         ; #REGb is set to count 16 bits.
 $2E14 LD A,D           ; {#REGd is copied to #REGa for testing: is it zero?
 $2E15 AND A            ; }
 $2E16 JR NZ,$2E1E      ; Jump if it is not zero.
 $2E18 OR E             ; Now test #REGe.
 $2E19 JR Z,$2E24       ; Jump if #REGde is zero: x is a pure fraction.
 $2E1B LD D,E           ; {Move #REGe to #REGd and set #REGb for 8 bits: #REGd
 $2E1C LD B,$08         ; was zero and #REGe was not.}
@label=PF_SAVE
*$2E1E PUSH DE          ; {Transfer #REGde to #REGde', via the machine stack,
 $2E1F EXX              ; to be moved into the print buffer at #R$2E7B.
 $2E20 POP DE           ;
 $2E21 EXX              ; }
 $2E22 JR $2E7B         ; Jump forward.
; iii. Pure fractions are multiplied by 10#powern, where n is the approximate
; number of leading zeros after the decimal; and -n is added to the second byte
; of mem-5, which holds the number of digits needed before the decimal; a
; negative number here indicates leading zeros after the decimal.
@label=PF_SMALL
*$2E24 RST $28          ; i (i=zero here)
 $2E25 DEFB $E2         ; #R$340F(get_mem_2): i, f
 $2E26 DEFB $38         ; #R$369B: i, f
; Note that the stack is now unbalanced. An extra byte 'DEFB &02, delete' is
; needed immediately after the RST #o28. Now an expression like "2"+STR$ 0.5 is
; evaluated incorrectly as 0.5; the zero left on the stack displaces the "2"
; and is treated as a null string. Similarly all the string comparisons can
; yield incorrect values if the second string takes the form STR$ x where x is
; numerically less than 1; e.g. the expression "50"<STR$ 0.1 yields the logical
; value "true"; once again "" is used instead of "50".
 $2E27 LD A,(HL)        ; The exponent byte e of f is copied to #REGa.
 $2E28 SUB $7E          ; #REGa becomes e minus &7E, i.e. e'+2, where e' is the
                        ; true exponent of f.
 $2E2A CALL $2DC1       ; {The construction #REGa=ABS INT (LOG (2#power#REGa))
 $2E2D LD D,A           ; is performed (LOG is to base 10); i.e. #REGa=n, say:
                        ; n is copied from #REGa to #REGd.}
@ssub=LD A,($5C92+$1A)
 $2E2E LD A,($5CAC)     ; {The current count is collected from the second byte
 $2E31 SUB D            ; of #R$5CAB(mem-5) and n is subtracted from it.
@ssub=LD ($5C92+$1A),A
 $2E32 LD ($5CAC),A     ; }
 $2E35 LD A,D           ; n is copied from #REGd to #REGa.
 $2E36 CALL $2D4F       ; y=f*10#powern is formed and stacked.
 $2E39 RST $28          ; i, y
 $2E3A DEFB $31         ; #R$33C0: i, y, y
 $2E3B DEFB $27         ; #R$36AF: i, y, INT (y)=i2
 $2E3C DEFB $C1         ; #R$342D(st_mem_1): (i2 is copied to mem-1).
 $2E3D DEFB $03         ; #R$300F: i, y-i2
 $2E3E DEFB $E1         ; #R$340F(get_mem_1): i, y-i2, i2
 $2E3F DEFB $38         ; #R$369B: i, f2, i2 (f2=y-i2)
 $2E40 CALL $2DD5       ; i2 is transferred from the stack to #REGa.
 $2E43 PUSH HL          ; The pointer to f2 is saved.
@ssub=LD ($5C92+$0F),A
 $2E44 LD ($5CA1),A     ; i2 is stored in the first byte of #R$5CA1(mem-3): a
                        ; digit for printing.
 $2E47 DEC A            ; {i2 will not count as a digit for printing if it is
 $2E48 RLA              ; zero; #REGa is manipulated so that zero will produce
 $2E49 SBC A,A          ; zero but a non-zero digit will produce 1.
 $2E4A INC A            ; }
@ssub=LD HL,$5C92+$19
 $2E4B LD HL,$5CAB      ; {The zero or one is inserted into the first byte of
 $2E4E LD (HL),A        ; #R$5CAB(mem-5) (the number of digits for printing)
 $2E4F INC HL           ; and added to the second byte of mem-5 (the number of
 $2E50 ADD A,(HL)       ; digits before the decimal).
 $2E51 LD (HL),A        ; }
 $2E52 POP HL           ; The pointer to f2 is restored.
 $2E53 JP $2ECF         ; Jump to store f2 in buffer (#REGhl now points to f2,
                        ; #REGde to i2).
; iv. Numbers greater than 2#power27 are similarly multiplied by 2#power(-n+7),
; reducing the number of digits before the decimal to 8, and the loop is
; re-entered at #R$2E01.
@label=PF_LARGE
*$2E56 SUB $80          ; e minus &80 is e', the true exponent of i.
 $2E58 CP $1C           ; Is e' less than 28?
 $2E5A JR C,$2E6F       ; Jump if it is less.
 $2E5C CALL $2DC1       ; n is formed in #REGa.
 $2E5F SUB $07          ; And reduced to n-7.
 $2E61 LD B,A           ; Then copied to #REGb.
@ssub=LD HL,$5C92+$1A
 $2E62 LD HL,$5CAC      ; {n-7 is added in to the second byte of
 $2E65 ADD A,(HL)       ; #R$5CAB(mem-5), the number of digits required before
 $2E66 LD (HL),A        ; the decimal in x.}
 $2E67 LD A,B           ; {Then i is multiplied by 10#power(-n+7). This will
 $2E68 NEG              ; bring it into medium range for printing.
 $2E6A CALL $2D4F       ; }
 $2E6D JR $2E01         ; Round the loop again to deal with the now
                        ; medium-sized number.
; v. The integer part of x is now stored in the print buffer in mem-3 and
; mem-4.
@label=PF_MEDIUM
*$2E6F EX DE,HL         ; #REGde now points to i, #REGhl to f.
 $2E70 CALL $2FBA       ; The mantissa of i is now in #REGd', #REGe', #REGd,
                        ; #REGe.
 $2E73 EXX              ; Get the exchange registers.
 $2E74 SET 7,D          ; True numerical bit 7 to #REGd'.
 $2E76 LD A,L           ; Exponent byte e of i to #REGa.
 $2E77 EXX              ; Back to the main registers.
 $2E78 SUB $80          ; True exponent e'=e minus &80 to #REGa.
 $2E7A LD B,A           ; This gives the required bit count.
; Note that the case where i is a small integer (less than 65536) re-enters
; here.
@label=PF_BITS
*$2E7B SLA E            ; {The mantissa of i is now rotated left and all the
 $2E7D RL D             ; bits of i are thus shifted into mem-4 and each byte
 $2E7F EXX              ; of mem-4 is decimal adjusted at each shift.
 $2E80 RL E             ;
 $2E82 RL D             ; }
 $2E84 EXX              ; Back to the main registers.
@keep=$18
@ssub=LD HL,$5C92+$18
 $2E85 LD HL,$5CAA      ; {Address of fifth byte of #R$5CA6(mem-4) to #REGhl;
 $2E88 LD C,$05         ; count of 5 bytes to #REGc.}
@label=PF_BYTES
*$2E8A LD A,(HL)        ; Get the byte of mem-4.
 $2E8B ADC A,A          ; Shift it left, taking in the new bit.
 $2E8C DAA              ; Decimal adjust the byte.
 $2E8D LD (HL),A        ; Restore it to mem-4.
 $2E8E DEC HL           ; Point to next byte of mem-4.
 $2E8F DEC C            ; Decrease the byte count by one.
 $2E90 JR NZ,$2E8A      ; Jump for each byte of mem-4.
 $2E92 DJNZ $2E7B       ; Jump for each bit of INT (x).
; Decimal adjusting each byte of mem-4 gave 2 decimal digits per byte, there
; being at most 9 digits. The digits will now be re-packed, one to a byte, in
; mem-3 and mem-4, using the instruction '#S/RLD/'.
 $2E94 XOR A            ; #REGa is cleared to receive the digits.
@ssub=LD HL,$5C92+$14
 $2E95 LD HL,$5CA6      ; Source address: first byte of #R$5CA6(mem-4).
@ssub=LD DE,$5C92+$0F
 $2E98 LD DE,$5CA1      ; Destination: first byte of #R$5CA1(mem-3).
 $2E9B LD B,$09         ; There are at most 9 digits.
 $2E9D RLD              ; The left nibble of mem-4 is discarded.
 $2E9F LD C,$FF         ; &FF in #REGc will signal a leading zero, &00 will
                        ; signal a non-leading zero.
@label=PF_DIGITS
*$2EA1 RLD              ; Left nibble of (#REGhl) to #REGa, right nibble of
                        ; (#REGhl) to left.
 $2EA3 JR NZ,$2EA9      ; Jump if digit in #REGa is not zero.
 $2EA5 DEC C            ; {Test for a leading zero: it will now give zero
 $2EA6 INC C            ; reset.}
 $2EA7 JR NZ,$2EB3      ; Jump if it was a leading zero.
@label=PF_INSERT
*$2EA9 LD (DE),A        ; Insert the digit now.
 $2EAA INC DE           ; Point to next destination.
 $2EAB INC (IY+$71)     ; {One more digit for printing, and one more before the
 $2EAE INC (IY+$72)     ; decimal.}
 $2EB1 LD C,$00         ; Change the flag from leading zero to other zero.
@label=PF_TEST_2
*$2EB3 BIT 0,B          ; {The source pointer needs to be incremented on every
 $2EB5 JR Z,$2EB8       ; second passage through the loop, when #REGb is odd.
 $2EB7 INC HL           ; }
@label=PF_ALL_9
*$2EB8 DJNZ $2EA1       ; Jump back for all 9 digits.
@ssub=LD A,($5C92+$19)
 $2EBA LD A,($5CAB)     ; {Get counter from the first byte of #R$5CAB(mem-5):
 $2EBD SUB $09          ; were there 9 digits excluding leading zeros?}
 $2EBF JR C,$2ECB       ; If not, jump to get more digits.
 $2EC1 DEC (IY+$71)     ; Prepare to round: reduce count to 8.
 $2EC4 LD A,$04         ; {Compare 9th digit, byte 4 of #R$5CA6(mem-4), with 4
 $2EC6 CP (IY+$6F)      ; to set carry for rounding up.}
 $2EC9 JR $2F0C         ; Jump forward to round up.
@label=PF_MORE
*$2ECB RST $28          ; Use the calculator again.
 $2ECC DEFB $02         ; #R$33A1: - (i is now deleted).
 $2ECD DEFB $E2         ; #R$340F(get_mem_2): f
 $2ECE DEFB $38         ; #R$369B: f
; vi. The fractional part of x is now stored in the print buffer.
@label=PF_FRACTN
*$2ECF EX DE,HL         ; #REGde now points to f.
 $2ED0 CALL $2FBA       ; The mantissa of f is now in #REGd', #REGe', #REGd,
                        ; #REGe.
 $2ED3 EXX              ; Get the exchange registers.
 $2ED4 LD A,$80         ; {The exponent of f is reduced to zero, by shifting
 $2ED6 SUB L            ; the bits of f &80 minus e places right, where #REGl'
 $2ED7 LD L,$00         ; contained e.}
 $2ED9 SET 7,D          ; True numerical bit to bit 7 of #REGd'.
 $2EDB EXX              ; Restore the main registers.
 $2EDC CALL $2FDD       ; Now make the shift.
@label=PF_FRN_LP
*$2EDF LD A,(IY+$71)    ; Get the digit count.
 $2EE2 CP $08           ; Are there already 8 digits?
 $2EE4 JR C,$2EEC       ; If not, jump forward.
 $2EE6 EXX              ; {If 8 digits, just use f to round i up, rotating
 $2EE7 RL D             ; #REGd' left to set the carry.}
 $2EE9 EXX              ; {Restore main registers and jump forward to round up.
 $2EEA JR $2F0C         ; }
@keep
@label=PF_FR_DGT
*$2EEC LD BC,$0200      ; Initial zero to #REGc, count of 2 to #REGb.
@label=PF_FR_EXX
*$2EEF LD A,E           ; {#REG(d'e'de) is multiplied by 10 in 2 stages, first
 $2EF0 CALL $2F8B       ; #REGde then #REGde', each byte by byte in 2 steps,
 $2EF3 LD E,A           ; and the integer part of the result is obtained in
 $2EF4 LD A,D           ; #REGc to be passed into the print buffer.
 $2EF5 CALL $2F8B       ;
 $2EF8 LD D,A           ; }
 $2EF9 PUSH BC          ; {The count and the result alternate between #REGbc
 $2EFA EXX              ; and #REGbc'.
 $2EFB POP BC           ; }
 $2EFC DJNZ $2EEF       ; Loop back once through the exchange registers.
@ssub=LD HL,$5C92+$0F
 $2EFE LD HL,$5CA1      ; The start - 1st byte of #R$5CA1(mem-3).
 $2F01 LD A,C           ; Result to #REGa for storing.
 $2F02 LD C,(IY+$71)    ; Count of digits so far in number to #REGc.
 $2F05 ADD HL,BC        ; Address the first empty byte.
 $2F06 LD (HL),A        ; Store the next digit.
 $2F07 INC (IY+$71)     ; Step up the count of digits.
 $2F0A JR $2EDF         ; Loop back until there are 8 digits.
; vii. The digits stored in the print buffer are rounded to a maximum of 8
; digits for printing.
@label=PF_ROUND
*$2F0C PUSH AF          ; Save the carry flag for the rounding.
@ssub=LD HL,$5C92+$0F
 $2F0D LD HL,$5CA1      ; Base address of number: #R$5CA1(mem-3), byte 1.
 $2F10 LD C,(IY+$71)    ; {Offset (number of digits in number) to #REGbc.
 $2F13 LD B,$00         ; }
 $2F15 ADD HL,BC        ; Address the last byte of the number.
 $2F16 LD B,C           ; Copy #REGc to #REGb as the counter.
 $2F17 POP AF           ; Restore the carry flag.
@label=PF_RND_LP
*$2F18 DEC HL           ; This is the last byte of the number.
 $2F19 LD A,(HL)        ; Get the byte into #REGa.
 $2F1A ADC A,$00        ; Add in the carry i.e. round up.
 $2F1C LD (HL),A        ; Store the rounded byte in the buffer.
 $2F1D AND A            ; {If the byte is 0 or 10, #REGb will be decremented
 $2F1E JR Z,$2F25       ; and the final zero (or the 10) will not be counted
 $2F20 CP $0A           ; for printing.}
 $2F22 CCF              ; Reset the carry for a valid digit.
 $2F23 JR NC,$2F2D      ; Jump if carry reset.
@label=PF_R_BACK
*$2F25 DJNZ $2F18       ; Jump back for more rounding or more final zeros.
 $2F27 LD (HL),$01      ; {There is overflow to the left; an extra 1 is needed
 $2F29 INC B            ; here.}
 $2F2A INC (IY+$72)     ; It is also an extra digit before the decimal.
@label=PF_COUNT
*$2F2D LD (IY+$71),B    ; #REGb now sets the count of the digits to be printed
                        ; (final zeros will not be printed).
 $2F30 RST $28          ; f is to be deleted.
 $2F31 DEFB $02         ; #R$33A1: -
 $2F32 DEFB $38         ; #R$369B: -
 $2F33 EXX              ; {The calculator offset saved on the stack is restored
 $2F34 POP HL           ; to #REGhl'.
 $2F35 EXX              ; }
; viii. The number can now be printed. First #REGc will be set to hold the
; number of digits to be printed, not counting final zeros, while #REGb will
; hold the number of digits required before the decimal.
@ssub=LD BC,($5C92+$19)
 $2F36 LD BC,($5CAB)    ; The counters are set (first two bytes of
                        ; #R$5CAB(mem-5)).
@ssub=LD HL,$5C92+$0F
 $2F3A LD HL,$5CA1      ; The start of the digits (first byte of
                        ; #R$5CA1(mem-3)).
 $2F3D LD A,B           ; {If more than 9, or fewer than minus 4, digits are
 $2F3E CP $09           ; required before the decimal, then E-format will be
 $2F40 JR C,$2F46       ; needed.}
 $2F42 CP $FC           ; {Fewer than 4 means more than 4 leading zeros after
 $2F44 JR C,$2F6C       ; the decimal.}
@label=PF_NOT_E
*$2F46 AND A            ; {Are there no digits before the decimal? If so, print
 $2F47 CALL Z,$15EF     ; an initial zero.}
; The next entry point is also used to print the digits needed for E-format
; printing.
@label=PF_E_SBRN
*$2F4A XOR A            ; Start by setting #REGa to zero.
 $2F4B SUB B            ; {Subtract #REGb: minus will mean there are digits
 $2F4C JP M,$2F52       ; before the decimal; jump forward to print them.}
 $2F4F LD B,A           ; #REGa is now required as a counter.
 $2F50 JR $2F5E         ; Jump forward to print the decimal part.
@label=PF_OUT_LP
*$2F52 LD A,C           ; {Copy the number of digits to be printed to #REGa. If
 $2F53 AND A            ; #REGa is 0, there are still final zeros to print
 $2F54 JR Z,$2F59       ; (#REGb is non-zero), so jump.}
 $2F56 LD A,(HL)        ; Get a digit from the print buffer.
 $2F57 INC HL           ; Point to the next digit.
 $2F58 DEC C            ; Decrease the count by one.
@label=PF_OUT_DT
*$2F59 CALL $15EF       ; Print the appropriate digit.
 $2F5C DJNZ $2F52       ; Loop back until #REGb is zero.
@label=PF_DC_OUT
*$2F5E LD A,C           ; {It is time to print the decimal, unless #REGc is now
 $2F5F AND A            ; zero; in that case, return - finished.
 $2F60 RET Z            ; }
 $2F61 INC B            ; Add 1 to #REGb - include the decimal.
 $2F62 LD A,"."         ; Put the code for '.' into #REGa.
@label=PF_DEC_0S
*$2F64 RST $10          ; Print the '.'.
 $2F65 LD A,"0"         ; Enter the character code for '0'.
 $2F67 DJNZ $2F64       ; Loop back to print all needed zeros.
 $2F69 LD B,C           ; Set the count for all remaining digits.
 $2F6A JR $2F52         ; Jump back to print them.
@label=PF_E_FRMT
*$2F6C LD D,B           ; The count of digits is copied to #REGd.
 $2F6D DEC D            ; It is decremented to give the exponent.
 $2F6E LD B,$01         ; One digit is required before the decimal in E-format.
 $2F70 CALL $2F4A       ; All the part of the number before the 'E' is now
                        ; printed.
 $2F73 LD A,"E"         ; Enter the character code for 'E'.
 $2F75 RST $10          ; Print the 'E'.
 $2F76 LD C,D           ; Exponent to #REGc now for printing.
 $2F77 LD A,C           ; And to #REGa for testing.
 $2F78 AND A            ; Its sign is tested.
 $2F79 JP P,$2F83       ; Jump if it is positive.
 $2F7C NEG              ; Otherwise, negate it in #REGa.
 $2F7E LD C,A           ; Then copy it back to #REGc for printing.
 $2F7F LD A,"-"         ; Enter the character code for '-'.
 $2F81 JR $2F85         ; Jump to print the sign.
@label=PF_E_POS
*$2F83 LD A,"+"         ; Enter the character code for '+'.
@label=PF_E_SIGN
*$2F85 RST $10          ; Now print the sign: '+' or '-'.
 $2F86 LD B,$00         ; #REGbc holds the exponent for printing.
 $2F88 JP $1A1B         ; Jump back to print it and finish.

; THE 'CA=10*A+C' SUBROUTINE
;
; This subroutine is called by #R$2DE3 to multiply each byte of #REG(d'e'de) by
; 10 and return the integer part of the result in the #REGc register. On entry,
; the #REGa register contains the byte to be multiplied by 10 and the #REGc
; register contains the carry over from the previous byte. On return, the #REGa
; register contains the resulting byte and the #REGc register the carry forward
; to the next byte.
;
;   A First number (M)
;   C Second number (N)
; O:A LSB of 10*M+N
; O:C MSB of 10*M+N
@label=CA_10A_C
c$2F8B PUSH DE       ; Save whichever #REGde pair is in use.
 $2F8C LD L,A        ; {Copy the multiplicand from #REGa to #REGhl.
 $2F8D LD H,$00      ; }
 $2F8F LD E,L        ; {Copy it to #REGde too.
 $2F90 LD D,H        ; }
 $2F91 ADD HL,HL     ; Double #REGhl.
 $2F92 ADD HL,HL     ; Double it again.
 $2F93 ADD HL,DE     ; Add in #REGde to give #REGhl=5*#REGa.
 $2F94 ADD HL,HL     ; Double again: now #REGhl=10*#REGa.
 $2F95 LD E,C        ; Copy #REGc to #REGde (#REGd is zero) for addition.
 $2F96 ADD HL,DE     ; Now #REGhl=10*#REGa+#REGc.
 $2F97 LD C,H        ; #REGh is copied to #REGc.
 $2F98 LD A,L        ; #REGl is copied to #REGa, completing the task.
 $2F99 POP DE        ; The #REGde register pair is restored.
 $2F9A RET           ; Finished.

; THE 'PREPARE TO ADD' SUBROUTINE
;
; Used by the routine at #R$3014.
; .
; This subroutine is the first of four subroutines that are used by the main
; arithmetic operation routines - #R$300F, #R$3014, #R$30CA and #R$31AF.
; .
; This particular subroutine prepares a floating-point number for addition,
; mainly by replacing the sign bit with a true numerical bit 1, and negating
; the number (two's complement) if it is negative. The exponent is returned in
; the #REGa register and the first byte is set to &00 for a positive number and
; &FF for a negative number.
;
;   HL Address of the first byte of the number
; O:A Exponent byte
@label=PREP_ADD
c$2F9B LD A,(HL)     ; Transfer the exponent to #REGa.
 $2F9C LD (HL),$00   ; Presume a positive number.
 $2F9E AND A         ; {If the number is zero then the preparation is already
 $2F9F RET Z         ; finished.}
 $2FA0 INC HL        ; Now point to the sign byte.
 $2FA1 BIT 7,(HL)    ; Set the zero flag for positive number.
 $2FA3 SET 7,(HL)    ; Restore the true numeric bit.
 $2FA5 DEC HL        ; Point to the first byte again.
 $2FA6 RET Z         ; Positive numbers have been prepared, but negative
                     ; numbers need to be two's complemented.
 $2FA7 PUSH BC       ; Save any earlier exponent.
@keep
 $2FA8 LD BC,$0005   ; There are 5 bytes to be handled.
 $2FAB ADD HL,BC     ; Point one past the last byte.
 $2FAC LD B,C        ; Transfer the 5 to #REGb.
 $2FAD LD C,A        ; Save the exponent in #REGc.
 $2FAE SCF           ; Set carry flag for negation.
@label=NEG_BYTE
*$2FAF DEC HL        ; Point to each byte in turn.
 $2FB0 LD A,(HL)     ; Get each byte.
 $2FB1 CPL           ; One's complement the byte.
 $2FB2 ADC A,$00     ; Add in carry for negation.
 $2FB4 LD (HL),A     ; Restore the byte.
 $2FB5 DJNZ $2FAF    ; Loop 5 times.
 $2FB7 LD A,C        ; Restore the exponent to #REGa.
 $2FB8 POP BC        ; Restore any earlier exponent.
 $2FB9 RET           ; Finished.

; THE 'FETCH TWO NUMBERS' SUBROUTINE
;
; Used by the routines at #R$2DE3, #R$3014, #R$30CA and #R$31AF.
; .
; This subroutine is called by #R$3014, #R$30CA and #R$31AF to get two numbers
; from the calculator stack and put them into the registers, including the
; exchange registers.
; .
; On entry to the subroutine the #REGhl register pair points to the first byte
; of the first number (M) and the #REGde register pair points to the first byte
; of the second number (N).
; .
; When the subroutine is called from #R$30CA or #R$31AF the sign of the result
; is saved in the second byte of the first number.
;
;   A Bit 7 holds the sign bit of the result (when called from #R$30CA or
; .   #R$31AF)
;   DE Address of the first byte of N
;   HL Address of the first byte of M
; O:H'B'C'CB The five bytes of M
; O:L'D'E'DE The five bytes of N
@label=FETCH_TWO
c$2FBA PUSH HL       ; #REGhl is preserved.
 $2FBB PUSH AF       ; #REGaf is preserved.
; Call the five bytes of the first number M1, M2, M3, M4 and M5, and the five
; bytes of the second number N1, N2, N3, N4 and N5.
 $2FBC LD C,(HL)     ; M1 to #REGc.
 $2FBD INC HL        ; Next.
 $2FBE LD B,(HL)     ; M2 to #REGb.
 $2FBF LD (HL),A     ; Copy the sign of the result to bit 7 of (#REGhl).
 $2FC0 INC HL        ; Next.
 $2FC1 LD A,C        ; M1 to #REGa.
 $2FC2 LD C,(HL)     ; M3 to #REGc.
 $2FC3 PUSH BC       ; Save M2 and M3 on the machine stack.
 $2FC4 INC HL        ; Next.
 $2FC5 LD C,(HL)     ; M4 to #REGc.
 $2FC6 INC HL        ; Next.
 $2FC7 LD B,(HL)     ; M5 to #REGb.
 $2FC8 EX DE,HL      ; #REGhl now points to N1.
 $2FC9 LD D,A        ; M1 to #REGd.
 $2FCA LD E,(HL)     ; N1 to #REGe.
 $2FCB PUSH DE       ; Save M1 and N1 on the machine stack.
 $2FCC INC HL        ; Next.
 $2FCD LD D,(HL)     ; N2 to #REGd.
 $2FCE INC HL        ; Next.
 $2FCF LD E,(HL)     ; N3 to #REGe.
 $2FD0 PUSH DE       ; Save N2 and N3 on the machine stack.
 $2FD1 EXX           ; Get the exchange registers.
 $2FD2 POP DE        ; N2 to #REGd' and N3 to #REGe'.
 $2FD3 POP HL        ; M1 to #REGh' and N1 to #REGl'.
 $2FD4 POP BC        ; M2 to #REGb' and M3 to #REGc'.
 $2FD5 EXX           ; Get the original set of registers.
 $2FD6 INC HL        ; Next.
 $2FD7 LD D,(HL)     ; N4 to #REGd.
 $2FD8 INC HL        ; Next.
 $2FD9 LD E,(HL)     ; N5 to #REGe.
 $2FDA POP AF        ; Restore the original #REGaf.
 $2FDB POP HL        ; Restore the original #REGhl.
 $2FDC RET           ; Finished.
; Summary:
; .
; #LIST
; { M1 - M5 are in #REGh', #REGb', #REGc', #REGc, #REGb. }
; { N1 - N5 are in #REGl', #REGd', #REGe', #REGd, #REGe. }
; { #REGhl points to the first byte of the first number. }
; LIST#

; THE 'SHIFT ADDEND' SUBROUTINE
;
; Used by the routines at #R$2DE3 and #R$3014.
; .
; This subroutine shifts a floating-point number up to 32 places right to line
; it up properly for addition. The number with the smaller exponent has been
; put in the addend position before this subroutine is called. Any overflow to
; the right, into the carry, is added back into the number. If the exponent
; difference is greater than 32, or the carry ripples right back to the
; beginning of the number then the number is set to zero so that the addition
; will not alter the other number (the augend).
;
; A Number of shifts to perform
; D'E'DE Mantissa of number to shift right
; L' Sign byte of number to shift right (&00 or &FF)
@label=SHIFT_FP
c$2FDD AND A         ; {If the exponent difference is zero, the subroutine
 $2FDE RET Z         ; returns at once.}
 $2FDF CP $21        ; {If the difference is greater than &20, jump forward.
 $2FE1 JR NC,$2FF9   ; }
 $2FE3 PUSH BC       ; Save #REGbc briefly.
 $2FE4 LD B,A        ; Transfer the exponent difference to #REGb to count the
                     ; shifts right.
@label=ONE_SHIFT
*$2FE5 EXX           ; {Arithmetic shift right for #REGl', preserving the sign
 $2FE6 SRA L         ; marker bits.}
 $2FE8 RR D          ; {Rotate right with carry #REGd', #REGe', #REGd and
 $2FEA RR E          ; #REGe, thereby shifting the whole five bytes of the
 $2FEC EXX           ; number to the right as many times as #REGb counts.
 $2FED RR D          ;
 $2FEF RR E          ; }
 $2FF1 DJNZ $2FE5    ; Loop back until #REGb reaches zero.
 $2FF3 POP BC        ; Restore the original #REGbc.
 $2FF4 RET NC        ; Done if no carry to retrieve.
 $2FF5 CALL $3004    ; Retrieve carry.
 $2FF8 RET NZ        ; Return unless the carry rippled right back. (In this
                     ; case there is nothing to add.)
@label=ADDEND_0
*$2FF9 EXX           ; Fetch #REGl', #REGd' and #REGe'.
 $2FFA XOR A         ; Clear the #REGa register.
; This entry point is used by the routine at #R$30CA.
@label=ZEROS_4_5
*$2FFB LD L,$00      ; {Set the addend to zero in #REGd', #REGe', #REGd and
 $2FFD LD D,A        ; #REGe, together with its marker byte (sign indicator)
 $2FFE LD E,L        ; #REGl', which was &00 for a positive number and &FF for
 $2FFF EXX           ; a negative number. This produces only 4 zero bytes when
@keep
 $3000 LD DE,$0000   ; called for near underflow by #R$30CA.}
 $3003 RET           ; Finished.

; THE 'ADD-BACK' SUBROUTINE
;
; Used by the routines at #R$2FDD and #R$30CA.
; .
; This subroutine adds back into the number any carry which has overflowed to
; the right. In the extreme case, the carry ripples right back to the left of
; the number.
; .
; When this subroutine is called during addition, this ripple means that a
; mantissa of 0.5 was shifted a full 32 places right, and the addend will now
; be set to zero; when called from #R$30CA, it means that the exponent must be
; incremented, and this may result in overflow.
;
;   D'E'DE Mantissa of number shifted right
; O:F Zero flag set on overflow (mantissa was #S/FFFFFFFF/)
@label=ADD_BACK
c$3004 INC E         ; Add carry to rightmost byte.
 $3005 RET NZ        ; Return if no overflow to left.
 $3006 INC D         ; Continue to the next byte.
 $3007 RET NZ        ; Return if no overflow to left.
 $3008 EXX           ; Get the next byte.
 $3009 INC E         ; Increment it too.
 $300A JR NZ,$300D   ; Jump if no overflow.
 $300C INC D         ; Increment the last byte.
@label=ALL_ADDED
*$300D EXX           ; Restore the original registers.
 $300E RET           ; Finished.

; THE 'SUBTRACTION' OPERATION (offset &03)
;
; Used by the routine at #R$353B.
; .
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called via the calculator literal &03 by the routines at #R$03F8, #R$1DDA,
; #R$2320, #R$2382, #R$247D, #R$25F8, #R$2DE3, #R$3449, #R$36A0, #R$36AF,
; #R$36C4, #R$3713, #R$3783, #R$37AA, #R$37B5, #R$37E2, #R$3833 and #R$3843. It
; is also called indirectly via #R$33A2.
; .
; This subroutine simply changes the sign of the subtrahend and carries on into
; #R$3014.
; .
; Note that #REGhl points to the minuend and #REGde points to the subtrahend.
; (See #R$3014 for more details.)
;
; DE Address of the first byte of the subtrahend
; HL Address of the first byte of the minuend
@refs=$335B
@label=subtract
c$300F EX DE,HL      ; Exchange the pointers.
 $3010 CALL $346E    ; Change the sign of the subtrahend.
 $3013 EX DE,HL      ; Exchange the pointers back and continue into #R$3014.

; THE 'ADDITION' OPERATION (offset &0F)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called via the calculator literal &0F by the routines at #R$03F8, #R$1DAB,
; #R$2320, #R$2382, #R$247D, #R$25F8, #R$2C9B, #R$2D3B, #R$2DA2, #R$3449,
; #R$36C4, #R$3713, #R$3783, #R$37B5, #R$37E2 and #R$3833. It is also called
; indirectly via #R$33A2, and the routine at #R$300F continues here.
; .
; The first of three major arithmetical subroutines, this subroutine carries
; out the floating-point addition of two numbers, each with a 4-byte mantissa
; and a 1-byte exponent. In these three subroutines, the two numbers at the top
; of the calculator stack are added/multiplied/divided to give one number at
; the top of the calculator stack, a 'last value'.
; .
; #REGhl points to the second number from the top, the
; augend/multiplier/dividend. #REGde points to the number at the top of the
; calculator stack, the addend/multiplicand/divisor. Afterwards #REGhl points
; to the resultant 'last value' whose address can also be considered to be
; #SYSVAR(STKEND)-5.
; .
; But the addition subroutine first tests whether the 2 numbers to be added are
; 'small integers'. If they are, it adds them quite simply in #REGhl and
; #REGbc, and puts the result directly on the stack. No two's complementing is
; needed before or after the addition, since such numbers are held on the stack
; in two's complement form, ready for addition.
;
; DE Address of the first byte of the addend/multiplicand/divisor
; HL Address of the first byte of the augend/multiplier/dividend
@refs=$335B
@label=addition
c$3014 LD A,(DE)     ; {Test whether the first bytes of both numbers are zero.
 $3015 OR (HL)       ; }
 $3016 JR NZ,$303E   ; If not, jump for full addition.
 $3018 PUSH DE       ; Save the pointer to the second number.
 $3019 INC HL        ; {Point to the second byte of the first number and save
 $301A PUSH HL       ; that pointer too.}
 $301B INC HL        ; Point to the less significant byte.
 $301C LD E,(HL)     ; Fetch it in #REGe.
 $301D INC HL        ; Point to the more significant byte.
 $301E LD D,(HL)     ; Fetch it in #REGd.
 $301F INC HL        ; {Move on to the second byte of the second number.
 $3020 INC HL        ;
 $3021 INC HL        ; }
 $3022 LD A,(HL)     ; Fetch it in #REGa (this is the sign byte).
 $3023 INC HL        ; Point to the less significant byte.
 $3024 LD C,(HL)     ; Fetch it in #REGc.
 $3025 INC HL        ; Point to the more significant byte.
 $3026 LD B,(HL)     ; Fetch it in #REGb.
 $3027 POP HL        ; {Fetch the pointer to the sign byte of the first number;
 $3028 EX DE,HL      ; put it in #REGde, and the number in #REGhl.}
 $3029 ADD HL,BC     ; Perform the addition: result in #REGhl.
 $302A EX DE,HL      ; Result to #REGde, sign byte to #REGhl.
 $302B ADC A,(HL)    ; {Add the sign bytes and the carry into #REGa; this will
 $302C RRCA          ; detect any overflow.}
 $302D ADC A,$00     ; A non-zero #REGa now indicates overflow.
 $302F JR NZ,$303C   ; Jump to reset the pointers and to do full addition.
 $3031 SBC A,A       ; Define the correct sign byte for the result.
 $3032 LD (HL),A     ; Store it on the stack.
 $3033 INC HL        ; Point to the next location.
 $3034 LD (HL),E     ; Store the low byte of the result.
 $3035 INC HL        ; Point to the next location.
 $3036 LD (HL),D     ; Store the high byte of the result.
 $3037 DEC HL        ; {Move the pointer back to address the first byte of the
 $3038 DEC HL        ; result.
 $3039 DEC HL        ; }
 $303A POP DE        ; Restore #SYSVAR(STKEND) to #REGde.
 $303B RET           ; Finished.
@ignoreua
; Note that the number -65536 can arise here in the form 00 #S/FF/ 00 00 00 as
; the result of the addition of two smaller negative integers, e.g. -65000 and
; -536. It is simply stacked in this form. This is a mistake. The Spectrum
; system cannot handle this number.
; .
; Most functions treat it as zero, and it is printed as -1E-38, obtained by
; treating is as 'minus zero' in an illegitimate format.
; .
; One possible remedy would be to test for this number at about byte
; #R$3032(#h3032) and, if it is present, to make the second byte &80 and the
; first byte &91, so producing the full five-byte floating-point form of the
; number, i.e. 91 80 00 00 00, which causes no problems. See also the
; #R$3225(remarks in 'truncate').
@label=ADDN_OFLW
*$303C DEC HL        ; Restore the pointer to the first number.
 $303D POP DE        ; Restore the pointer to the second number.
@label=FULL_ADDN
*$303E CALL $3293    ; Re-stack both numbers in full five-byte floating-point
                     ; form.
; The full addition subroutine first calls #R$2F9B for each number, then gets
; the two numbers from the calculator stack and puts the one with the smaller
; exponent into the addend position. It then calls #R$2FDD to shift the addend
; up to 32 decimal places right to line it up for addition. The actual addition
; is done in a few bytes, a single shift is made for carry (overflow to the
; left) if needed, the result is two's complemented if negative, and any
; arithmetic overflow is reported; otherwise the subroutine jumps to #R$3155 to
; normalise the result and return it to the stack with the correct sign bit
; inserted into the second byte.
 $3041 EXX           ; Exchange the registers.
 $3042 PUSH HL       ; Save the next literal address.
 $3043 EXX           ; Exchange the registers.
 $3044 PUSH DE       ; Save pointer to the addend.
 $3045 PUSH HL       ; Save pointer to the augend.
 $3046 CALL $2F9B    ; Prepare the augend.
 $3049 LD B,A        ; Save its exponent in #REGb.
 $304A EX DE,HL      ; Exchange the pointers.
 $304B CALL $2F9B    ; Prepare the addend.
 $304E LD C,A        ; Save its exponent in #REGc.
 $304F CP B          ; {If the first exponent is smaller, keep the first number
 $3050 JR NC,$3055   ; in the addend position; otherwise change the exponents
 $3052 LD A,B        ; and the pointers back again.
 $3053 LD B,C        ;
 $3054 EX DE,HL      ; }
@label=SHIFT_LEN
*$3055 PUSH AF       ; Save the larger exponent in #REGa.
 $3056 SUB B         ; The difference between the exponents is the length of
                     ; the shift right.
 $3057 CALL $2FBA    ; Get the two numbers from the stack.
 $305A CALL $2FDD    ; Shift the addend right.
 $305D POP AF        ; Restore the larger exponent.
 $305E POP HL        ; #REGhl is to point to the result.
 $305F LD (HL),A     ; Store the exponent of the result.
 $3060 PUSH HL       ; Save the pointer again.
 $3061 LD L,B        ; {M4 to #REGh and M5 to #REGl (see #R$2FBA).
 $3062 LD H,C        ; }
 $3063 ADD HL,DE     ; Add the two right bytes.
 $3064 EXX           ; {N2 to #REGh' and N3 to #REGl' (see #R$2FBA).
 $3065 EX DE,HL      ; }
 $3066 ADC HL,BC     ; Add left bytes with carry.
 $3068 EX DE,HL      ; Result back in #REG(d'e').
 $3069 LD A,H        ; {Add #REGh', #REGl' and the carry; the resulting
 $306A ADC A,L       ; mechanisms will ensure that a single shift right is
 $306B LD L,A        ; called if the sum of 2 positive numbers has overflowed
 $306C RRA           ; left, or the sum of 2 negative numbers has not
 $306D XOR L         ; overflowed left.
 $306E EXX           ; }
 $306F EX DE,HL      ; The result is now in #REG(ded'e').
 $3070 POP HL        ; Get the pointer to the exponent.
 $3071 RRA           ; {The test for shift (#REGh', #REGl' were &00 for
 $3072 JR NC,$307C   ; positive numbers and &FF for negative numbers).}
 $3074 LD A,$01      ; #REGa counts a single shift right.
 $3076 CALL $2FDD    ; The shift is called.
 $3079 INC (HL)      ; {Add 1 to the exponent; this may lead to arithmetic
 $307A JR Z,$309F    ; overflow.}
@label=TEST_NEG
*$307C EXX           ; {Test for negative result: get sign bit of #REGl' into
 $307D LD A,L        ; #REGa (this now correctly indicates the sign of the
 $307E AND $80       ; result).
 $3080 EXX           ; }
 $3081 INC HL        ; {Store it in the second byte position of the result on
 $3082 LD (HL),A     ; the calculator stack.
 $3083 DEC HL        ; }
 $3084 JR Z,$30A5    ; If it is zero, then do not two's complement the result.
 $3086 LD A,E        ; Get the first byte.
 $3087 NEG           ; Negate it.
 $3089 CCF           ; {Complement the carry for continued negation, and store
 $308A LD E,A        ; byte.}
 $308B LD A,D        ; Get the next byte.
 $308C CPL           ; One's complement it.
 $308D ADC A,$00     ; Add in the carry for negation.
 $308F LD D,A        ; Store the byte.
 $3090 EXX           ; {Proceed to get next byte into the #REGa register.
 $3091 LD A,E        ; }
 $3092 CPL           ; One's complement it.
 $3093 ADC A,$00     ; Add in the carry for negation.
 $3095 LD E,A        ; Store the byte.
 $3096 LD A,D        ; Get the last byte.
 $3097 CPL           ; One's complement it.
 $3098 ADC A,$00     ; Add in the carry for negation.
 $309A JR NC,$30A3   ; Done if no carry.
 $309C RRA           ; {Else, get .5 into mantissa and add 1 to the exponent;
 $309D EXX           ; this will be needed when two negative numbers add to
 $309E INC (HL)      ; give an exact power of 2, and it may lead to arithmetic
                     ; overflow.}
@label=ADD_REP_6
*$309F JP Z,$31AD    ; {Give the error if required.
 $30A2 EXX           ; }
@label=END_COMPL
*$30A3 LD D,A        ; {Store the last byte.
 $30A4 EXX           ; }
@label=GO_NC_MLT
*$30A5 XOR A         ; Clear #REGa and the carry flag.
 $30A6 JP $3155      ; Exit via #R$3155.

; THE 'HL=HL*DE' SUBROUTINE
;
; This subroutine is called by #R$2AF4 and by #R$30CA to perform the 16-bit
; multiplication as stated.
; .
; Any overflow of the 16 bits available is dealt with on return from the
; subroutine.
;
;   DE First number (M)
;   HL Second number (N)
; O:HL M*N
@label=HL_HLxDE
c$30A9 PUSH BC       ; #REGbc is saved.
 $30AA LD B,$10      ; It is to be a 16-bit multiplication.
 $30AC LD A,H        ; #REGa holds the high byte.
 $30AD LD C,L        ; #REGc holds the low byte.
@keep
 $30AE LD HL,$0000   ; Initialise the result to zero.
@label=HL_LOOP
*$30B1 ADD HL,HL     ; Double the result.
 $30B2 JR C,$30BE    ; Jump if overflow.
 $30B4 RL C          ; Rotate bit 7 of #REGc into the carry.
 $30B6 RLA           ; Rotate the carry bit into bit 0 and bit 7 into the carry
                     ; flag.
 $30B7 JR NC,$30BC   ; Jump if the carry flag is reset.
 $30B9 ADD HL,DE     ; Otherwise add #REGde in once.
 $30BA JR C,$30BE    ; Jump if overflow.
@label=HL_AGAIN
*$30BC DJNZ $30B1    ; Repeat until 16 passes have been made.
@label=HL_END
*$30BE POP BC        ; Restore #REGbc.
 $30BF RET           ; Finished.

; THE 'PREPARE TO MULTIPLY OR DIVIDE' SUBROUTINE
;
; Used by the routines at #R$30CA and #R$31AF.
; .
; This subroutine prepares a floating-point number for multiplication or
; division, returning with carry set if the number is zero, getting the sign of
; the result into the #REGa register, and replacing the sign bit in the number
; by the true numeric bit, 1.
;
;   A Bit 7 holds 0 on the first call, or the sign bit of the first number
;   HL Address of the first byte of the number
; O:A Bit 7 holds the sign bit of the first number, or the sign bit of the
; .   product/quotient
; O:F Carry flag set if the number is zero
@label=PREP_M_D
c$30C0 CALL $34E9    ; {If the number is zero, return with the carry flag set.
 $30C3 RET C         ; }
 $30C4 INC HL        ; Point to the sign byte.
 $30C5 XOR (HL)      ; Get sign for result into #REGa (like signs give plus,
                     ; unlike give minus); also reset the carry flag.
 $30C6 SET 7,(HL)    ; Set the true numeric bit.
 $30C8 DEC HL        ; Point to the exponent again.
 $30C9 RET           ; Return with carry flag reset.

; THE 'MULTIPLICATION' OPERATION (offset &04)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called via the calculator literal &04 by the routines at #R$03F8, #R$2320,
; #R$2382, #R$247D, #R$25F8, #R$2C9B, #R$2D3B, #R$2D4F, #R$2DC1, #R$3449,
; #R$36A0, #R$36C4, #R$3713, #R$3783, #R$37B5, #R$37E2, #R$3833 and #R$3851. It
; is also called indirectly via #R$33A2.
; .
; This subroutine first tests whether the two numbers to be multiplied are
; 'small integers'. If they are, it uses #R$2D7F to get them from the stack,
; #R$30A9 to multiply them and #R$2D8E to return the result to the stack. Any
; overflow of this 'short multiplication' (i.e. if the result is not itself a
; 'small integer') causes a jump to multiplication in full five byte
; floating-point form (see below).
;
; DE Address of the first byte of the second number
; HL Address of the first byte of the first number
@refs=$335B
@label=multiply
c$30CA LD A,(DE)     ; {Test whether the first bytes of both numbers are zero.
 $30CB OR (HL)       ; }
 $30CC JR NZ,$30F0   ; If not, jump for 'long' multiplication.
 $30CE PUSH DE       ; Save the pointers to the second number.
 $30CF PUSH HL       ; And to the first number.
 $30D0 PUSH DE       ; And to the second number yet again.
 $30D1 CALL $2D7F    ; Fetch sign in #REGc, number in #REGde.
 $30D4 EX DE,HL      ; Number to #REGhl now.
 $30D5 EX (SP),HL    ; Number to stack, second pointer to #REGhl.
 $30D6 LD B,C        ; Save first sign in #REGb.
 $30D7 CALL $2D7F    ; Fetch second sign in #REGc, number in #REGde.
 $30DA LD A,B        ; {Form sign of result in #REGa: like signs give plus
 $30DB XOR C         ; (&00), unlike give minus (&FF).}
 $30DC LD C,A        ; Store sign of result in #REGc.
 $30DD POP HL        ; Restore the first number to #REGhl.
 $30DE CALL $30A9    ; Perform the actual multiplication.
 $30E1 EX DE,HL      ; Store the result in #REGde.
 $30E2 POP HL        ; Restore the pointer to the first number.
 $30E3 JR C,$30EF    ; Jump on overflow to 'full' multiplication.
 $30E5 LD A,D        ; {These 5 bytes ensure that 00 #S/FF/ 00 00 00 is
 $30E6 OR E          ; replaced by zero; that they should not be needed if this
 $30E7 JR NZ,$30EA   ; number were excluded from the system is noted at
 $30E9 LD C,A        ; #R$303C.}
@label=MULT_RSLT
*$30EA CALL $2D8E    ; Now store the result on the stack.
 $30ED POP DE        ; Restore #SYSVAR(STKEND) to #REGde.
 $30EE RET           ; Finished.
@label=MULT_OFLW
*$30EF POP DE        ; Restore the pointer to the second number.
@label=MULT_LONG
*$30F0 CALL $3293    ; Re-stack both numbers in full five byte floating-point
                     ; form.
; The full multiplication subroutine prepares the first number for
; multiplication by calling #R$30C0, returning if it is zero; otherwise the
; second number is prepared by again calling #R$30C0, and if it is zero the
; subroutine goes to set the result to zero. Next it fetches the two numbers
; from the calculator stack and multiplies their mantissas in the usual way,
; rotating the first number (treated as the multiplier) right and adding in the
; second number (the multiplicand) to the result whenever the multiplier bit is
; set. The exponents are then added together and checks are made for overflow
; and for underflow (giving the result zero). Finally, the result is normalised
; and returned to the calculator stack with the correct sign bit in the second
; byte.
 $30F3 XOR A         ; #REGa is set to zero so that the sign of the first
                     ; number will go into #REGa.
 $30F4 CALL $30C0    ; {Prepare the first number, and return if zero. (Result
 $30F7 RET C         ; already zero.)}
 $30F8 EXX           ; Exchange the registers.
 $30F9 PUSH HL       ; Save the next literal address.
 $30FA EXX           ; Exchange the registers.
 $30FB PUSH DE       ; Save the pointer to the multiplicand.
 $30FC EX DE,HL      ; Exchange the pointers.
 $30FD CALL $30C0    ; Prepare the 2nd number.
 $3100 EX DE,HL      ; Exchange the pointers again.
 $3101 JR C,$315D    ; Jump forward if 2nd number is zero.
 $3103 PUSH HL       ; Save the pointer to the result.
 $3104 CALL $2FBA    ; Get the two numbers from the stack.
 $3107 LD A,B        ; M5 to #REGa (see #R$2FBA).
 $3108 AND A         ; Prepare for a subtraction.
 $3109 SBC HL,HL     ; Initialise #REGhl to zero for the result.
 $310B EXX           ; Exchange the registers.
 $310C PUSH HL       ; Save M1 and N1 (see #R$2FBA).
 $310D SBC HL,HL     ; Also initialise #REGhl' for the result.
 $310F EXX           ; Exchange the registers.
 $3110 LD B,$21      ; #REGb counts thirty three shifts.
 $3112 JR $3125      ; Jump forward into the loop.
; Now enter the multiplier loop.
@label=MLT_LOOP
*$3114 JR NC,$311B   ; Jump forward to #R$311B if no carry, i.e. the multiplier
                     ; bit was reset.
 $3116 ADD HL,DE     ; {Else, add the multiplicand in #REG(d'e'de) (see
 $3117 EXX           ; #R$2FBA) into the result being built up in #REG(h'l'hl).
 $3118 ADC HL,DE     ;
 $311A EXX           ; }
@label=NO_ADD
*$311B EXX           ; {Whether multiplicand was added or not, shift result
 $311C RR H          ; right in #REG(h'l'hl); the shift is done by rotating
 $311E RR L          ; each byte with carry, so that any bit that drops into
 $3120 EXX           ; the carry is picked up by the next byte, and the shift
 $3121 RR H          ; continued into #REG(b'c'ca).
 $3123 RR L          ; }
@label=STRT_MLT
*$3125 EXX           ; {Shift right the multiplier in #REG(b'c'ca) (see #R$2FBA
 $3126 RR B          ; and above). A final bit dropping into the carry will
 $3128 RR C          ; trigger another add of the multiplicand to the result.
 $312A EXX           ;
 $312B RR C          ;
 $312D RRA           ; }
 $312E DJNZ $3114    ; Loop 33 times to get all the bits.
 $3130 EX DE,HL      ; {Move the result from #REG(h'l'hl) to #REG(d'e'de).
 $3131 EXX           ;
 $3132 EX DE,HL      ;
 $3133 EXX           ; }
; Now add the exponents together.
 $3134 POP BC        ; Restore the exponents - M1 and N1.
 $3135 POP HL        ; Restore the pointer to the exponent byte.
 $3136 LD A,B        ; {Get the sum of the two exponent bytes in #REGa, and the
 $3137 ADD A,C       ; correct carry.}
 $3138 JR NZ,$313B   ; {If the sum equals zero then clear the carry; else leave
 $313A AND A         ; it unchanged.}
@label=MAKE_EXPT
*$313B DEC A         ; {Prepare to increase the exponent by &80.
 $313C CCF           ; }
; This entry point is used by the routine at #R$31AF.
@label=DIVN_EXPT
*$313D RLA           ; {These few bytes very cleverly make the correct exponent
 $313E CCF           ; byte. Rotating left then right gets the exponent byte
 $313F RRA           ; (true exponent plus &80) into #REGa.}
 $3140 JP P,$3146    ; If the sign flag is reset, no report of arithmetic
                     ; overflow needed.
 $3143 JR NC,$31AD   ; Report the overflow if carry reset.
 $3145 AND A         ; Clear the carry now.
@label=OFLW1_CLR
*$3146 INC A         ; {The exponent byte is now complete; but if #REGa is zero
 $3147 JR NZ,$3151   ; a further check for overflow is needed.
 $3149 JR C,$3151    ; }
 $314B EXX           ; {If there is no carry set and the result is already in
 $314C BIT 7,D       ; normal form (bit 7 of #REGd' set) then there is overflow
 $314E EXX           ; to report; but if bit 7 of #REGd' is reset, the result
 $314F JR NZ,$31AD   ; in just in range, i.e. just under 2**127.}
@label=OFLW2_CLR
*$3151 LD (HL),A     ; Store the exponent byte, at last.
 $3152 EXX           ; {Pass the fifth result byte to #REGa for the
 $3153 LD A,B        ; normalisation sequence, i.e. the overflow from #REGl
 $3154 EXX           ; into #REGb'.}
; This entry point is used by the routine at #R$3014.
; .
; The remainder of the subroutine deals with normalisation and is common to all
; the arithmetic routines.
@label=TEST_NORM
*$3155 JR NC,$316C   ; If no carry then normalise now.
 $3157 LD A,(HL)     ; {Else, deal with underflow (zero result) or near
 $3158 AND A         ; underflow (result 2**-128): return exponent to #REGa,
@label=NEAR_ZERO
*$3159 LD A,$80      ; test if #REGa is zero (case 2**-128) and if so produce
 $315B JR Z,$315E    ; 2**-128 if number is normal; otherwise produce zero. The
@label=ZERO_RSLT
*$315D XOR A         ; exponent must then be set to zero (for zero) or 1 (for
@label=SKIP_ZERO
*$315E EXX           ; 2**-128).
 $315F AND D         ;
 $3160 CALL $2FFB    ;
 $3163 RLCA          ; }
 $3164 LD (HL),A     ; Restore the exponent byte.
 $3165 JR C,$3195    ; Jump if case 2**-128.
 $3167 INC HL        ; {Otherwise, put zero into second byte of result on the
 $3168 LD (HL),A     ; calculator stack.
 $3169 DEC HL        ; }
 $316A JR $3195      ; Jump forward to transfer the result.
; The actual normalisation operation.
@label=NORMALISE
*$316C LD B,$20      ; {Normalise the result by up to 32 shifts left of
@label=SHIFT_ONE
*$316E EXX           ; #REG(d'e'de) (with #REGa adjoined) until bit 7 of #REGd'
 $316F BIT 7,D       ; is set. #REGa holds zero after addition so no precision
 $3171 EXX           ; is gained or lost; #REGa holds the fifth byte from
 $3172 JR NZ,$3186   ; #REGb' after multiplication or division; but as only
 $3174 RLCA          ; about 32 bits can be correct, no precision is lost. Note
 $3175 RL E          ; that #REGa is rotated circularly, with branch at
 $3177 RL D          ; carry...eventually a random process.
 $3179 EXX           ;
 $317A RL E          ;
 $317C RL D          ;
 $317E EXX           ; }
 $317F DEC (HL)      ; The exponent is decremented on each shift.
 $3180 JR Z,$3159    ; If the exponent becomes zero, then numbers from 2**-129
                     ; are rounded up to 2**-128.
 $3182 DJNZ $316E    ; Loop back, up to 32 times.
 $3184 JR $315D      ; If bit 7 never became 1 then the whole result is to be
                     ; zero.
; Finish the normalisation by considering the 'carry'.
@label=NORML_NOW
*$3186 RLA           ; {After normalisation add back any final carry that went
 $3187 JR NC,$3195   ; into #REGa. Jump forward if the carry does not ripple
 $3189 CALL $3004    ; right back.
 $318C JR NZ,$3195   ; }
 $318E EXX           ; {If it should ripple right back then set mantissa to 0.5
 $318F LD D,$80      ; and increment the exponent. This action may lead to
 $3191 EXX           ; arithmetic overflow (final case).
 $3192 INC (HL)      ;
 $3193 JR Z,$31AD    ; }
; The final part of the subroutine involves passing the result to the bytes
; reserved for it on the calculator stack and resetting the pointers.
@label=OFLOW_CLR
*$3195 PUSH HL       ; Save the result pointer.
 $3196 INC HL        ; Point to the sign byte in the result.
 $3197 EXX           ; {The result is moved from #REG(d'e'de) to #REG(bcde),
 $3198 PUSH DE       ; and then to #REG(acde).
 $3199 EXX           ;
 $319A POP BC        ;
 $319B LD A,B        ; }
 $319C RLA           ; {The sign bit is retrieved from its temporary store and
 $319D RL (HL)       ; transferred to its correct position of bit 7 of the
 $319F RRA           ; first byte of the mantissa.}
 $31A0 LD (HL),A     ; The first byte is stored.
 $31A1 INC HL        ; Next.
 $31A2 LD (HL),C     ; The second byte is stored.
 $31A3 INC HL        ; Next.
 $31A4 LD (HL),D     ; The third byte is stored.
 $31A5 INC HL        ; Next.
 $31A6 LD (HL),E     ; The fourth byte is stored.
 $31A7 POP HL        ; Restore the pointer to the result.
 $31A8 POP DE        ; Restore the pointer to second number.
 $31A9 EXX           ; Exchange the register.
 $31AA POP HL        ; Restore the next literal address.
 $31AB EXX           ; Exchange the registers.
 $31AC RET           ; Finished.
; This entry point is used by the routines at #R$2C9B, #R$3014 and #R$31AF.
; .
; Report 6 - Arithmetic overflow.
@label=REPORT_6
*$31AD RST $08       ; {Call the error handling routine.
 $31AE DEFB $05      ; }

; THE 'DIVISION' OPERATION (offset &05)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called via the calculator literal &05 by the routines at #R$03F8, #R$2382,
; #R$247D, #R$2C9B, #R$2D4F, #R$36A0, #R$37DA, #R$37E2, #R$3833 and #R$3851. It
; is also called indirectly via #R$33A2.
; .
; This subroutine first prepares the divisor by calling #R$30C0, reporting
; arithmetic overflow if it is zero; then it prepares the dividend again
; calling #R$30C0, returning if it is zero. Next it fetches the two numbers
; from the calculator stack and divides their mantissa by means of the usual
; restoring division, trial subtracting the divisor from the dividend and
; restoring if there is carry, otherwise adding 1 to the quotient. The maximum
; precision is obtained for a 4-byte division, and after subtracting the
; exponents the subroutine exits by joining the later part of #R$30CA.
;
; DE Address of the first byte of the second number (divisor)
; HL Address of the first byte of the first number (dividend)
@refs=$335B
@label=division
c$31AF CALL $3293    ; Use full floating-point forms.
 $31B2 EX DE,HL      ; Exchange the pointers.
 $31B3 XOR A         ; #REGa is set to 0, so that the sign of the first number
                     ; will go into #REGa.
 $31B4 CALL $30C0    ; {Prepare the divisor and give the report for arithmetic
 $31B7 JR C,$31AD    ; overflow if it is zero.}
 $31B9 EX DE,HL      ; Exchange the pointers.
 $31BA CALL $30C0    ; {Prepare the dividend and return if it is zero (result
 $31BD RET C         ; already zero).}
 $31BE EXX           ; Exchange the pointers.
 $31BF PUSH HL       ; Save the next literal address.
 $31C0 EXX           ; Exchange the registers.
 $31C1 PUSH DE       ; Save pointer to divisor.
 $31C2 PUSH HL       ; Save pointer to dividend.
 $31C3 CALL $2FBA    ; Get the two numbers from the stack.
 $31C6 EXX           ; Exchange the registers.
 $31C7 PUSH HL       ; Save M1 and N1 (the exponent bytes) on the machine
                     ; stack.
 $31C8 LD H,B        ; {Copy the four bytes of the dividend from registers
 $31C9 LD L,C        ; #REG(b'c'cb) (i.e. M2, M3, M4 and M5; see #R$2FBA) to
 $31CA EXX           ; the registers #REG(h'l'hl).
 $31CB LD H,C        ;
 $31CC LD L,B        ; }
 $31CD XOR A         ; Clear #REGa and reset the carry flag.
 $31CE LD B,$DF      ; #REGb will count upwards from -33 to -1 (&DF to &FF),
                     ; looping on minus and will jump again on zero for extra
                     ; precision.
 $31D0 JR $31E2      ; Jump forward into the division loop for the first trial
                     ; subtraction.
; Now enter the division loop.
@label=DIV_LOOP
*$31D2 RLA           ; {Shift the result left into #REG(b'c'ca), shifting out
 $31D3 RL C          ; the bits already there, picking up 1 from the carry
 $31D5 EXX           ; whenever it is set, and rotating left each byte with
 $31D6 RL C          ; carry to achieve the 32-bit shift.
 $31D8 RL B          ;
 $31DA EXX           ; }
@label=DIV_34TH
 $31DB ADD HL,HL     ; {Move what remains of the dividend left in #REG(h'l'hl)
 $31DC EXX           ; before the next trial subtraction; if a bit drops into
 $31DD ADC HL,HL     ; the carry, force no restore and a bit for the quotient,
 $31DF EXX           ; thus retrieving the lost bit and allowing a full 32-bit
 $31E0 JR C,$31F2    ; divisor.}
@label=DIV_START
*$31E2 SBC HL,DE     ; {Trial subtract divisor in #REG(d'e'de) from rest of
 $31E4 EXX           ; dividend in #REG(h'l'hl); there is no initial carry (see
 $31E5 SBC HL,DE     ; previous step).
 $31E7 EXX           ; }
 $31E8 JR NC,$31F9   ; Jump forward if there is no carry.
 $31EA ADD HL,DE     ; {Otherwise restore, i.e. add back the divisor. Then
 $31EB EXX           ; clear the carry so that there will be no bit for the
 $31EC ADC HL,DE     ; quotient (the divisor 'did not go').
 $31EE EXX           ;
 $31EF AND A         ; }
 $31F0 JR $31FA      ; Jump forward to the counter.
@label=SUBN_ONLY
*$31F2 AND A         ; {Just subtract with no restore and go on to set the
 $31F3 SBC HL,DE     ; carry flag because the lost bit of the dividend is to be
 $31F5 EXX           ; retrieved and used for the quotient.
 $31F6 SBC HL,DE     ;
 $31F8 EXX           ; }
@label=NO_RSTORE
*$31F9 SCF           ; One for the quotient in #REG(b'c'ca).
@label=COUNT_ONE
*$31FA INC B         ; Step the loop count up by one.
 $31FB JP M,$31D2    ; Loop 32 times for all bits.
 $31FE PUSH AF       ; Save any 33rd bit for extra precision (the present
                     ; carry).
@bfix=JR Z,$31DB
 $31FF JR Z,$31E2    ; Trial subtract yet again for any 34th bit; the '#S/PUSH
                     ; AF/' above saves this bit too.
@ignoreua
; #IF({fix}<2)!!Note: this jump is made to the wrong place. No 34th bit will
; ever be obtained without first shifting the dividend. Hence important results
; like 1/10 and 1/1000 are not rounded up as they should be. Rounding up never
; occurs when it depends on the 34th bit. The jump should have been to #R$31DB
; above, i.e. byte &3200 in the ROM should read &DA instead of &E1.!!
 $3201 LD E,A        ; {Now move the four bytes that form the mantissa of the
 $3202 LD D,C        ; result from #REG(b'c'ca) to #REG(d'e'de).
 $3203 EXX           ;
 $3204 LD E,C        ;
 $3205 LD D,B        ; }
 $3206 POP AF        ; {Then put the 34th and 33rd bits into #REGb' to be
 $3207 RR B          ; picked up on normalisation.
 $3209 POP AF        ;
 $320A RR B          ;
 $320C EXX           ; }
 $320D POP BC        ; Restore the exponent bytes M1 and N1.
 $320E POP HL        ; Restore the pointer to the result.
 $320F LD A,B        ; {Get the difference between the two exponent bytes into
 $3210 SUB C         ; #REGa and set the carry flag if required.}
 $3211 JP $313D      ; Exit via #R$313D.

; THE 'INTEGER TRUNCATION TOWARDS ZERO' SUBROUTINE (offset &3A)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called via the calculator literal &3A by the routine at #R$36AF.
; .
; This subroutine (say I(x)) returns the result of integer truncation of x, the
; 'last value', towards zero. Thus I(2.4) is 2 and I(-2.4) is -2. The
; subroutine returns at once if x is in the form of a 'short integer'. It
; returns zero if the exponent byte of x is less than &81 (ABS x is less than
; 1). If I(x) is a 'short integer' the subroutine returns it in that form. It
; returns x if the exponent byte is &A0 or greater (x has no significant
; non-integral part). Otherwise the correct number of bytes of x are set to
; zero and, if needed, one more byte is split with a mask.
;
; HL Address of the first byte of the number
@refs=$335B
@label=truncate
c$3214 LD A,(HL)     ; Get the exponent byte of x into #REGa.
 $3215 AND A         ; {If #REGa is zero, return since x is already a small
 $3216 RET Z         ; integer.}
 $3217 CP $81        ; Compare e, the exponent, to &81.
 $3219 JR NC,$3221   ; Jump if e is greater than &80.
 $321B LD (HL),$00   ; {Else, set the exponent to zero; enter &20 into #REGa
 $321D LD A,$20      ; and jump forward to #R$3272 to make all the bits of x be
 $321F JR $3272      ; zero.}
@label=T_GR_ZERO
*$3221 CP $91        ; Compare e to &91.
 $3223 JR NZ,$323F   ; Jump if e not &91.
@ignoreua
; The next 26 bytes seem designed to test whether x is in fact -65536, i.e. 91
; 80 00 00 00, and if it is, to set it to 00 #S/FF/ 00 00 00. This is a
; mistake. As #R$303C(already stated), the Spectrum system cannot handle this
; number. The result here is simply to make INT (-65536) return the value -1.
; This is a pity, since the number would have been perfectly all right if left
; alone. The remedy would seem to be simply to omit the 28 bytes from #h3223
; above to #h323E inclusive from the program.
 $3225 INC HL        ; {#REGhl is pointed at the fourth byte of x, where the 17
 $3226 INC HL        ; bits of the integer part of x end after the first bit.
 $3227 INC HL        ; }
 $3228 LD A,$80      ; {The first bit is obtained in #REGa, using &80 as a
 $322A AND (HL)      ; mask.}
 $322B DEC HL        ; {That bit and the previous 8 bits are tested together
 $322C OR (HL)       ; for zero.}
 $322D DEC HL        ; #REGhl is pointed at the second byte of x.
 $322E JR NZ,$3233   ; If already non-zero, the test can end.
 $3230 LD A,$80      ; {Otherwise, the test for -65536 is now completed: 91 80
 $3232 XOR (HL)      ; 00 00 00 will leave the zero flag set now.}
@label=T_FIRST
*$3233 DEC HL        ; #REGhl is pointed at the first byte of x.
 $3234 JR NZ,$326C   ; If zero reset, the jump is made.
 $3236 LD (HL),A     ; The first byte is set to zero.
 $3237 INC HL        ; #REGhl points to the second byte.
 $3238 LD (HL),$FF   ; The second byte is set to &FF.
 $323A DEC HL        ; #REGhl again points to the first byte.
 $323B LD A,$18      ; The last 24 bits are to be zero.
 $323D JR $3272      ; The jump to #R$3272 completes the number 00 #S/FF/ 00 00
                     ; 00.
; If the exponent byte of x is between &81 and &90 inclusive, I(x) is a 'small
; integer', and will be compressed into one or two bytes. But first a test is
; made to see whether x is, after all, large.
@label=T_SMALL
*$323F JR NC,$326D   ; Jump with exponent byte &92 or more (it would be better
                     ; to jump with &91 too).
 $3241 PUSH DE       ; Save #SYSVAR(STKEND) in #REGde.
 $3242 CPL           ; Range 129<=#REGa<=144 becomes 126>=#REGa>=111.
 $3243 ADD A,$91     ; Range is now 15>=#REGa>=0.
 $3245 INC HL        ; Point #REGhl at second byte.
 $3246 LD D,(HL)     ; Second byte to #REGd.
 $3247 INC HL        ; Point #REGhl at third byte.
 $3248 LD E,(HL)     ; Third byte to #REGe.
 $3249 DEC HL        ; {Point #REGhl at first byte again.
 $324A DEC HL        ; }
 $324B LD C,$00      ; Assume a positive number.
 $324D BIT 7,D       ; Now test for negative (bit 7 set).
 $324F JR Z,$3252    ; Jump if positive after all.
 $3251 DEC C         ; Change the sign.
@label=T_NUMERIC
*$3252 SET 7,D       ; Insert true numeric bit, 1, in #REGd.
 $3254 LD B,$08      ; {Now test whether #REGa>=8 (one byte only) or two bytes
 $3256 SUB B         ; needed.}
 $3257 ADD A,B       ; Leave #REGa unchanged.
 $3258 JR C,$325E    ; Jump if two bytes needed.
 $325A LD E,D        ; Put the one byte into #REGe.
 $325B LD D,$00      ; And set #REGd to zero.
 $325D SUB B         ; Now 1<=#REGa<=7 to count the shifts needed.
@label=T_TEST
*$325E JR Z,$3267    ; Jump if no shift needed.
 $3260 LD B,A        ; #REGb will count the shifts.
@label=T_SHIFT
*$3261 SRL D         ; {Shift #REGd and #REGe right #REGb times to produce the
 $3263 RR E          ; correct number.}
 $3265 DJNZ $3261    ; Loop until #REGb is zero.
@label=T_STORE
*$3267 CALL $2D8E    ; Store the result on the stack.
 $326A POP DE        ; Restore #SYSVAR(STKEND) to #REGde.
 $326B RET           ; Finished.
; Large values of x remain to be considered.
@label=T_EXPNENT
*$326C LD A,(HL)     ; Get the exponent byte of x into #REGa.
@label=X_LARGE
*$326D SUB $A0       ; Subtract &A0 from e.
 $326F RET P         ; Return on plus - x has no significant non-integral part.
                     ; (If the true exponent were reduced to zero, the 'binary
                     ; point' would come at or after the end of the four bytes
                     ; of the mantissa.)
 $3270 NEG           ; Else, negate the remainder; this gives the number of
                     ; bits to become zero (the number of bits after the
                     ; 'binary point').
; Now the bits of the mantissa can be cleared.
@label=NIL_BYTES
*$3272 PUSH DE       ; Save the current value of #REGde (#SYSVAR(STKEND)).
 $3273 EX DE,HL      ; Make #REGhl point one past the fifth byte.
 $3274 DEC HL        ; #REGhl now points to the fifth byte of x.
 $3275 LD B,A        ; {Get the number of bits to be set to zero in #REGb and
 $3276 SRL B         ; divide it by 8 to give the number of whole bytes
 $3278 SRL B         ; implied.
 $327A SRL B         ; }
 $327C JR Z,$3283    ; Jump forward if the result is zero.
@label=BYTE_ZERO
*$327E LD (HL),$00   ; {Else, set the bytes to zero; #REGb counts them.
 $3280 DEC HL        ;
 $3281 DJNZ $327E    ; }
@label=BITS_ZERO
*$3283 AND $07       ; Get #REGa (mod 8); this is the number of bits still to
                     ; be set to zero.
 $3285 JR Z,$3290    ; Jump to the end if nothing more to do.
 $3287 LD B,A        ; #REGb will count the bits now.
 $3288 LD A,$FF      ; Prepare the mask.
@label=LESS_MASK
*$328A SLA A         ; {With each loop a zero enters the mask from the right
 $328C DJNZ $328A    ; and thereby a mask of the correct length is produced.}
 $328E AND (HL)      ; {The unwanted bits of (#REGhl) are lost as the masking
 $328F LD (HL),A     ; is performed.}
@label=IX_END
*$3290 EX DE,HL      ; Return the pointer to #REGhl.
 $3291 POP DE        ; Return #SYSVAR(STKEND) to #REGde.
 $3292 RET           ; Finished.

; THE 'RE-STACK TWO' SUBROUTINE
;
; Used by the routines at #R$3014, #R$30CA and #R$31AF.
; .
; This subroutine is called to re-stack two 'small integers' in full five-byte
; floating-point form for the binary operations of addition, multiplication and
; division. It does so by calling the following subroutine twice.
;
; DE Address of the first byte of the second number
; HL Address of the first byte of the first number
@label=RE_ST_TWO
c$3293 CALL $3296    ; Call the subroutine and then continue into it for the
                     ; second call.
@label=RESTK_SUB
*$3296 EX DE,HL      ; Exchange the pointers at each call.
; This routine continues into #R$3297.

; THE 'RE-STACK' SUBROUTINE (offset &3D)
;
; Used by the routine at #R$37E2.
; .
; The routine at #R$3293 continues here.
; .
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called via the calculator literal &3D by the routines at #R$2320, #R$2382,
; #R$36C4, #R$3713 and #R$3783. The routine at #R$3293 also continues here.
; .
; This subroutine is called to re-stack one number (which could be a 'small
; integer') in full five-byte floating-point form.
;
; HL Address of the first byte of the number
@refs=$335B
@label=re_stack
c$3297 LD A,(HL)     ; {If the first byte is not zero, return - the number
 $3298 AND A         ; cannot be a 'small integer'.
 $3299 RET NZ        ; }
 $329A PUSH DE       ; Save the 'other' pointer in #REGde.
 $329B CALL $2D7F    ; Fetch the sign in #REGc and the number in #REGde.
 $329E XOR A         ; Clear the #REGa register.
 $329F INC HL        ; Point to the fifth location.
 $32A0 LD (HL),A     ; Set the fifth byte to zero.
 $32A1 DEC HL        ; Point to the fourth location.
 $32A2 LD (HL),A     ; Set the fourth byte to zero; bytes 2 and 3 will hold the
                     ; mantissa.
 $32A3 LD B,$91      ; Set #REGb to &91 for the exponent, i.e. for up to 16
                     ; bits in the integer.
 $32A5 LD A,D        ; {Test whether #REGd is zero so that at most 8 bits would
 $32A6 AND A         ; be needed.}
 $32A7 JR NZ,$32B1   ; Jump if more than 8 bits needed.
 $32A9 OR E          ; Now test #REGe too.
 $32AA LD B,D        ; Save the zero in #REGb (it will give zero exponent if
                     ; #REGe too is zero).
 $32AB JR Z,$32BD    ; Jump if #REGe is indeed zero.
 $32AD LD D,E        ; Move #REGe to #REGd (#REGd was zero, #REGe not).
 $32AE LD E,B        ; Set #REGe to zero now.
 $32AF LD B,$89      ; Set #REGb to &89 for the exponent - no more than 8 bits
                     ; now.
@label=RS_NRMLSE
*$32B1 EX DE,HL      ; Pointer to #REGde, number to #REGhl.
@label=RSTK_LOOP
*$32B2 DEC B         ; Decrement the exponent on each shift.
 $32B3 ADD HL,HL     ; Shift the number right one position.
 $32B4 JR NC,$32B2   ; Until the carry is set.
 $32B6 RRC C         ; Sign bit to carry flag now.
 $32B8 RR H          ; {Insert it in place as the number is shifted back one
 $32BA RR L          ; place normal now.}
 $32BC EX DE,HL      ; Pointer to byte 4 back to #REGhl.
@label=RS_STORE
*$32BD DEC HL        ; Point to the third location.
 $32BE LD (HL),E     ; Store the third byte.
 $32BF DEC HL        ; Point to the second location.
 $32C0 LD (HL),D     ; Store the second byte.
 $32C1 DEC HL        ; Point to the first location.
 $32C2 LD (HL),B     ; Store the exponent byte.
 $32C3 POP DE        ; Restore the 'other' pointer to #REGde.
 $32C4 RET           ; Finished.

; THE TABLE OF CONSTANTS
;
; Used by the routine at #R$341B.
; .
; This table holds five useful and frequently needed numbers: zero, one, a
; half, a half of pi, and ten. The numbers are held in a condensed form which
; is expanded by the routine at #R$33C6 to give the required floating-point
; form.
@label=CONSTANTS
b$32C5 DEFB $00,$B0,$00         ; zero (00 00 00 00 00)
@label=stk_one
 $32C8 DEFB $40,$B0,$00,$01     ; one (00 00 01 00 00)
@label=stk_half
 $32CC DEFB $30,$00             ; a half (80 00 00 00 00)
@label=stk_pi_2
 $32CE DEFB $F1,$49,$0F,$DA,$A2 ; a half of pi (81 49 #S/0F DA A2/)
@label=stk_ten
 $32D3 DEFB $40,$B0,$00,$0A     ; ten (00 00 #S/0A/ 00 00)

; THE TABLE OF ADDRESSES
;
; Used by the routine at #R$335B.
; .
; This table is a look-up table of the addresses of the sixty-six operational
; subroutines of the calculator. The offsets used to index into the table are
; derived either from the operation codes used in the routine at #R$24FB (see
; #R$2734, etc.) or from the literals that follow a 'RST #o28' instruction.
@label=CALCADDR
w$32D7 DEFW $368F    ; &00
 $32D9 DEFW $343C    ; &01
 $32DB DEFW $33A1    ; &02
 $32DD DEFW $300F    ; &03
 $32DF DEFW $30CA    ; &04
 $32E1 DEFW $31AF    ; &05
 $32E3 DEFW $3851    ; &06
 $32E5 DEFW $351B    ; &07
 $32E7 DEFW $3524    ; &08
 $32E9 DEFW $353B    ; &09: <= (numbers)
 $32EB DEFW $353B    ; &0A: >= (numbers)
 $32ED DEFW $353B    ; &0B: <> (numbers)
 $32EF DEFW $353B    ; &0C: > (numbers)
 $32F1 DEFW $353B    ; &0D: < (numbers)
 $32F3 DEFW $353B    ; &0E: = (numbers)
 $32F5 DEFW $3014    ; &0F
 $32F7 DEFW $352D    ; &10
 $32F9 DEFW $353B    ; &11: <= (strings)
 $32FB DEFW $353B    ; &12: >= (strings)
 $32FD DEFW $353B    ; &13: <> (strings)
 $32FF DEFW $353B    ; &14: > (strings)
 $3301 DEFW $353B    ; &15: < (strings)
 $3303 DEFW $353B    ; &16: = (strings)
 $3305 DEFW $359C    ; &17
 $3307 DEFW $35DE    ; &18 (VAL$)
 $3309 DEFW $34BC    ; &19
 $330B DEFW $3645    ; &1A
 $330D DEFW $346E    ; &1B
 $330F DEFW $3669    ; &1C
 $3311 DEFW $35DE    ; &1D (VAL)
 $3313 DEFW $3674    ; &1E
 $3315 DEFW $37B5    ; &1F
 $3317 DEFW $37AA    ; &20
 $3319 DEFW $37DA    ; &21
 $331B DEFW $3833    ; &22
 $331D DEFW $3843    ; &23
 $331F DEFW $37E2    ; &24
 $3321 DEFW $3713    ; &25
 $3323 DEFW $36C4    ; &26
 $3325 DEFW $36AF    ; &27
 $3327 DEFW $384A    ; &28
 $3329 DEFW $3492    ; &29
 $332B DEFW $346A    ; &2A
 $332D DEFW $34AC    ; &2B
 $332F DEFW $34A5    ; &2C
 $3331 DEFW $34B3    ; &2D
 $3333 DEFW $361F    ; &2E
 $3335 DEFW $35C9    ; &2F
 $3337 DEFW $3501    ; &30
 $3339 DEFW $33C0    ; &31
 $333B DEFW $36A0    ; &32
 $333D DEFW $3686    ; &33
 $333F DEFW $33C6    ; &34
 $3341 DEFW $367A    ; &35
 $3343 DEFW $3506    ; &36
 $3345 DEFW $34F9    ; &37
 $3347 DEFW $369B    ; &38
 $3349 DEFW $3783    ; &39
 $334B DEFW $3214    ; &3A
 $334D DEFW $33A2    ; &3B
 $334F DEFW $2D4F    ; &3C
 $3351 DEFW $3297    ; &3D
 $3353 DEFW $3449    ; &3E
 $3355 DEFW $341B    ; &3F
 $3357 DEFW $342D    ; &40
 $3359 DEFW $340F    ; &41
; Note: the last four subroutines are multi-purpose subroutines and are entered
; with a parameter that is a copy of the right hand five bits of the original
; literal. The full set follows:
; .
; #LIST
; { Offset &3E: series-06, series-08 and series-0C; literals &86, &88 and &8C.
; }
; { Offset &3F: stk-zero, stk-one, stk-half, stk-pi/2 and stk-ten; literals &A0
; to &A4. }
; { Offset &40: st-mem-0, st-mem-1, st-mem-2, st-mem-3, st-mem-4 and st-mem-5;
; literals &C0 to &C5. }
; { Offset &41: get-mem-0, get-mem-1, get-mem-2, get-mem-3, get-mem-4 and
; get-mem-5; literals &E0 to &E5. }
; LIST#

; THE 'CALCULATE' SUBROUTINE
;
; Used by the routine at #R$0028.
; .
; This subroutine is used to perform floating-point calculations. These can be
; considered to be of three types:
; .
; #LIST
; { Binary operations, e.g. #R$3014, where two numbers in floating-point form
; are added together to give one 'last value'. }
; { Unary operations, e.g. #R$37B5, where the 'last value' is changed to give
; the appropriate function result as a new 'last value'. }
; { Manipulatory operations, e.g. #R$342D, where the 'last value' is copied to
; the first five bytes of the calculator's memory area. }
; LIST#
; .
; The operations to be performed are specified as a series of data-bytes, the
; literals, that follow an RST #o28 instruction that calls this subroutine. The
; last literal in the list is always '&38' which leads to an end to the whole
; operation.
; .
; In the case of a single operation needing to be performed, the operation
; offset can be passed to the calculator in the #REGb register, and operation
; '&3B', the #R$33A2(single calculation operation), performed.
; .
; It is also possible to call this subroutine recursively, i.e. from within
; itself, and in such a case it is possible to use the system variable
; #SYSVAR(BREG) as a counter that controls how many operations are performed
; before returning.
; .
; The first part of this subroutine is complicated but essentially it performs
; the two tasks of setting the registers to hold their required values, and to
; produce an offset, and possibly a parameter, from the literal that is
; currently being considered.
; .
; The offset is used to index into the calculator's #R$32D7(table of addresses)
; to find the required subroutine address.
; .
; The parameter is used when the multi-purpose subroutines are called.
; .
; Note: a floating-point number may in reality be a set of string parameters.
;
; B Operation offset or counter
@label=CALCULATE
c$335B CALL $35BF    ; Presume a unary operation and therefore set #REGhl to
                     ; point to the start of the 'last value' on the calculator
                     ; stack and #REGde one past this floating-point number
                     ; (#SYSVAR(STKEND)).
; This entry point is used by the routine at #R$3449.
@label=GEN_ENT_1
*$335E LD A,B        ; {Either transfer a single operation offset to
 $335F LD ($5C67),A  ; #SYSVAR(BREG) temporarily, or, when using the subroutine
                     ; recursively, pass the parameter to #SYSVAR(BREG) to be
                     ; used as a counter.}
; This entry point is used by the routine at #R$3449.
@label=GEN_ENT_2
*$3362 EXX           ; {The return address of the subroutine is stored in
 $3363 EX (SP),HL    ; #REGhl'. This saves the pointer to the first literal.
 $3364 EXX           ; Entering the calculator here is done whenever
                     ; #SYSVAR(BREG) is in use as a counter and is not to be
                     ; disturbed.}
@label=RE_ENTRY
 $3365 LD ($5C65),DE ; A loop is now entered to handle each literal in the list
                     ; that follows the calling instruction; so first, always
                     ; set #SYSVAR(STKEND).
 $3369 EXX           ; {Go to the alternate register set and fetch the literal
 $336A LD A,(HL)     ; for this loop.}
 $336B INC HL        ; Make #REGhl' point to the next literal.
; This entry point is used by the routine at #R$33A2.
@label=SCAN_ENT
*$336C PUSH HL       ; This pointer is saved briefly on the machine stack.
                     ; #R$336C is used by #R$33A2 to find the subroutine that
                     ; is required.
 $336D AND A         ; Test the #REGa register.
 $336E JP P,$3380    ; Separate the simple literals from the multi-purpose
                     ; literals. Jump with literals &00 to &3D.
 $3371 LD D,A        ; Save the literal in #REGd.
 $3372 AND $60       ; Continue only with bits 5 and 6.
 $3374 RRCA          ; {Four right shifts make them now bits 1 and 2.
 $3375 RRCA          ;
 $3376 RRCA          ;
 $3377 RRCA          ; }
 $3378 ADD A,$7C     ; {The offsets required are &3E to &41, and #REGl will now
 $337A LD L,A        ; hold double the required offset.}
 $337B LD A,D        ; {Now produce the parameter by taking bits 0, 1, 2, 3 and
 $337C AND $1F       ; 4 of the literal; keep the parameter in #REGa.}
 $337E JR $338E      ; Jump forward to find the address of the required
                     ; subroutine.
@label=FIRST_3D
*$3380 CP $18        ; {Jump forward if performing a unary operation.
 $3382 JR NC,$338C   ; }
 $3384 EXX           ; {All of the subroutines that perform binary operations
 $3385 LD BC,$FFFB   ; require that #REGhl points to the first operand and
 $3388 LD D,H        ; #REGde points to the second operand (the 'last value')
 $3389 LD E,L        ; as they appear on the calculator stack.
 $338A ADD HL,BC     ;
 $338B EXX           ; }
@label=DOUBLE_A
*$338C RLCA          ; {As each entry in the table of addresses takes up two
 $338D LD L,A        ; bytes the offset produced is doubled.}
@label=ENT_TABLE
*$338E LD DE,$32D7   ; The base address of the #R$32D7(table).
 $3391 LD H,$00      ; {The address of the required table entry is formed in
 $3393 ADD HL,DE     ; #REGhl, and the required subroutine address is loaded
 $3394 LD E,(HL)     ; into the #REGde register pair.
 $3395 INC HL        ;
 $3396 LD D,(HL)     ; }
@nowarn
 $3397 LD HL,$3365   ; {The address of #R$3365 is put on the machine stack
 $339A EX (SP),HL    ; underneath the subroutine address.
 $339B PUSH DE       ; }
 $339C EXX           ; Return to the main set of registers.
@keep=$01
@ssub=LD BC,($5C67-$01)
 $339D LD BC,($5C66) ; The current value of #SYSVAR(BREG) is transferred to the
                     ; #REGb register thereby returning the single operation
                     ; offset (see #R$353B).
; The address of this entry point is found in the #R$32D7(table of addresses).
; It is called via the calculator literal &02 by the routines at #R$03F8,
; #R$1CF0, #R$1D03, #R$1DAB, #R$2320, #R$2382, #R$247D, #R$25F8, #R$2AFF,
; #R$2C9B, #R$2D4F, #R$2DA2, #R$2DE3, #R$3449, #R$36A0, #R$36C4, #R$3713,
; #R$3783 and #R$3851.
@label=delete
 $33A1 RET           ; An indirect jump to the required subroutine.
; The #R$33A1 subroutine contains only the single '#S/RET/' instruction above.
; The literal '&02' results in this subroutine being considered as a binary
; operation that is to be entered with a first number addressed by the #REGhl
; register pair and a second number addressed by the #REGde register pair, and
; the result produced again addressed by the #REGhl register pair.
; .
; The single '#S/RET/' instruction thereby leads to the first number being
; considered as the resulting 'last value' and the second number considered as
; being deleted. Of course the number has not been deleted from the memory but
; remains inactive and will probably soon be overwritten.

; THE 'SINGLE OPERATION' SUBROUTINE (offset &3B)
;
@ignoreua
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called via the calculator literal &3B by the routine at #R$26C9.
; .
; This subroutine is only called from #R$2757(#h2757) and is used to perform a
; single arithmetic operation. The offset that specifies which operation is to
; be performed is supplied to the calculator in the #REGb register and
; subsequently transferred to the system variable #SYSVAR(BREG).
; .
; The effect of calling this subroutine is essentially to make a jump to the
; appropriate subroutine for the single operation.
@refs=$335B
@label=fp_calc_2
c$33A2 POP AF        ; Discard the #R$3365 address.
 $33A3 LD A,($5C67)  ; Transfer the offset from #SYSVAR(BREG) to #REGa.
 $33A6 EXX           ; Enter the alternate register set.
 $33A7 JR $336C      ; Jump back to find the required address; stack the
                     ; #R$3365 address and jump to the subroutine for the
                     ; operation.

; THE 'TEST 5-SPACES' SUBROUTINE
;
; Used by the routines at #R$2AB1, #R$33C0 and #R$33C6.
; .
; This subroutine tests whether there is sufficient room in memory for another
; 5-byte floating-point number to be added to the calculator stack.
;
; O:BC &0005
@label=TEST_5_SP
c$33A9 PUSH DE       ; Save #REGde briefly.
 $33AA PUSH HL       ; Save #REGhl briefly.
@keep
 $33AB LD BC,$0005   ; Specify the test is for 5 bytes.
 $33AE CALL $1F05    ; Make the test.
 $33B1 POP HL        ; Restore #REGhl.
 $33B2 POP DE        ; Restore #REGde.
 $33B3 RET           ; Finished.

; THE 'STACK NUMBER' SUBROUTINE
;
; Used by the routines at #R$03F8, #R$268D and #R$26C9.
; .
; This subroutine is called by #R$03F8, #R$25AF and #R$26C9 to copy
; #SYSVAR(STKEND) to #REGde, move a floating-point number to the calculator
; stack, and reset #SYSVAR(STKEND) from #REGde. It calls #R$33C0 to do the
; actual move.
;
; HL Address of the first byte of the number to stack
@label=STACK_NUM
c$33B4 LD DE,($5C65) ; Copy #SYSVAR(STKEND) to #REGde as destination address.
 $33B8 CALL $33C0    ; Move the number.
 $33BB LD ($5C65),DE ; Reset #SYSVAR(STKEND) from #REGde.
 $33BF RET           ; Finished.

; THE 'MOVE A FLOATING-POINT NUMBER' SUBROUTINE (offset &31)
;
; Used by the routines at #R$2951, #R$33B4, #R$340F and #R$342D.
; .
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called via the calculator literal &31 by the routines at #R$03F8, #R$2320,
; #R$2382, #R$247D, #R$25F8, #R$2D4F, #R$2DE3, #R$3449, #R$36A0, #R$36AF,
; #R$36C4, #R$3713, #R$3783, #R$37B5, #R$37DA, #R$37E2, #R$3833, #R$384A and
; #R$3851.
; .
; This subroutine moves a floating-point number to the top of the calculator
; stack (3 cases) or from the top of the stack to the calculator's memory area
; (1 case). It is also called through the calculator when it simply duplicates
; the number at the top of the calculator stack, the 'last value', thereby
; extending the stack by five bytes.
;
; DE Destination address
; HL Address of the first byte of the number to move
@refs=$335B
@label=duplicate
c$33C0 CALL $33A9    ; A test is made for room.
 $33C3 LDIR          ; Move the five bytes involved.
 $33C5 RET           ; Finished.

; THE 'STACK LITERALS' SUBROUTINE (offset &34)
;
; Used by the routine at #R$3449.
; .
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called via the calculator literal &34 by the routines at #R$03F8, #R$247D,
; #R$25F8, #R$2DC1, #R$36C4, #R$3713 and #R$3783.
; .
; This subroutine places on the calculator stack, as a 'last value', the
; floating-point number supplied to it as 2, 3, 4 or 5 literals.
; .
; When called by using offset '&34' the literals follow the '&34' in the list
; of literals; when called by the #R$3449(series generator), the literals are
; supplied by the subroutine that called for a series to be generated; and when
; called by #R$33F7 and #R$341B the literals are obtained from the calculator's
; #R$32C5(table of constants).
; .
; In each case, the first literal supplied is divided by &40, and the integer
; quotient plus 1 determines whether 1, 2, 3 or 4 further literals will be
; taken from the source to form the mantissa of the number. Any unfilled bytes
; of the five bytes that go to form a 5-byte floating-point number are set to
; zero. The first literal is also used to determine the exponent, after
; reducing mod &40, unless the remainder is zero, in which case the second
; literal is used, as it stands, without reducing mod &40. In either case, &50
; is added to the literal, giving the augmented exponent byte, e (the true
; exponent e' plus &80). The rest of the 5 bytes are stacked, including any
; zeros needed, and the subroutine returns.
;
; DE #SYSVAR(STKEND)
; HL' Address of the next literal
@refs=$335B
@label=stk_data
c$33C6 LD H,D        ; {This subroutine performs the manipulatory operation of
 $33C7 LD L,E        ; adding a 'last value' to the calculator stack; hence
                     ; #REGhl is set to point one past the present 'last value'
                     ; and hence point to the result.}
; This entry point is used by the routines at #R$33F7 and #R$341B.
@label=STK_CONST
*$33C8 CALL $33A9    ; Now test that there is indeed room.
 $33CB EXX           ; {Go to the alternate register set and stack the pointer
 $33CC PUSH HL       ; to the next literal.
 $33CD EXX           ; }
 $33CE EX (SP),HL    ; Switch over the result pointer and the next literal
                     ; pointer.
 $33CF PUSH BC       ; Save #REGbc briefly.
 $33D0 LD A,(HL)     ; {The first literal is put into #REGa and divided by &40
 $33D1 AND $C0       ; to give the integer values 0, 1, 2 or 3.
 $33D3 RLCA          ;
 $33D4 RLCA          ; }
 $33D5 LD C,A        ; {The integer value is transferred to #REGc and
 $33D6 INC C         ; incremented, thereby giving the range 1, 2, 3 or 4 for
                     ; the number of literals that will be needed.}
 $33D7 LD A,(HL)     ; {The literal is fetched anew, reduced mod &40 and
 $33D8 AND $3F       ; discarded as inappropriate if the remainder if zero; in
 $33DA JR NZ,$33DE   ; which case the next literal is fetched and used
 $33DC INC HL        ; unreduced.
 $33DD LD A,(HL)     ; }
@label=FORM_EXP
*$33DE ADD A,$50     ; {The exponent, e, is formed by the addition of &50 and
 $33E0 LD (DE),A     ; passed to the calculator stack as the first of the five
                     ; bytes of the result.}
 $33E1 LD A,$05      ; {The number of literals specified in #REGc are taken
 $33E3 SUB C         ; from the source and entered into the bytes of the
 $33E4 INC HL        ; result.
 $33E5 INC DE        ;
 $33E6 LD B,$00      ;
 $33E8 LDIR          ; }
 $33EA POP BC        ; Restore #REGbc.
 $33EB EX (SP),HL    ; {Return the result pointer to #REGhl and the next
 $33EC EXX           ; literal pointer to its usual position in #REGhl'.
 $33ED POP HL        ;
 $33EE EXX           ; }
 $33EF LD B,A        ; {The number of zero bytes required at this stage is
 $33F0 XOR A         ; given by 5-#REGc-1, and this number of zeros is added to
@label=STK_ZEROS
*$33F1 DEC B         ; the result to make up the required five bytes.
 $33F2 RET Z         ;
 $33F3 LD (DE),A     ;
 $33F4 INC DE        ;
 $33F5 JR $33F1      ; }

; THE 'SKIP CONSTANTS' SUBROUTINE
;
; Used by the routine at #R$341B.
; .
; This subroutine is entered with the #REGhl' register pair holding the base
; address of the calculator's #R$32C5(table of constants) and the #REGa
; register holding a parameter that shows which of the five constants is being
; requested.
; .
; The subroutine performs the null operations of loading the five bytes of each
; unwanted constant into the locations 0000, 0001, 0002, 0003 and 0004 at the
; beginning of the ROM until the requested constant is reached.
; .
; The subroutine returns with the #REGhl' register pair holding the base
; address of the requested constant within the table of constants.
;
;   A Index of the required constant (&00 to &04)
;   HL' #R$32C5
; O:HL' Address of the required constant
@label=SKIP_CONS
c$33F7 AND A         ; {The subroutine returns if the parameter is zero, or
@label=SKIP_NEXT
*$33F8 RET Z         ; when the requested constant has been reached.}
 $33F9 PUSH AF       ; Save the parameter.
 $33FA PUSH DE       ; Save the result pointer.
@keep
 $33FB LD DE,$0000   ; The dummy address.
 $33FE CALL $33C8    ; Perform imaginary stacking of an expanded constant.
 $3401 POP DE        ; Restore the result pointer.
 $3402 POP AF        ; Restore the parameter.
 $3403 DEC A         ; Count the loops.
 $3404 JR $33F8      ; Jump back to consider the value of the counter.

; THE 'MEMORY LOCATION' SUBROUTINE
;
; Used by the routines at #R$03F8, #R$340F and #R$342D.
; .
; This subroutine finds the base address for each five-byte portion of the
; calculator's memory area to or from which a floating-point number is to be
; moved from or to the calculator stack. It does this operation by adding five
; times the parameter supplied to the base address for the area which is held
; in the #REGhl register pair.
; .
; Note that when a FOR-NEXT variable is being handled then the pointers are
; changed so that the variable is treated as if it were the calculator's memory
; area.
;
;   A Index of the required entry
;   HL Base address (#R$046E or #SYSVAR(MEM))
; O:HL Base address + 5 * #REGa
@label=LOC_MEM
c$3406 LD C,A        ; Copy the parameter to #REGc.
 $3407 RLCA          ; Double the parameter.
 $3408 RLCA          ; Double the result.
 $3409 ADD A,C       ; Add the value of the parameter to give five times the
                     ; original value.
 $340A LD C,A        ; {This result is wanted in the #REGbc register pair.
 $340B LD B,$00      ; }
 $340D ADD HL,BC     ; Produce the new base address.
 $340E RET           ; Finished.

; THE 'GET FROM MEMORY AREA' SUBROUTINE (offset &41)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called via a calculator literal (&E0 to &E5) by the routines at #R$03F8,
; #R$1D03, #R$1DAB, #R$1DDA, #R$2320, #R$2382, #R$247D, #R$2C9B, #R$2D4F,
; #R$2DE3, #R$3449, #R$36A0, #R$36AF, #R$36C4 and #R$37AA.
; .
; This subroutine is called using the literals &E0 to &E5 and the parameter
; derived from these literals is held in the #REGa register. The subroutine
; calls #R$3406 to put the required source address into the #REGhl register
; pair and #R$33C0 to copy the five bytes involved from the calculator's memory
; area to the top of the calculator stack to form a new 'last value'.
;
;   A Index of the required memory area (&00 to &05)
;   DE Destination address
; O:HL Destination address (as #REGde on entry)
@refs=$335B
@label=get_mem
c$340F PUSH DE       ; Save the result pointer.
 $3410 LD HL,($5C68) ; Fetch the pointer to the current memory area
                     ; (#SYSVAR(MEM)).
 $3413 CALL $3406    ; The base address is found.
 $3416 CALL $33C0    ; The five bytes are moved.
 $3419 POP HL        ; Set the result pointer.
 $341A RET           ; Finished.

; THE 'STACK A CONSTANT' SUBROUTINE (offset &3F)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called via a calculator literal (&A0 to &A4) by the routines at #R$03F8,
; #R$1CDE, #R$1D03, #R$2320, #R$2382, #R$247D, #R$25F8, #R$2627, #R$2C9B,
; #R$2D3B, #R$2D4F, #R$2DA2, #R$2DE3, #R$3449, #R$353B, #R$36AF, #R$36C4,
; #R$3713, #R$3783, #R$37AA, #R$37B5, #R$37E2, #R$3833, #R$3843, #R$384A and
; #R$3851.
; .
; This subroutine uses #R$33F7 to find the base address of the requested
; constants from the calculator's table of constants and then calls #R$33C8 to
; make the expanded form of the constant the 'last value' on the calculator
; stack.
;
; A Index of the required constant (&00 to &04)
; DE #SYSVAR(STKEND)
@refs=$335B
@label=stk_con
c$341B LD H,D        ; {Set #REGhl to hold the result pointer.
 $341C LD L,E        ; }
 $341D EXX           ; {Go to the alternate register set and save the next
 $341E PUSH HL       ; literal pointer.}
 $341F LD HL,$32C5   ; The base address of the calculator's #R$32C5(table of
                     ; constants).
 $3422 EXX           ; Back to the main set of registers.
 $3423 CALL $33F7    ; Find the requested base address.
 $3426 CALL $33C8    ; Expand the constant.
 $3429 EXX           ; {Restore the next literal pointer.
 $342A POP HL        ;
 $342B EXX           ; }
 $342C RET           ; Finished.

; THE 'STORE IN MEMORY AREA' SUBROUTINE (offset &40)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called via a calculator literal (&C0 to &C5) by the routines at #R$03F8,
; #R$1D03, #R$1DAB, #R$2320, #R$2382, #R$247D, #R$2C9B, #R$2D4F, #R$2DE3,
; #R$3449, #R$36A0, #R$36AF, #R$36C4 and #R$3783.
; .
; This subroutine is called using the literals &C0 to &C5 and the parameter
; derived from these literals is held in the #REGa register. This subroutine is
; very similar to #R$340F but the source and destination pointers are
; exchanged.
;
; A Index of the required memory area (&00 to &05)
; HL Source address
@refs=$335B
@label=st_mem
c$342D PUSH HL       ; Save the result pointer.
 $342E EX DE,HL      ; Source to #REGde briefly.
 $342F LD HL,($5C68) ; Fetch the pointer to the current memory area
                     ; (#SYSVAR(MEM)).
 $3432 CALL $3406    ; The base address is found.
 $3435 EX DE,HL      ; Exchange source and destination pointers.
 $3436 CALL $33C0    ; The five bytes are moved.
 $3439 EX DE,HL      ; 'Last value'+5, i.e. #SYSVAR(STKEND), to #REGde.
 $343A POP HL        ; Result pointer to #REGhl.
 $343B RET           ; Finished.
; Note that the pointers #REGhl and #REGde remain as they were, pointing to
; #SYSVAR(STKEND)-5 and #SYSVAR(STKEND) respectively, so that the 'last value'
; remains on the calculator stack. If required it can be removed by using
; #R$33A1.

; THE 'EXCHANGE' SUBROUTINE (offset &01)
;
; Used by the routine at #R$353B.
; .
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called via the calculator literal &01 by the routines at #R$03F8, #R$1736,
; #R$1D03, #R$1DDA, #R$2320, #R$2382, #R$247D, #R$2D3B, #R$2DE3, #R$3449,
; #R$36A0, #R$36AF, #R$3713, #R$3783, #R$37DA, #R$37E2 and #R$3851.
; .
; This binary operation 'exchanges' the first number with the second number,
; i.e. the topmost two numbers on the calculator stack are exchanged.
;
;   DE Address of the first byte of the second number
;   HL Address of the first byte of the first number
; O:HL Address of the first byte of the second number
@refs=$335B
@label=exchange
c$343C LD B,$05      ; There are five bytes involved.
@label=SWAP_BYTE
*$343E LD A,(DE)     ; Each byte of the second number.
 $343F LD C,(HL)     ; Each byte of the first number.
 $3440 EX DE,HL      ; Switch source and destination.
 $3441 LD (DE),A     ; Now to the first number.
 $3442 LD (HL),C     ; Now to the second number.
 $3443 INC HL        ; {Move to consider the next pair of bytes.
 $3444 INC DE        ; }
 $3445 DJNZ $343E    ; Exchange the five bytes.
 $3447 EX DE,HL      ; Get the pointers correct as 5 is an odd number.
 $3448 RET           ; Finished.

; THE 'SERIES GENERATOR' SUBROUTINE (offset &3E)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called via a calculator literal (&86, &88 or &8C) by the routines at
; #R$36C4, #R$3713, #R$37B5 and #R$37E2.
; .
; This important subroutine generates the series of Chebyshev polynomials which
; are used to approximate to SIN, ATN, LN and EXP and hence to derive the other
; arithmetic functions which depend on these (COS, TAN, ASN, ACS, ** and SQR).
; .
; #HTML[The polynomials are generated, for n=1, 2, etc. by the recurrence
; relation T<sub>n+1</sub>(z)=2zT<sub>n</sub>(z)-T<sub>n-1</sub>(z), where
; T<sub>n</sub>(z) is the nth Chebyshev polynomial in z.]
; .
; #HTML[The series in fact generates T<sub>0</sub>, 2T<sub>1</sub>,
; 2T<sub>2</sub>, ..., 2T<sub>n-1</sub>, where n is 6 for SIN, 8 for EXP, and
; 12 for LN and ATN.]
; .
; #HTML[The coefficients of the powers of z in these polynomials may be found
; in the Handbook of Mathematical Functions by M. Abramowitz and I. A. Stegun
; (Dover 1965), page 795.]
; .
; In simple terms this subroutine is called with the 'last value' on the
; calculator stack, say Z, being a number that bears a simple relationship to
; the argument, say X, when the task is to evaluate, for instance, SIN X. The
; calling subroutine also supplies the list of constants that are to be
; required (six constants for SIN). The series generator then manipulates its
; data and returns to the calling routine a 'last value' that bears a simple
; relationship to the requested function, for instance, SIN X.
;
; A Series parameter (&06, &08 or &0C)
;
; This subroutine can be considered to have four major parts.
; .
; i. The setting of the loop counter. The calling subroutine passes its
; parameters in the #REGa register for use as a counter. The calculator is
; entered at #R$335E so that the counter can be set.
@refs=$335B
@label=series
c$3449 LD B,A        ; Move the parameter to #REGb.
 $344A CALL $335E    ; In effect a RST #o28 instruction but sets the counter.
; ii. The handling of the 'last value', Z. The loop of the generator requires
; 2*Z to be placed in mem-0, zero to be placed in mem-2 and the 'last value' to
; be zero.
 $344D DEFB $31      ; #R$33C0: Z, Z
 $344E DEFB $0F      ; #R$3014: 2*Z
 $344F DEFB $C0      ; #R$342D(st_mem_0): 2*Z (mem-0 holds 2*Z)
 $3450 DEFB $02      ; #R$33A1: -
 $3451 DEFB $A0      ; #R$341B(stk_zero): 0
 $3452 DEFB $C2      ; #R$342D(st_mem_2): 0 (mem-2 holds 0)
; iii. The main loop.
; .
; The series is generated by looping, using #SYSVAR(BREG) as a counter; the
; constants in the calling subroutine are stacked in turn by calling #R$33C6;
; the calculator is re-entered at #R$3362 so as not to disturb the value of
; #SYSVAR(BREG); and the series is built up in the form:
; .
; B(R)=2*Z*B(R-1)-B(R-2)+A(R), for R=1, 2, ..., N, where A(1), A(2)...A(N) are
; the constants supplied by the calling subroutine (SIN, ATN, LN and EXP) and
; B(0)=0=B(-1).
; .
; The (R+1)th loop starts with B(R) on the stack and with 2*Z, B(R-2) and
; B(R-1) in mem-0, mem-1 and mem-2 respectively.
@label=G_LOOP
 $3453 DEFB $31      ; #R$33C0: B(R), B(R)
 $3454 DEFB $E0      ; #R$340F(get_mem_0): B(R), B(R), 2*Z
 $3455 DEFB $04      ; #R$30CA: B(R), 2*B(R)*Z
 $3456 DEFB $E2      ; #R$340F(get_mem_2): B(R),2*B(R)*Z, B(R-1)
 $3457 DEFB $C1      ; #R$342D(st_mem_1): mem-1 holds B(R-1)
 $3458 DEFB $03      ; #R$300F: B(R), 2*B(R)*Z-B(R-1)
 $3459 DEFB $38      ; #R$369B
; The next constant is placed on the calculator stack.
 $345A CALL $33C6    ; B(R), 2*B(R)*Z-B(R-1), A(R+1)
; The calculator is re-entered without disturbing #SYSVAR(BREG).
 $345D CALL $3362    ;
 $3460 DEFB $0F      ; #R$3014: B(R), 2*B(R)*Z-B(R-1)+A(R+1)
 $3461 DEFB $01      ; #R$343C: 2*B(R)*Z-B(R-1)+A(R+1), B(R)
 $3462 DEFB $C2      ; #R$342D(st_mem_2): mem-2 holds B(R)
 $3463 DEFB $02      ; #R$33A1: 2*B(R)*Z-B(R-1)+A(R+1)=B(R+1)
 $3464 DEFB $35      ; {#R$367A to #R$3453: B(R+1)
 $3465 DEFB $EE      ; }
; iv. The subtraction of B(N-2). The loop above leaves B(N) on the stack and
; the required result is given by B(N)-B(N-2).
 $3466 DEFB $E1      ; #R$340F(get_mem_1): B(N), B(N-2)
 $3467 DEFB $03      ; #R$300F: B(N)-B(N-2)
 $3468 DEFB $38      ; #R$369B
 $3469 RET           ; Finished.

; THE 'ABSOLUTE MAGNITUDE' FUNCTION (offset &2A)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called via the calculator literal &2A by the routines at #R$2320, #R$2382,
; #R$247D, #R$2DE3, #R$3783 and #R$37AA. It is also called indirectly via
; #R$33A2.
; .
; This subroutine performs its unary operation by ensuring that the sign bit of
; a floating-point number is reset.
; .
; 'Small integers' have to be treated separately. Most of the work is shared
; with the 'unary minus' operation.
;
; HL Address of the first byte of the number
@refs=$335B
@label=abs
c$346A LD B,$FF      ; #REGb is set to &FF.
 $346C JR $3474      ; The jump is made into 'unary minus'.

; THE 'UNARY MINUS' OPERATION (offset &1B)
;
; Used by the routine at #R$300F.
; .
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called via the calculator literal &1B by the routines at #R$247D, #R$3783,
; #R$37AA, #R$37E2, #R$3833 and #R$3843. It is also called indirectly via
; #R$33A2.
; .
; This subroutine performs its unary operation by changing the sign of the
; 'last value' on the calculator stack.
; .
; Zero is simply returned unchanged. Full five byte floating-point numbers have
; their sign bit manipulated so that it ends up reset (for 'abs') or changed
; (for 'negate'). 'Small integers' have their sign byte set to zero (for 'abs')
; or changed (for 'negate').
;
; HL Address of the first byte of the number
@refs=$335B
@label=negate
c$346E CALL $34E9    ; {If the number is zero, the subroutine returns leaving
 $3471 RET C         ; 00 00 00 00 00 unchanged.}
 $3472 LD B,$00      ; #REGb is set to &00 for 'negate'.
; This entry point is used by the routine at #R$346A.
@label=NEG_TEST
*$3474 LD A,(HL)     ; {If the first byte is zero, the jump is made to deal
 $3475 AND A         ; with a 'small integer'.
 $3476 JR Z,$3483    ; }
 $3478 INC HL        ; Point to the second byte.
 $3479 LD A,B        ; Get &FF for 'abs', &00 for 'negate'.
 $347A AND $80       ; Now &80 for 'abs', &00 for 'negate'.
 $347C OR (HL)       ; This sets bit 7 for 'abs', but changes nothing for
                     ; 'negate'.
 $347D RLA           ; {Now bit 7 is changed, leading to bit 7 of byte 2 reset
 $347E CCF           ; for 'abs', and simply changed for 'negate'.
 $347F RRA           ; }
 $3480 LD (HL),A     ; The new second byte is stored.
 $3481 DEC HL        ; #REGhl points to the first byte again.
 $3482 RET           ; Finished.
; The 'integer case' does a similar operation with the sign byte.
@label=INT_CASE
*$3483 PUSH DE       ; Save #SYSVAR(STKEND) in #REGde.
 $3484 PUSH HL       ; Save pointer to the number in #REGhl.
 $3485 CALL $2D7F    ; Fetch the sign in #REGc, the number in #REGde.
 $3488 POP HL        ; Restore the pointer to the number in #REGhl.
 $3489 LD A,B        ; Get &FF for 'abs', &00 for 'negate'.
 $348A OR C          ; Now &FF for 'abs', no change for 'negate'.
 $348B CPL           ; {Now &00 for 'abs', and a changed byte for 'negate';
 $348C LD C,A        ; store it in #REGc.}
 $348D CALL $2D8E    ; Store result on the stack.
 $3490 POP DE        ; Return #SYSVAR(STKEND) to #REGde.
 $3491 RET           ;

; THE 'SIGNUM' FUNCTION (offset &29)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called indirectly via #R$33A2.
; .
; This subroutine handles the function SGN X and therefore returns a 'last
; value' of 1 if X is positive, zero if X is zero and -1 if X is negative.
;
; HL Address of the first byte of the number
@refs=$335B
@label=sgn
c$3492 CALL $34E9    ; {If X is zero, just return with zero as the 'last
 $3495 RET C         ; value'.}
 $3496 PUSH DE       ; Save the pointer to #SYSVAR(STKEND).
@keep
 $3497 LD DE,$0001   ; Store 1 in #REGde.
 $349A INC HL        ; Point to the second byte of X.
 $349B RL (HL)       ; Rotate bit 7 into the carry flag.
 $349D DEC HL        ; Point to the destination again.
 $349E SBC A,A       ; {Set #REGc to zero for positive X and to &FF for
 $349F LD C,A        ; negative X.}
 $34A0 CALL $2D8E    ; Stack 1 or -1 as required.
 $34A3 POP DE        ; Restore the pointer to #SYSVAR(STKEND).
 $34A4 RET           ; Finished.

; THE 'IN' FUNCTION (offset &2C)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called indirectly via #R$33A2.
; .
; This subroutine handles the function IN X. It inputs at processor level from
; port X, loading #REGbc with X and performing the instruction '#S/IN A,(C)/'.
@refs=$335B
@label=f_in
c$34A5 CALL $1E99    ; The 'last value', X, is compressed into #REGbc.
 $34A8 IN A,(C)      ; The signal is received.
 $34AA JR $34B0      ; Jump to stack the result.

; THE 'PEEK' FUNCTION (offset &2B)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called indirectly via #R$33A2.
; .
; This subroutine handles the function PEEK X. The 'last value' is unstacked by
; calling #R$1E99 and replaced by the value of the contents of the required
; location.
@refs=$335B
@label=peek
c$34AC CALL $1E99    ; Evaluate the 'last value', rounded to the nearest
                     ; integer; test that it is in range and return it in
                     ; #REGbc.
 $34AF LD A,(BC)     ; Fetch the required byte.
; This entry point is used by the routine at #R$34A5.
@label=IN_PK_STK
*$34B0 JP $2D28      ; Exit by jumping to #R$2D28.

; THE 'USR' FUNCTION (offset &2D)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called indirectly via #R$33A2.
; .
; This subroutine ('USR number' as distinct from 'USR string') handles the
; function USR X, where X is a number. The value of X is obtained in #REGbc, a
; return address is stacked and the machine code is executed from location X.
@refs=$335B
@label=usr_no
c$34B3 CALL $1E99    ; Evaluate the 'last value', rounded to the nearest
                     ; integer; test that it is in range and return it in
                     ; #REGbc.
@nowarn
 $34B6 LD HL,$2D2B   ; {Make the return address be that of the subroutine
 $34B9 PUSH HL       ; #R$2D2B.}
 $34BA PUSH BC       ; {Make an indirect jump to the required location.
 $34BB RET           ; }
@ignoreua
; Note: it is interesting that the #REGiy register pair is re-initialised when
; the return to #R$2D2B has been made, but the important #REGhl' that holds the
; next literal pointer is not restored should it have been disturbed. For a
; successful return to BASIC, #REGhl' must on exit from the machine code
; contain the address of the 'end-calc' instruction at #R$2758(&2758).

; THE 'USR STRING' FUNCTION (offset &19)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called indirectly via #R$33A2.
; .
; This subroutine handles the function USR X$, where X$ is a string. The
; subroutine returns in #REGbc the address of the bit pattern for the
; user-defined graphic corresponding to X$. It reports error A if X$ is not a
; single letter between 'a' and 'u' or a user-defined graphic.
@refs=$335B
@label=usr
c$34BC CALL $2BF1    ; Fetch the parameters of the string X$.
 $34BF DEC BC        ; Decrease the length by 1 to test it.
 $34C0 LD A,B        ; {If the length was not 1, then jump to give error report
 $34C1 OR C          ; A.
 $34C2 JR NZ,$34E7   ; }
 $34C4 LD A,(DE)     ; Fetch the single code of the string.
 $34C5 CALL $2C8D    ; Does it denote a letter?
 $34C8 JR C,$34D3    ; If so, jump to gets its address.
 $34CA SUB $90       ; Reduce range for actual user-defined graphics to 0-20.
 $34CC JR C,$34E7    ; Give report A if out of range.
 $34CE CP $15        ; Test the range again.
 $34D0 JR NC,$34E7   ; Give report A if out of range.
 $34D2 INC A         ; Make range of user-defined graphics 1 to 21, as for 'a'
                     ; to 'u'.
@label=USR_RANGE
*$34D3 DEC A         ; Now make the range 0 to 20 in each case.
 $34D4 ADD A,A       ; {Multiply by 8 to get an offset for the address.
 $34D5 ADD A,A       ;
 $34D6 ADD A,A       ; }
 $34D7 CP $A8        ; Test the range of the offset.
 $34D9 JR NC,$34E7   ; Give report A if out of range.
 $34DB LD BC,($5C7B) ; Fetch the address of the first user-defined graphic
                     ; (#SYSVAR(UDG)) in #REGbc.
 $34DF ADD A,C       ; Add #REGc to the offset.
 $34E0 LD C,A        ; Store the result back in #REGc.
 $34E1 JR NC,$34E4   ; Jump if there is no carry.
 $34E3 INC B         ; Increment #REGb to complete the address.
@label=USR_STACK
*$34E4 JP $2D2B      ; Jump to stack the address.
; Report A - Invalid argument.
@label=REPORT_A
*$34E7 RST $08       ; {Call the error handling routine.
 $34E8 DEFB $09      ; }

; THE 'TEST-ZERO' SUBROUTINE
;
; Used by the routines at #R$1CF0, #R$30C0, #R$346E, #R$3492, #R$34F9, #R$3501,
; #R$351B, #R$3524 and #R$352D.
; .
; This subroutine is called at least nine times to test whether a
; floating-point number is zero. This test requires that the first four bytes
; of the number should each be zero. The subroutine returns with the carry flag
; set if the number was in fact zero.
;
;   HL Address of the first byte of the number
; O:F Carry flag set if the number is zero
@label=TEST_ZERO
c$34E9 PUSH HL       ; Save #REGhl on the stack.
 $34EA PUSH BC       ; Save #REGbc on the stack.
 $34EB LD B,A        ; Save the value of #REGa in #REGb.
 $34EC LD A,(HL)     ; Get the first byte.
 $34ED INC HL        ; Point to the second byte.
 $34EE OR (HL)       ; '#S/OR/' the first byte with the second.
 $34EF INC HL        ; Point to the third byte.
 $34F0 OR (HL)       ; '#S/OR/' the result with the third byte.
 $34F1 INC HL        ; Point to the fourth byte.
 $34F2 OR (HL)       ; '#S/OR/' the result with the fourth byte.
 $34F3 LD A,B        ; Restore the original value of #REGa.
 $34F4 POP BC        ; And of #REGbc.
 $34F5 POP HL        ; Restore the pointer to the number to #REGhl.
 $34F6 RET NZ        ; Return with carry reset if any of the four bytes was
                     ; non-zero.
 $34F7 SCF           ; {Set the carry flag to indicate that the number was
 $34F8 RET           ; zero, and return.}

; THE 'GREATER THAN ZERO' OPERATION (offset &37)
;
; Used by the routine at #R$353B.
; .
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called via the calculator literal &37 by the routines at #R$1DDA, #R$2DE3,
; #R$3713, #R$3783 and #R$3851.
; .
; This subroutine returns a 'last value' of one if the present 'last value' is
; greater than zero and zero otherwise. It is also used by other subroutines to
; 'jump on plus'.
;
; HL Address of the first byte of the number
@refs=$335B
@label=greater_0
c$34F9 CALL $34E9    ; Is the 'last-value' zero?
 $34FC RET C         ; If so, return.
 $34FD LD A,$FF      ; {Jump forward to #R$3506 but signal the opposite action
 $34FF JR $3507      ; is needed.}

; THE 'NOT' FUNCTION (offset &30)
;
; Used by the routine at #R$353B.
; .
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called via the calculator literal &30 by the routines at #R$2382, #R$36AF,
; #R$384A and #R$3851. It is also called indirectly via #R$33A2.
; .
; This subroutine returns a 'last value' of one if the present 'last value' is
; zero and zero otherwise. It is also used by other subroutines to 'jump on
; zero'.
;
; HL Address of the first byte of the number
@refs=$335B
@label=f_not
c$3501 CALL $34E9    ; The carry flag will be set only if the 'last value' is
                     ; zero; this gives the correct result.
 $3504 JR $350B      ; Jump forward.

; THE 'LESS THAN ZERO' OPERATION (offset &36)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called via the calculator literal &36 by the routines at #R$1DDA, #R$2DE3,
; #R$36AF, #R$3783 and #R$37E2.
; .
; This subroutine returns a 'last value' of one if the present 'last value' is
; less than zero and zero otherwise. It is also used by other subroutines to
; 'jump on minus'.
;
; HL Address of the first byte of the number
@refs=$335B
@label=less_0
c$3506 XOR A         ; Clear the #REGa register.
; This entry point is used by the routine at #R$34F9 with #REGa=&FF.
@label=SIGN_TO_C
*$3507 INC HL        ; Point to the sign byte.
 $3508 XOR (HL)      ; {The carry is reset for a positive number and set for a
 $3509 DEC HL        ; negative number; when entered from #R$34F9 the opposite
 $350A RLCA          ; sign goes to the carry.}
; This routine continues into #R$350B.

; THE 'ZERO OR ONE' SUBROUTINE
;
; Used by the routines at #R$2D4F, #R$3501, #R$351B and #R$3524.
; .
; The routine at #R$3506 continues here.
; .
; This subroutine sets the 'last value' to zero if the carry flag is reset and
; to one if it is set. When called from #R$2D4F however it creates the zero or
; one not on the stack but in mem-0.
;
; HL Address of the first byte of the number
; F Carry set for 1, reset for 0
@label=FP_0_1
c$350B PUSH HL       ; Save the result pointer.
 $350C LD A,$00      ; Clear #REGa without disturbing the carry.
 $350E LD (HL),A     ; Set the first byte to zero.
 $350F INC HL        ; Point to the second byte.
 $3510 LD (HL),A     ; Set the second byte to zero.
 $3511 INC HL        ; Point to the third byte.
 $3512 RLA           ; Rotate the carry into #REGa, making #REGa one if the
                     ; carry was set, but zero if the carry was reset.
 $3513 LD (HL),A     ; Set the third byte to one or zero.
 $3514 RRA           ; Ensure that #REGa is zero again.
 $3515 INC HL        ; Point to the fourth byte.
 $3516 LD (HL),A     ; Set the fourth byte to zero.
 $3517 INC HL        ; Point to the fifth byte.
 $3518 LD (HL),A     ; Set the fifth byte to zero.
 $3519 POP HL        ; Restore the result pointer.
 $351A RET           ;

; THE 'OR' OPERATION (offset &07)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called indirectly via #R$33A2.
; .
; This subroutine performs the binary operation 'X OR Y' and returns X if Y is
; zero and the value 1 otherwise.
;
; DE Address of the first byte of the second number (Y)
; HL Address of the first byte of the first number (X)
@refs=$335B
@label=no_or_no
c$351B EX DE,HL      ; Point #REGhl at Y, the second number.
 $351C CALL $34E9    ; Test whether Y is zero.
 $351F EX DE,HL      ; Restore the pointers.
 $3520 RET C         ; Return if Y was zero; X is now the 'last value'.
 $3521 SCF           ; {Set the carry flag and jump back to set the 'last
 $3522 JR $350B      ; value' to 1.}

; THE 'NUMBER AND NUMBER' OPERATION (offset &08)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called indirectly via #R$33A2.
; .
; This subroutine performs the binary operation 'X AND Y' and returns X if Y is
; non-zero and the value zero otherwise.
;
; DE Address of the first byte of the second number (Y)
; HL Address of the first byte of the first number (X)
@refs=$335B
@label=no_and_no
c$3524 EX DE,HL      ; Point #REGhl at Y, #REGde at X.
 $3525 CALL $34E9    ; Test whether Y is zero.
 $3528 EX DE,HL      ; Swap the pointers back.
 $3529 RET NC        ; Return with X as the 'last value' if Y was non-zero.
 $352A AND A         ; {Reset the carry flag and jump back to set the 'last
 $352B JR $350B      ; value' to zero.}

; THE 'STRING AND NUMBER' OPERATION (offset &10)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called indirectly via #R$33A2.
; .
; This subroutine performs the binary operation 'X$ AND Y' and returns X$ if Y
; is non-zero and a null string otherwise.
;
; DE Address of the first byte of the number (Y)
@refs=$335B
@label=str_no
c$352D EX DE,HL      ; Point #REGhl at Y, #REGde at X$.
 $352E CALL $34E9    ; Test whether Y is zero.
 $3531 EX DE,HL      ; Swap the pointers back.
 $3532 RET NC        ; Return with X$ as the 'last value' if Y was non-zero.
 $3533 PUSH DE       ; Save the pointer to the number.
 $3534 DEC DE        ; Point to the fifth byte of the string parameters, i.e.
                     ; length-high.
 $3535 XOR A         ; Clear the #REGa register.
 $3536 LD (DE),A     ; Length-high is now set to zero.
 $3537 DEC DE        ; Point to length-low.
 $3538 LD (DE),A     ; Length-low is now set to zero.
 $3539 POP DE        ; Restore the pointer.
 $353A RET           ; Return with the string parameters being the 'last
                     ; value'.

; THE 'COMPARISON' OPERATIONS (offsets &09 to &0E, &11 to &16)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called indirectly via #R$33A2.
; .
; This subroutine is used to perform the twelve possible comparison operations
; (offsets &09 to &0E and &11 to &16: '<=', '>=', '<>', '>', '<' and '=' for
; numbers and strings respectively). The single operation offset is present in
; the #REGb register at the start of the subroutine.
;
; B Operation offset (&09 to &0E, &11 to &16)
; DE Address of the first byte of the second argument
; HL Address of the first byte of the first argument
@refs=$335B
@label=compare
c$353B LD A,B        ; The single offset goes to the #REGa register.
 $353C SUB $08       ; The range is now &01 to &06 and &09 to &0E.
 $353E BIT 2,A       ; {This range is changed to &00, &01, &02, &04, &05, &06,
 $3540 JR NZ,$3543   ; &08, &09, &0A, &0C, &0D, &0E.
 $3542 DEC A         ; }
@label=EX_OR_NOT
*$3543 RRCA          ; {Then reduced to &00 to &07 with carry set for 'greater
 $3544 JR NC,$354E   ; than or equal to' and 'less than'; the operations with
 $3546 PUSH AF       ; carry set are then treated as their complementary
 $3547 PUSH HL       ; operation once their values have been exchanged.
 $3548 CALL $343C    ;
 $354B POP DE        ;
 $354C EX DE,HL      ;
 $354D POP AF        ; }
@label=NU_OR_STR
*$354E BIT 2,A       ; {The numerical comparisons are now separated from the
 $3550 JR NZ,$3559   ; string comparisons by testing bit 2.}
 $3552 RRCA          ; The numerical operations now have the range &00 to &01
                     ; with carry set for 'equal' and 'not equal'.
 $3553 PUSH AF       ; Save the offset.
 $3554 CALL $300F    ; {The numbers are subtracted for the final tests.
 $3557 JR $358C      ; }
@label=STRINGS
*$3559 RRCA          ; The string comparisons now have the range &02 to &03
                     ; with carry set for 'equal' and 'not equal'.
 $355A PUSH AF       ; Save the offset.
 $355B CALL $2BF1    ; {The lengths and starting addresses of the strings are
 $355E PUSH DE       ; fetched from the calculator stack.
 $355F PUSH BC       ;
 $3560 CALL $2BF1    ; }
 $3563 POP HL        ; The length of the second string.
@label=BYTE_COMP
*$3564 LD A,H        ;
 $3565 OR L          ;
 $3566 EX (SP),HL    ;
 $3567 LD A,B        ;
 $3568 JR NZ,$3575   ; Jump unless the second string is null.
 $356A OR C          ;
@label=SECND_LOW
*$356B POP BC        ; Here the second string is either null or less than the
                     ; first.
 $356C JR Z,$3572    ;
 $356E POP AF        ;
 $356F CCF           ; {The carry is complemented to give the correct test
 $3570 JR $3588      ; results.}
@label=BOTH_NULL
*$3572 POP AF        ; {Here the carry is used as it stands.
 $3573 JR $3588      ; }
@label=SEC_PLUS
*$3575 OR C          ;
 $3576 JR Z,$3585    ; The first string is now null, the second not.
 $3578 LD A,(DE)     ; {Neither string is null, so their next bytes are
 $3579 SUB (HL)      ; compared.}
 $357A JR C,$3585    ; Jump if the first byte is less.
 $357C JR NZ,$356B   ; Jump if the second byte is less.
 $357E DEC BC        ; {The bytes are equal; so the lengths are decremented and
 $357F INC DE        ; a jump is made to #R$3564 to compare the next bytes of
 $3580 INC HL        ; the reduced strings.
 $3581 EX (SP),HL    ;
 $3582 DEC HL        ;
 $3583 JR $3564      ; }
@label=FRST_LESS
*$3585 POP BC        ;
 $3586 POP AF        ;
 $3587 AND A         ; The carry is cleared here for the correct test results.
@label=STR_TEST
*$3588 PUSH AF       ; {For the string tests, a zero is put on to the
 $3589 RST $28       ; calculator stack.}
 $358A DEFB $A0      ; #R$341B(stk_zero)
 $358B DEFB $38      ; #R$369B
@label=END_TESTS
*$358C POP AF        ; {These three tests, called as needed, give the correct
 $358D PUSH AF       ; results for all twelve comparisons. The initial carry is
 $358E CALL C,$3501  ; set for 'not equal' and 'equal', and the final carry is
 $3591 POP AF        ; set for 'greater than', 'less than' and 'equal'.
 $3592 PUSH AF       ;
 $3593 CALL NC,$34F9 ;
 $3596 POP AF        ;
 $3597 RRCA          ;
 $3598 CALL NC,$3501 ; }
 $359B RET           ; Finished.

; THE 'STRING CONCATENATION' OPERATION (offset &17)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called indirectly via #R$33A2.
; .
; This subroutine performs the binary operation 'A$+B$'. The parameters for
; these strings are fetched and the total length found. Sufficient room to hold
; both the strings is made available in the work space and the strings are
; copied over. The result of this subroutine is therefore to produce a
; temporary variable A$+B$ that resides in the work space.
@refs=$335B
@label=strs_add
c$359C CALL $2BF1    ; {The parameters of the second string are fetched and
 $359F PUSH DE       ; saved.
 $35A0 PUSH BC       ; }
 $35A1 CALL $2BF1    ; The parameters of the first string are fetched.
 $35A4 POP HL        ; {The lengths are now in #REGhl and #REGbc.
 $35A5 PUSH HL       ; }
 $35A6 PUSH DE       ; {The parameters of the first string are saved.
 $35A7 PUSH BC       ; }
 $35A8 ADD HL,BC     ; {The total length of the two strings is calculated and
 $35A9 LD B,H        ; passed to #REGbc.
 $35AA LD C,L        ; }
 $35AB RST $30       ; Sufficient room is made available.
 $35AC CALL $2AB2    ; The parameters of the new string are passed to the
                     ; calculator stack.
 $35AF POP BC        ; {The parameters of the first string are retrieved and
 $35B0 POP HL        ; the string copied to the work space as long as it is not
 $35B1 LD A,B        ; a null string.
 $35B2 OR C          ;
 $35B3 JR Z,$35B7    ;
 $35B5 LDIR          ; }
@label=OTHER_STR
*$35B7 POP BC        ; {Exactly the same procedure is followed for the second
 $35B8 POP HL        ; string thereby giving 'A$+B$'.
 $35B9 LD A,B        ;
 $35BA OR C          ;
 $35BB JR Z,$35BF    ;
 $35BD LDIR          ; }
; This routine continues into #R$35BF.

; THE 'STK-PNTRS' SUBROUTINE
;
; Used by the routines at #R$335B, #R$359C, #R$35DE and #R$3645.
; .
; This subroutine resets the #REGhl register pair to point to the first byte of
; the 'last value', i.e. #SYSVAR(STKEND)-5, and the #REGde register pair to
; point one past the 'last value', i.e. #SYSVAR(STKEND).
;
; O:DE #SYSVAR(STKEND)
; O:HL #SYSVAR(STKEND)-5
@label=STK_PNTRS
c$35BF LD HL,($5C65) ; Fetch the current value of #SYSVAR(STKEND).
 $35C2 LD DE,$FFFB   ; Set #REGde to -5, two's complement.
 $35C5 PUSH HL       ; Stack the value for #SYSVAR(STKEND).
 $35C6 ADD HL,DE     ; Calculate #SYSVAR(STKEND)-5.
 $35C7 POP DE        ; #REGde now holds #SYSVAR(STKEND) and #REGhl holds
                     ; #SYSVAR(STKEND)-5.
 $35C8 RET           ;

; THE 'CHR$' FUNCTION (offset &2F)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called indirectly via #R$33A2.
; .
; This subroutine handles the function CHR$ X and creates a single character
; string in the work space.
@refs=$335B
@label=chrs
c$35C9 CALL $2DD5    ; The 'last value' is compressed into the #REGa register.
 $35CC JR C,$35DC    ; {Give the error report if X is greater than 255, or X is
 $35CE JR NZ,$35DC   ; a negative number.}
 $35D0 PUSH AF       ; Save the compressed value of X.
@keep
 $35D1 LD BC,$0001   ; {Make one space available in the work space.
 $35D4 RST $30       ; }
 $35D5 POP AF        ; Fetch the value.
 $35D6 LD (DE),A     ; Copy the value to the work space.
 $35D7 CALL $2AB2    ; Pass the parameters of the new string to the calculator
                     ; stack.
 $35DA EX DE,HL      ; Reset the pointers.
 $35DB RET           ; Finished.
; Report B - Integer out of range.
@label=REPORT_B_4
*$35DC RST $08       ; {Call the error handling routine.
 $35DD DEFB $0A      ; }

; THE 'VAL' AND 'VAL$' FUNCTIONS (offsets &18, &1D)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called indirectly via #R$33A2.
; .
; This subroutine handles the functions VAL X$ and VAL$ X$. When handling VAL
; X$, it returns a 'last value' that is the result of evaluating the string
; (without its bounding quotes) as a numerical expression. when handling VAL$
; X$, it evaluates X$ (without its bounding quotes) as a string expression, and
; returns the parameters of that string expression as a 'last value' on the
; calculator stack.
;
; B Offset (&18 or &1D)
@refs=$335B
@label=val
c$35DE LD HL,($5C5D)  ; {The current value of #SYSVAR(CH-ADD) is preserved on
 $35E1 PUSH HL        ; the machine stack.}
 $35E2 LD A,B         ; The 'offset' for 'val' or 'val$' must be in the #REGb
                      ; register; it is now copied to #REGa.
 $35E3 ADD A,$E3      ; Produce &00 and carry set for 'val', &FB and carry
                      ; reset for 'val$'.
 $35E5 SBC A,A        ; Produce &FF (bit 6 therefore set) for 'val', but &00
                      ; (bit 6 reset) for 'val$'.
 $35E6 PUSH AF        ; Save this 'flag' on the machine stack.
 $35E7 CALL $2BF1     ; {The parameters of the string are fetched; the starting
 $35EA PUSH DE        ; address is saved; one byte is added to the length and
 $35EB INC BC         ; room made available for the string (+1) in the work
 $35EC RST $30        ; space.}
 $35ED POP HL         ; The starting address of the string goes to #REGhl as a
                      ; source address.
 $35EE LD ($5C5D),DE  ; {The pointer to the first new space goes to
 $35F2 PUSH DE        ; #SYSVAR(CH-ADD) and to the machine stack.}
 $35F3 LDIR           ; The string is copied to the work space, together with
                      ; an extra byte.
 $35F5 EX DE,HL       ; Switch the pointers.
 $35F6 DEC HL         ; {The extra byte is replaced by a 'carriage return'
 $35F7 LD (HL),$0D    ; character.}
 $35F9 RES 7,(IY+$01) ; {The syntax flag (bit 7 of #SYSVAR(FLAGS)) is reset and
 $35FD CALL $24FB     ; the string is scanned for correct syntax.}
 $3600 RST $18        ; The character after the string is fetched.
 $3601 CP $0D         ; A check is made that the end of the expression has been
                      ; reached.
 $3603 JR NZ,$360C    ; If not, the error is reported.
 $3605 POP HL         ; The starting address of the string is fetched.
 $3606 POP AF         ; {The 'flag' for 'val/val$' is fetched and bit 6 is
 $3607 XOR (IY+$01)   ; compared with bit 6 of the result (#SYSVAR(FLAGS)) of
 $360A AND $40        ; the syntax scan.}
@label=V_RPORT_C
*$360C JP NZ,$1C8A    ; Report the error if they do not match.
 $360F LD ($5C5D),HL  ; Start address to #SYSVAR(CH-ADD) again.
 $3612 SET 7,(IY+$01) ; The flag (bit 7 of #SYSVAR(FLAGS)) is set for line
                      ; execution.
 $3616 CALL $24FB     ; The string is treated as a 'next expression' and a
                      ; 'last value' produced.
 $3619 POP HL         ; {The original value of #SYSVAR(CH-ADD) is restored.
 $361A LD ($5C5D),HL  ; }
 $361D JR $35BF       ; The subroutine exits via #R$35BF which resets the
                      ; pointers.

; THE 'STR$' FUNCTION (offset &2E)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called indirectly via #R$33A2.
; .
; This subroutine handles the function STR$ X and returns a 'last value' which
; is a set of parameters that define a string containing what would appear on
; the screen if X were displayed by a PRINT command.
@refs=$335B
@keep
@label=str
c$361F LD BC,$0001   ; {One space is made in the work space and its address is
 $3622 RST $30       ; copied to #SYSVAR(K-CUR), the address of the cursor.
 $3623 LD ($5C5B),HL ; }
 $3626 PUSH HL       ; This address is saved on the stack too.
 $3627 LD HL,($5C51) ; {The current channel address (#SYSVAR(CURCHL)) is saved
 $362A PUSH HL       ; on the machine stack.}
 $362B LD A,$FF      ; {Channel 'R' is opened, allowing the string to be
 $362D CALL $1601    ; 'printed' out into the work space.}
 $3630 CALL $2DE3    ; The 'last value', X, is now printed out in the work
                     ; space and the work space is expanded with each
                     ; character.
 $3633 POP HL        ; {Restore #SYSVAR(CURCHL) to #REGhl and restore the flags
 $3634 CALL $1615    ; that are appropriate to it.}
 $3637 POP DE        ; Restore the start address of the string.
 $3638 LD HL,($5C5B) ; {Now the cursor address is one past the end of the
 $363B AND A         ; string and hence the difference is the length.
 $363C SBC HL,DE     ; }
 $363E LD B,H        ; {Transfer the length to #REGbc.
 $363F LD C,L        ; }
 $3640 CALL $2AB2    ; Pass the parameters of the new string to the calculator
                     ; stack.
 $3643 EX DE,HL      ; Reset the pointers.
 $3644 RET           ; Finished.
; Note: see #R$2DE3 for an explanation of the 'PRINT "A"+STR$ 0.1' error.

; THE 'READ-IN' SUBROUTINE (offset &1A)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called indirectly via #R$33A2.
; .
; This subroutine is called via the calculator offset (&5A) through the first
; line of #R$2634. It appears to provide for the reading in of data through
; different streams from those available on the standard Spectrum. Like #R$2634
; the subroutine returns a string.
@refs=$335B
@label=read_in
c$3645 CALL $1E94    ; The numerical parameter is compressed into the #REGa
                     ; register.
 $3648 CP $10        ; Is it smaller than 16?
 $364A JP NC,$1E9F   ; If not, report the error.
 $364D LD HL,($5C51) ; {The current channel address (#SYSVAR(CURCHL)) is saved
 $3650 PUSH HL       ; on the machine stack.}
 $3651 CALL $1601    ; The channel specified by the parameter is opened.
 $3654 CALL $15E6    ; The signal is now accepted, like a 'key-value'.
@keep
 $3657 LD BC,$0000   ; The default length of the resulting string is zero.
 $365A JR NC,$365F   ; Jump if there was no signal.
 $365C INC C         ; Set the length to 1 now.
 $365D RST $30       ; Make a space in the work space.
 $365E LD (DE),A     ; Put the string into it.
@label=R_I_STORE
*$365F CALL $2AB2    ; Pass the parameters of the string to the calculator
                     ; stack.
 $3662 POP HL        ; {Restore #SYSVAR(CURCHL) and the appropriate flags.
 $3663 CALL $1615    ; }
 $3666 JP $35BF      ; Exit, setting the pointers.

; THE 'CODE' FUNCTION (offset &1C)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called indirectly via #R$33A2.
; .
; This subroutine handles the function CODE A$ and returns the Spectrum code of
; the first character in A$, or zero if A$ is null.
@refs=$335B
@label=code
c$3669 CALL $2BF1    ; The parameters of the string are fetched.
 $366C LD A,B        ; {The length is tested and the #REGa register holding
 $366D OR C          ; zero is carried forward if A$ is a null string.
 $366E JR Z,$3671    ; }
 $3670 LD A,(DE)     ; The code of the first character is put into #REGa
                     ; otherwise.
@label=STK_CODE
*$3671 JP $2D28      ; The subroutine exits via #R$2D28 which gives the correct
                     ; 'last value'.

; THE 'LEN' FUNCTION (offset &1E)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called indirectly via #R$33A2.
; .
; This subroutine handles the function LEN A$ and returns a 'last value' that
; is equal to the length of the string.
@refs=$335B
@label=len
c$3674 CALL $2BF1    ; The parameters of the string are fetched.
 $3677 JP $2D2B      ; The subroutine exits via #R$2D2B which gives the correct
                     ; 'last value'.

; THE 'DECREASE THE COUNTER' SUBROUTINE (offset &35)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called via the calculator literal &35 by the routine at #R$3449.
; .
; This subroutine is only called by the #R$3449(series generator) and in effect
; is a '#S/DJNZ/' operation but the counter is the system variable,
; #SYSVAR(BREG), rather than the #REGb register.
;
;   HL' Address of the jump offset
; O:HL' Address of the next calculator literal to execute
@refs=$335B
@label=dec_jr_nz
c$367A EXX           ; {Go to the alternative register set and save the next
 $367B PUSH HL       ; literal pointer on the machine stack.}
 $367C LD HL,$5C67   ; Make #REGhl point to #SYSVAR(BREG).
 $367F DEC (HL)      ; Decrease #SYSVAR(BREG).
 $3680 POP HL        ; Restore the next literal pointer.
 $3681 JR NZ,$3687   ; The jump is made on non-zero.
 $3683 INC HL        ; The next literal is passed over.
 $3684 EXX           ; Return to the main register set.
 $3685 RET           ; Finished.

; THE 'JUMP' SUBROUTINE (offset &33)
;
; Used by the routine at #R$368F.
; .
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called via the calculator literal &33 by the routines at #R$2D4F, #R$37AA
; and #R$37E2.
; .
; This subroutine executes an unconditional jump when called by the literal
; '&33'.
;
;   HL' Address of the jump offset
; O:HL' Address of the next calculator literal to execute
@refs=$335B
@label=jump
c$3686 EXX           ; Go to the next alternate register set.
; This entry point is used by the routine at #R$367A.
@label=JUMP_2
*$3687 LD E,(HL)     ; The next literal (jump length) is put in the #REGe'
                     ; register.
 $3688 LD A,E        ; {The number &00 or &FF is formed in #REGa according as
 $3689 RLA           ; #REGe' is positive or negative, and is then copied to
 $368A SBC A,A       ; #REGd'.
 $368B LD D,A        ; }
 $368C ADD HL,DE     ; {#REGhl' now holds the next literal pointer.
 $368D EXX           ; }
 $368E RET           ; Finished.

; THE 'JUMP ON TRUE' SUBROUTINE (offset &00)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called via the calculator literal &00 by the routines at #R$1DDA, #R$2382,
; #R$2D4F, #R$2DE3, #R$36AF, #R$3713, #R$3783, #R$37AA, #R$37E2, #R$384A and
; #R$3851.
; .
; This subroutine executes a conditional jump if the 'last value' on the
; calculator stack, or more precisely the number addressed currently by the
; #REGde register pair, is true.
;
;   DE Address of the first byte of the last value on the calculator stack
;   HL' Address of the jump offset
; O:HL' Address of the next calculator literal to execute
@refs=$335B
@label=jump_true
c$368F INC DE        ; {Point to the third byte, which is zero or one.
 $3690 INC DE        ; }
 $3691 LD A,(DE)     ; Collect this byte in the #REGa register.
 $3692 DEC DE        ; {Point to the first byte once again.
 $3693 DEC DE        ; }
 $3694 AND A         ; Test the third byte: is it zero?
 $3695 JR NZ,$3686   ; Make the jump if the byte is non-zero, i.e. if the
                     ; number is not-false.
 $3697 EXX           ; Go to the alternate register set.
 $3698 INC HL        ; Pass over the jump length.
 $3699 EXX           ; Back to the main set of registers.
 $369A RET           ; Finished.

; THE 'END-CALC' SUBROUTINE (offset &38)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called via the calculator literal &38 by the routines at #R$03F8, #R$1736,
; #R$1CDE, #R$1CF0, #R$1D03, #R$1DAB, #R$1DDA, #R$2320, #R$2382, #R$247D,
; #R$25F8, #R$2627, #R$26C9, #R$2AFF, #R$2C9B, #R$2D2B, #R$2D3B, #R$2D4F,
; #R$2DA2, #R$2DC1, #R$2DE3, #R$3449, #R$353B, #R$36A0, #R$36AF, #R$36C4,
; #R$3713, #R$3783, #R$37B5, #R$37DA, #R$37E2, #R$3833, #R$3843, #R$384A and
; #R$3851.
; .
; This subroutine ends a RST #o28 operation.
@refs=$335B
@label=end_calc
c$369B POP AF        ; The return address to the calculator (#R$3365) is
                     ; discarded.
 $369C EXX           ; {Instead, the address in #REGhl' is put on the machine
 $369D EX (SP),HL    ; stack and an indirect jump is made to it. #REGhl' will
 $369E EXX           ; now hold any earlier address in the calculator chain of
                     ; addresses.}
 $369F RET           ; Finished.

; THE 'MODULUS' SUBROUTINE (offset &32)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called via the calculator literal &32 by the routine at #R$25F8.
; .
; This subroutine calculates N (mod M), where M is a positive integer held at
; the top of the calculator stack (the 'last value'), and N is the integer held
; on the stack beneath M.
; .
; The subroutine returns the integer quotient INT (N/M) at the top of the
; calculator stack (the 'last value'), and the remainder N-INT (N/M) in the
; second place on the stack.
; .
; This subroutine is called during the calculation of a random number to reduce
; N mod 65537.
@refs=$335B
@label=n_mod_m
c$36A0 RST $28       ; N, M
 $36A1 DEFB $C0      ; #R$342D(st_mem_0): N, M (mem-0 holds M)
 $36A2 DEFB $02      ; #R$33A1: N
 $36A3 DEFB $31      ; #R$33C0: N, N
 $36A4 DEFB $E0      ; #R$340F(get_mem_0): N, N, M
 $36A5 DEFB $05      ; #R$31AF: N, N/M
 $36A6 DEFB $27      ; #R$36AF: N, INT (N/M)
 $36A7 DEFB $E0      ; #R$340F(get_mem_0): N, INT (N/M), M
 $36A8 DEFB $01      ; #R$343C: N, M, INT (N/M)
 $36A9 DEFB $C0      ; #R$342D(st_mem_0): N, M, INT (N/M) (mem-0 holds INT
                     ; (N/M))
 $36AA DEFB $04      ; #R$30CA: N, M*INT (N/M)
 $36AB DEFB $03      ; #R$300F: N-M*INT (N/M)
 $36AC DEFB $E0      ; #R$340F(get_mem_0): N-M*INT (N/M), INT (N/M)
 $36AD DEFB $38      ; #R$369B
 $36AE RET           ; Finished.

; THE 'INT' FUNCTION (offset &27)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called via the calculator literal &27 by the routines at #R$03F8, #R$2DA2,
; #R$2DC1, #R$2DE3, #R$36A0, #R$36C4 and #R$3783. It is also called indirectly
; via #R$33A2.
; .
; This subroutine handles the function INT X and returns a 'last value' that is
; the 'integer part' of the value supplied. Thus INT 2.4 gives 2 but as the
; subroutine always rounds the result down INT -2.4 gives -3.
; .
; The subroutine uses #R$3214 to produce I(X) such that I(2.4)=2 and
; I(-2.4)=-2. Thus, INT X is given by I(X) when X>=0, and by I(X)-1 for
; negative values of X that are not already integers, when the result is, of
; course, I(X).
@refs=$335B
@label=int
c$36AF RST $28       ; X
 $36B0 DEFB $31      ; #R$33C0: X, X
 $36B1 DEFB $36      ; #R$3506: X, (1/0)
 $36B2 DEFB $00      ; {#R$368F to #R$36B7: X
 $36B3 DEFB $04      ; }
; For values of X that have been shown to be greater than or equal to zero
; there is no jump and I(X) is readily found.
 $36B4 DEFB $3A      ; #R$3214: I(X)
 $36B5 DEFB $38      ; #R$369B
 $36B6 RET           ; Finished.
; When X is a negative integer I(X) is returned, otherwise I(X)-1 is returned.
@label=X_NEG
 $36B7 DEFB $31      ; #R$33C0: X, X
 $36B8 DEFB $3A      ; #R$3214: X, I(X)
 $36B9 DEFB $C0      ; #R$342D(st_mem_0): X, I(X) (mem-0 holds I(X))
 $36BA DEFB $03      ; #R$300F: X-I(X)
 $36BB DEFB $E0      ; #R$340F(get_mem_0): X-I(X), I(X)
 $36BC DEFB $01      ; #R$343C: I(X), X-I(X)
 $36BD DEFB $30      ; #R$3501: I(X), (1/0)
 $36BE DEFB $00      ; {#R$368F to #R$36C2: I(X)
 $36BF DEFB $03      ; }
; The jump is made for values of X that are negative integers, otherwise there
; is no jump and I(X)-1 is calculated.
 $36C0 DEFB $A1      ; #R$341B(stk_one): I(X), 1
 $36C1 DEFB $03      ; #R$300F: I(X)-1
; In either case the subroutine finishes with:
@label=EXIT
 $36C2 DEFB $38      ; #R$369B: I(X) or I(X)-1
 $36C3 RET           ;

; THE 'EXPONENTIAL' FUNCTION (offset &26)
;
; Used by the routine at #R$3851.
; .
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called indirectly via #R$33A2.
; .
; This subroutine handles the function EXP X and is the first of four routines
; that use the #R$3449(series generator) to produce Chebyshev polynomials.
; .
; The approximation to EXP X is found as follows:
; .
; #LIST
; { i. X is divided by LN 2 to give Y, so that 2**Y is now the required result.
; }
; { ii. The value N is found, such that N=INT Y. }
; { iii. The value W=Y-N is found; 0<=W<=1, as required for the series to
; converge. }
; { iv. The argument Z=2*W-1 is formed. }
; { v. The #R$3449(series generator) is used to return 2**W. }
; { vi. Finally N is added to the exponent, giving 2**(N+W), which is 2**Y and
; therefore the required answer. }
; LIST#
@refs=$335B
@label=exp
c$36C4 RST $28                  ; X
; Perform step i.
 $36C5 DEFB $3D                 ; #R$3297: X (in full floating-point form)
 $36C6 DEFB $34                 ; {#R$33C6: X, 1/LN 2
 $36C7 DEFB $F1,$38,$AA,$3B,$29 ; }
 $36CC DEFB $04                 ; #R$30CA: X/LN 2=Y
; Perform step ii.
 $36CD DEFB $31                 ; #R$33C0: Y, Y
 $36CE DEFB $27                 ; #R$36AF: Y, INT Y=N
 $36CF DEFB $C3                 ; #R$342D(st_mem_3): Y, N (mem-3 holds N)
; Perform step iii.
 $36D0 DEFB $03                 ; #R$300F: Y-N=W
; Perform step iv.
 $36D1 DEFB $31                 ; #R$33C0: W, W
 $36D2 DEFB $0F                 ; #R$3014: 2*W
 $36D3 DEFB $A1                 ; #R$341B(stk_one): 2*W, 1
 $36D4 DEFB $03                 ; #R$300F: 2*W-1=Z
; Perform step v, passing to the #R$3449(series generator) the parameter '8'
; and the eight constants required.
 $36D5 DEFB $88                 ; #R$3449(series_08): Z
 $36D6 DEFB $13,$36             ;
 $36D8 DEFB $58,$65,$66         ;
 $36DB DEFB $9D,$78,$65,$40     ;
 $36DF DEFB $A2,$60,$32,$C9     ;
 $36E3 DEFB $E7,$21,$F7,$AF,$24 ;
 $36E8 DEFB $EB,$2F,$B0,$B0,$14 ;
 $36ED DEFB $EE,$7E,$BB,$94,$58 ;
 $36F2 DEFB $F1,$3A,$7E,$F8,$CF ;
; At the end of the last loop the 'last value' is 2**W.
; .
; Perform step vi.
 $36F7 DEFB $E3                 ; #R$340F(get_mem_3): 2**W, N
 $36F8 DEFB $38                 ; #R$369B
 $36F9 CALL $2DD5               ; The absolute value of N mod 256 is put into
                                ; the #REGa register.
 $36FC JR NZ,$3705              ; Jump forward if N was negative.
 $36FE JR C,$3703               ; Error if ABS N>&FF.
 $3700 ADD A,(HL)               ; Now add ABS N to the exponent.
 $3701 JR NC,$370C              ; Jump unless e>&FF.
; Report 6 - Number too big.
@label=REPORT_6_2
*$3703 RST $08                  ; {Call the error handling routine.
 $3704 DEFB $05                 ; }
@label=N_NEGTV
*$3705 JR C,$370E               ; The result is to be zero if N<-255.
 $3707 SUB (HL)                 ; Subtract ABS N from the exponent as N was
                                ; negative.
 $3708 JR NC,$370E              ; Zero result if e less than zero.
 $370A NEG                      ; Minus e is changed to e.
@label=RESULT_OK
*$370C LD (HL),A                ; The exponent, e, is entered.
 $370D RET                      ; Finished: 'last value' is EXP X.
@label=RSLT_ZERO
*$370E RST $28                  ; Use the calculator to make the 'last value'
                                ; zero.
 $370F DEFB $02                 ; #R$33A1 (the stack is now empty)
 $3710 DEFB $A0                 ; #R$341B(stk_zero): 0
 $3711 DEFB $38                 ; #R$369B
 $3712 RET                      ; Finished, with EXP X=0.

; THE 'NATURAL LOGARITHM' FUNCTION (offset &25)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called via the calculator literal &25 by the routine at #R$3851. It is
; also called indirectly via #R$33A2.
; .
; This subroutine handles the function LN X and is the second of the four
; routines that use the #R$3449(series generator) to produce Chebyshev
; polynomials.
; .
; The approximation to LN X is found as follows:
; .
; #LIST
; { i. X is tested and report A is given if X is not positive. }
; { ii. X is then split into its true exponent, e', and its mantissa
; X'=X/(2**e'), where 0.5<=X'<1. }
; { iii. The required value Y1 or Y2 is formed: if X'>0.8 then Y1=e'*LN 2,
; otherwise Y2=(e'-1)*LN 2. }
; { iv. If X'>0.8 then the quantity X'-1 is stacked; otherwise 2*X'-1 is
; stacked. }
; { v. Now the argument Z is formed, being 2.5*X'-3 if X'>0.8, otherwise
; 5*X'-3. In each case, -1<=Z<=1, as required for the series to converge. }
; { vi. The #R$3449(series generator) is used to produce the required function.
; }
; { vii. Finally a simple multiplication and addition leads to LN X being
; returned as the 'last value'. }
; LIST#
@refs=$335B
@label=ln
c$3713 RST $28                  ; X
; Perform step i.
 $3714 DEFB $3D                 ; #R$3297: X (in full floating-point form)
 $3715 DEFB $31                 ; #R$33C0: X, X
 $3716 DEFB $37                 ; #R$34F9: X, (1/0)
 $3717 DEFB $00                 ; #R$368F to #R$371C: X
 $3718 DEFB $04                 ; #R$30CA: X
 $3719 DEFB $38                 ; #R$369B: X
; Report A - Invalid argument.
 $371A RST $08                  ; {Call the error handling routine.
 $371B DEFB $09                 ; }
; Perform step ii.
@label=VALID
 $371C DEFB $A0                 ; #R$341B(stk_zero): X, 0 (the deleted 1 is
                                ; overwritten with zero)
 $371D DEFB $02                 ; #R$33A1: X
 $371E DEFB $38                 ; #R$369B: X
 $371F LD A,(HL)                ; The exponent, e, goes into #REGa.
 $3720 LD (HL),$80              ; X is reduced to X'.
 $3722 CALL $2D28               ; The stack holds: X', e.
 $3725 RST $28                  ; X', e
 $3726 DEFB $34                 ; {#R$33C6: X', e, 128
 $3727 DEFB $38,$00             ; }
 $3729 DEFB $03                 ; #R$300F: X', e'
; Perform step iii.
 $372A DEFB $01                 ; #R$343C: e', X'
 $372B DEFB $31                 ; #R$33C0: e', X', X'
 $372C DEFB $34                 ; {#R$33C6: e', X', X', 0.8
 $372D DEFB $F0,$4C,$CC,$CC,$CD ; }
 $3732 DEFB $03                 ; #R$300F: e', X', X'-0.8
 $3733 DEFB $37                 ; #R$34F9: e', X', (1/0)
 $3734 DEFB $00                 ; {#R$368F to #R$373D: e', X'
 $3735 DEFB $08                 ; }
 $3736 DEFB $01                 ; #R$343C: X', e'
 $3737 DEFB $A1                 ; #R$341B(stk_one): X', e', 1
 $3738 DEFB $03                 ; #R$300F: X', e'-1
 $3739 DEFB $01                 ; #R$343C: e'-1, X'
 $373A DEFB $38                 ; #R$369B
 $373B INC (HL)                 ; Double X' to give 2*X'.
 $373C RST $28                  ; e'-1, 2*X'
@label=GRE_8
 $373D DEFB $01                 ; #R$343C: X', e' (X'>0.8) or 2*X', e'-1
                                ; (X'<=0.8)
 $373E DEFB $34                 ; {#R$33C6: X', e', LN 2 or 2*X', e'-1, LN 2
 $373F DEFB $F0,$31,$72,$17,$F8 ; }
 $3744 DEFB $04                 ; #R$30CA: X', e'*LN 2=Y1 or 2*X', (e'-1)*LN
                                ; 2=Y2
; Perform step iv.
 $3745 DEFB $01                 ; #R$343C: Y1, X' (X'>0.8) or Y2, 2*X'
                                ; (X'<=0.8)
 $3746 DEFB $A2                 ; #R$341B(stk_half): Y1, X', .5 or Y2, 2*X', .5
 $3747 DEFB $03                 ; #R$300F: Y1, X'-.5 or Y2, 2*X'-.5
 $3748 DEFB $A2                 ; #R$341B(stk_half): Y1, X'-.5, .5 or Y2,
                                ; 2*X'-.5, .5
 $3749 DEFB $03                 ; #R$300F: Y1, X'-1 or Y2, 2*X'-1
; Perform step v.
 $374A DEFB $31                 ; #R$33C0: Y, X'-1, X'-1 or Y2, 2*X'-1, 2*X'-1
 $374B DEFB $34                 ; {#R$33C6: Y1, X'-1, X'-1, 2.5 or Y2, 2*X'-1,
 $374C DEFB $32,$20             ; 2*X'-1, 2.5}
 $374E DEFB $04                 ; #R$30CA: Y1, X'-1, 2.5*X'-2.5 or Y2, 2*X'-1,
                                ; 5*X'-2.5
 $374F DEFB $A2                 ; #R$341B(stk_half): Y1, X'-1, 2.5*X'-2.5, .5
                                ; or Y2, 2*X'-1, 5*X'-2.5, .5
 $3750 DEFB $03                 ; #R$300F: Y1, X'-1, 2.5*X'-3=Z or Y2, 2*X'-1,
                                ; 5*X'-3=Z
; Perform step vi, passing to the #R$3449(series generator) the parameter '12',
; and the twelve constants required.
 $3751 DEFB $8C                 ; #R$3449(series_0C): Y1, X'-1, Z or Y2,
                                ; 2*X'-1, Z
 $3752 DEFB $11,$AC             ;
 $3754 DEFB $14,$09             ;
 $3756 DEFB $56,$DA,$A5         ;
 $3759 DEFB $59,$30,$C5         ;
 $375C DEFB $5C,$90,$AA         ;
 $375F DEFB $9E,$70,$6F,$61     ;
 $3763 DEFB $A1,$CB,$DA,$96     ;
 $3767 DEFB $A4,$31,$9F,$B4     ;
 $376B DEFB $E7,$A0,$FE,$5C,$FC ;
 $3770 DEFB $EA,$1B,$43,$CA,$36 ;
 $3775 DEFB $ED,$A7,$9C,$7E,$5E ;
 $377A DEFB $F0,$6E,$23,$80,$93 ;
; At the end of the last loop the 'last value' is:
; .
; #LIST
; { LN X'/(X'-1) if X'>0.8 }
; { LN (2*X')/(2*X'-1) if X'<=0.8 }
; LIST#
; .
; Perform step vii.
 $377F DEFB $04                 ; #R$30CA: Y1=LN (2**e'), LN X' or Y2=LN
                                ; (2**(e'-1)), LN (2*X')
 $3780 DEFB $0F                 ; #R$3014: LN (2**e')*X')=LN X or LN
                                ; (2**(e'-1)*2*X')=LN X
 $3781 DEFB $38                 ; #R$369B: LN X
 $3782 RET                      ; Finished: 'last value' is LN X.

; THE 'REDUCE ARGUMENT' SUBROUTINE (offset &39)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called via the calculator literal &39 by the routines at #R$37AA and
; #R$37B5.
; .
; This subroutine transforms the argument X of SIN X or COS X into a value V.
; .
; The subroutine first finds the value Y=X/2#pi-INT(X/2#pi+0.5), where
; -0.5<=Y<0.5.
; .
; The subroutine returns with:
; .
; #LIST
; { V=4*Y if -1<=4*Y<=1 (case i) }
; { or V=2-4*Y if 1<4*Y<2 (case ii) }
; { or V=-4*Y-2 if -2<=4*Y<-1 (case iii) }
; LIST#
; .
; In each case, -1<=V<=1 and SIN (#piV/2)=SIN X.
@refs=$335B
@label=get_argt
c$3783 RST $28                  ; X
 $3784 DEFB $3D                 ; #R$3297: X (in full floating-point form)
 $3785 DEFB $34                 ; {#R$33C6: X, 1/2#pi
 $3786 DEFB $EE,$22,$F9,$83,$6E ; }
 $378B DEFB $04                 ; #R$30CA: X/2#pi
 $378C DEFB $31                 ; #R$33C0: X/2#pi, X/2#pi
 $378D DEFB $A2                 ; #R$341B(stk_half): X/2#pi, X/2#pi, 0.5
 $378E DEFB $0F                 ; #R$3014: X/2#pi, X/2#pi+0.5
 $378F DEFB $27                 ; #R$36AF: X/2#pi, INT (X/2#pi+0.5)
 $3790 DEFB $03                 ; #R$300F: X/2#pi-INT (X/2#pi+0.5)=Y
; Note: adding 0.5 and taking INT rounds the result to the nearest integer.
 $3791 DEFB $31                 ; #R$33C0: Y, Y
 $3792 DEFB $0F                 ; #R$3014: 2*Y
 $3793 DEFB $31                 ; #R$33C0: 2*Y, 2*Y
 $3794 DEFB $0F                 ; #R$3014: 4*Y
 $3795 DEFB $31                 ; #R$33C0: 4*Y, 4*Y
 $3796 DEFB $2A                 ; #R$346A: 4*Y, ABS (4*Y)
 $3797 DEFB $A1                 ; #R$341B(stk_one): 4*Y, ABS (4*Y), 1
 $3798 DEFB $03                 ; #R$300F: 4*Y, ABS (4*Y)-1=Z
 $3799 DEFB $31                 ; #R$33C0: 4*Y, Z, Z
 $379A DEFB $37                 ; #R$34F9: 4*Y, Z, (1/0)
 $379B DEFB $C0                 ; #R$342D(st_mem_0): (mem-0 holds the result of
                                ; the test)
 $379C DEFB $00                 ; {#R$368F to #R$37A1: 4*Y, Z
 $379D DEFB $04                 ; }
 $379E DEFB $02                 ; #R$33A1: 4*Y
 $379F DEFB $38                 ; #R$369B: 4*Y=V (case i)
 $37A0 RET                      ; Finished.
; If the jump was made then continue.
@label=ZPLUS
 $37A1 DEFB $A1                 ; #R$341B(stk_one): 4*Y, Z, 1
 $37A2 DEFB $03                 ; #R$300F: 4*Y, Z-1
 $37A3 DEFB $01                 ; #R$343C: Z-1, 4*Y
 $37A4 DEFB $36                 ; #R$3506: Z-1, (1/0)
 $37A5 DEFB $00                 ; {#R$368F to #R$37A8: Z-1
 $37A6 DEFB $02                 ; }
 $37A7 DEFB $1B                 ; #R$346E: 1-Z
@label=YNEG
 $37A8 DEFB $38                 ; #R$369B: 1-Z=V (case ii) or Z-1=V (case iii)
 $37A9 RET                      ; Finished.

; THE 'COSINE' FUNCTION (offset &20)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called via the calculator literal &20 by the routines at #R$2382 and
; #R$37DA. It is also called indirectly via #R$33A2.
; .
; This subroutine handles the function COS X and returns a 'last value' 'that
; is an approximation to COS X.
; .
; The subroutine uses the expression COS X=SIN (#piW/2), where -1<=W<=1.
; .
; In deriving W for X the subroutine uses the test result obtained in the
; previous subroutine and stored for this purpose in mem-0. It then jumps to
; the #R$37B5 subroutine, entering at #R$37B7, to produce a 'last value' of COS
; X.
@refs=$335B
@label=cos
c$37AA RST $28       ; X
 $37AB DEFB $39      ; #R$3783: V
 $37AC DEFB $2A      ; #R$346A: ABS V
 $37AD DEFB $A1      ; #R$341B(stk_one): ABS V, 1
 $37AE DEFB $03      ; #R$300F: ABS V-1
 $37AF DEFB $E0      ; #R$340F(get_mem_0): ABS V-1, (1/0)
 $37B0 DEFB $00      ; {#R$368F to #R$37B7: ABS V-1=W
 $37B1 DEFB $06      ; }
; If the jump was not made then continue.
 $37B2 DEFB $1B      ; #R$346E: 1-ABS V
 $37B3 DEFB $33      ; {#R$3686 to #R$37B7: 1-ABS V=W
 $37B4 DEFB $03      ; }

; THE 'SINE' FUNCTION (offset &1F)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called via the calculator literal &1F by the routines at #R$2382, #R$247D
; and #R$37DA. It is also called indirectly via #R$33A2.
; .
; This subroutine handles the function SIN X and is the third of the four
; routines that use the #R$3449(series generator) to produce Chebyshev
; polynomials.
; .
; The approximation to SIN X is found as follows:
; .
; #LIST
; { i. The argument X is reduced to W, such that SIN (#pi*W/2)=SIN X. Note that
; -1<=W<=1, as required for the series to converge. }
; { ii. The argument Z=2*W*W-1 is formed. }
; { iii. The #R$3449(series generator) is used to return (SIN (#pi*W/2))/W. }
; { iv. Finally a simple multiplication by W gives SIN X. }
; LIST#
@refs=$335B
@label=sin
c$37B5 RST $28                  ; X
; Perform step i.
 $37B6 DEFB $39                 ; #R$3783: W
; Perform step ii. The subroutine from now on is common to both the SINE and
; COSINE functions.
@label=C_ENT
 $37B7 DEFB $31                 ; #R$33C0: W, W
 $37B8 DEFB $31                 ; #R$33C0: W, W, W
 $37B9 DEFB $04                 ; #R$30CA: W, W*W
 $37BA DEFB $31                 ; #R$33C0: W, W*W, W*W
 $37BB DEFB $0F                 ; #R$3014: W, 2*W*W
 $37BC DEFB $A1                 ; #R$341B(stk_one): W, 2*W*W, 1
 $37BD DEFB $03                 ; #R$300F: W, 2*W*W-1=Z
; Perform step iii, passing to the #R$3449(series generator) the parameter '6'
; and the six constants required.
 $37BE DEFB $86                 ; #R$3449(series_06): W, Z
 $37BF DEFB $14,$E6             ;
 $37C1 DEFB $5C,$1F,$0B         ;
 $37C4 DEFB $A3,$8F,$38,$EE     ;
 $37C8 DEFB $E9,$15,$63,$BB,$23 ;
 $37CD DEFB $EE,$92,$0D,$CD,$ED ;
 $37D2 DEFB $F1,$23,$5D,$1B,$EA ;
; At the end of the last loop the 'last value' is (SIN (#pi*W/2))/W.
; .
; Perform step iv.
 $37D7 DEFB $04                 ; #R$30CA: SIN (#pi*W/2)=SIN X (or COS X)
 $37D8 DEFB $38                 ; #R$369B
 $37D9 RET                      ; Finished: 'last value'=SIN X (or COS X).

; THE 'TAN' FUNCTION (offset &21)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called indirectly via #R$33A2.
; .
; This subroutine handles the function TAN X. It simply returns SIN X/COS X,
; with arithmetic overflow if COS X=0.
@refs=$335B
@label=tan
c$37DA RST $28       ; X
 $37DB DEFB $31      ; #R$33C0: X, X
 $37DC DEFB $1F      ; #R$37B5: X, SIN X
 $37DD DEFB $01      ; #R$343C: SIN X, X
 $37DE DEFB $20      ; #R$37AA: SIN X, COS X
 $37DF DEFB $05      ; #R$31AF: SIN X/COS X=TAN X (report arithmetic overflow
                     ; if needed)
 $37E0 DEFB $38      ; #R$369B: TAN X
 $37E1 RET           ; Finished: 'last value'=TAN X.

; THE 'ARCTAN' FUNCTION (offset &24)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called via the calculator literal &24 by the routine at #R$3833. It is
; also called indirectly via #R$33A2.
; .
; This subroutine handles the function ATN X and is the last of the four
; routines that use the #R$3449(series generator) to produce Chebyshev
; polynomials. It returns a real number between -#pi/2 and #pi/2, which is
; equal to the value in radians of the angle whose tan is X.
; .
; The approximation to ATN X is found as follows:
; .
; i. The values W and Y are found for three cases of X, such that:
; .
; #LIST
; { if -1<X<1 then W=0, Y=X (case i) }
; { if 1<=X then W=#pi/2, Y=-1/X (case ii) }
; { if X<=-1 then W=-#pi/2, Y=-1/X (case iii) }
; LIST#
; .
; In each case, -1<=Y<=1, as required for the series to converge.
; .
; ii. The argument Z is formed, such that:
; .
; #LIST
; { if -1<X<1 then Z=2*Y*Y-1=2*X*X-1 (case i) }
; { otherwise Z=2*Y*Y-1=2/(X*X)-1 (cases ii and iii) }
; LIST#
; .
; iii. The #R$3449(series generator) is used to produce the required function.
; .
; iv. Finally a simple multiplication and addition give ATN X.
;
; HL Address of the first byte of the number (X)
;
; Perform step i.
@refs=$335B
@label=atn
c$37E2 CALL $3297               ; Use the full floating-point form of X.
 $37E5 LD A,(HL)                ; Fetch the exponent of X.
 $37E6 CP $81                   ; {Jump forward for case i: Y=X.
 $37E8 JR C,$37F8               ; }
 $37EA RST $28                  ; X
 $37EB DEFB $A1                 ; #R$341B(stk_one): X, 1
 $37EC DEFB $1B                 ; #R$346E: X, -1
 $37ED DEFB $01                 ; #R$343C: -1, X
 $37EE DEFB $05                 ; #R$31AF: -1/X
 $37EF DEFB $31                 ; #R$33C0: -1/X, -1/X
 $37F0 DEFB $36                 ; #R$3506: -1/X, (1/0)
 $37F1 DEFB $A3                 ; #R$341B(stk_pi_2): -1/X, (1/0), #pi/2
 $37F2 DEFB $01                 ; #R$343C: -1/X, #pi/2, (1/0)
 $37F3 DEFB $00                 ; {#R$368F to #R$37FA for case ii: -1/X, #pi/2
 $37F4 DEFB $06                 ; }
 $37F5 DEFB $1B                 ; #R$346E: -1/X, -#pi/2
 $37F6 DEFB $33                 ; {#R$3686 to #R$37FA for case iii: -1/X,
 $37F7 DEFB $03                 ; -#pi/2}
@label=SMALL
*$37F8 RST $28                  ;
 $37F9 DEFB $A0                 ; #R$341B(stk_zero): Y, 0; continue for case i:
                                ; W=0
; Perform step ii.
@label=CASES
 $37FA DEFB $01                 ; #R$343C: W, Y
 $37FB DEFB $31                 ; #R$33C0: W, Y, Y
 $37FC DEFB $31                 ; #R$33C0: W, Y, Y, Y
 $37FD DEFB $04                 ; #R$30CA: W, Y, Y*Y
 $37FE DEFB $31                 ; #R$33C0: W, Y, Y*Y, Y*Y
 $37FF DEFB $0F                 ; #R$3014: W, Y, 2*Y*Y
 $3800 DEFB $A1                 ; #R$341B(stk_one): W, Y, 2*Y*Y, 1
 $3801 DEFB $03                 ; #R$300F: W, Y, 2*Y*Y-1=Z
; Perform step iii, passing to the #R$3449(series generator) the parameter
; '12', and the twelve constants required.
 $3802 DEFB $8C                 ; #R$3449(series_0C): W, Y, Z
 $3803 DEFB $10,$B2             ;
 $3805 DEFB $13,$0E             ;
 $3807 DEFB $55,$E4,$8D         ;
 $380A DEFB $58,$39,$BC         ;
 $380D DEFB $5B,$98,$FD         ;
 $3810 DEFB $9E,$00,$36,$75     ;
 $3814 DEFB $A0,$DB,$E8,$B4     ;
 $3818 DEFB $63,$42,$C4         ;
 $381B DEFB $E6,$B5,$09,$36,$BE ;
 $3820 DEFB $E9,$36,$73,$1B,$5D ;
 $3825 DEFB $EC,$D8,$DE,$63,$BE ;
 $382A DEFB $F0,$61,$A1,$B3,$0C ;
; At the end of the last loop the 'last value' is:
; .
; #LIST
; { ATN X/X (case i) }
; { ATN (-1/X)/(-1/X) (cases ii and iii) }
; LIST#
; .
; Perform step iv.
 $382F DEFB $04                 ; #R$30CA: W, ATN X (case i) or W, ATN (-1/X)
                                ; (cases ii and iii)
 $3830 DEFB $0F                 ; #R$3014: ATN X (all cases now)
 $3831 DEFB $38                 ; #R$369B
 $3832 RET                      ; Finished: 'last value'=ATN X.

; THE 'ARCSIN' FUNCTION (offset &22)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called via the calculator literal &22 by the routine at #R$3843. It is
; also called indirectly via #R$33A2.
; .
; This subroutine handles the function ASN X and returns a real number from
; -#pi/2 to #pi/2 inclusive which is equal to the value in radians of the angle
; whose sine is X. Thereby if Y=ASN X then X=SIN Y.
; .
; This subroutine uses the trigonometric identity TAN (Y/2)=SIN Y/(1+COS Y) to
; obtain TAN (Y/2) and hence (using ATN) Y/2 and finally Y.
@refs=$335B
@label=asn
c$3833 RST $28       ; X
 $3834 DEFB $31      ; #R$33C0: X, X
 $3835 DEFB $31      ; #R$33C0: X, X, X
 $3836 DEFB $04      ; #R$30CA: X, X*X
 $3837 DEFB $A1      ; #R$341B(stk_one): X, X*X, 1
 $3838 DEFB $03      ; #R$300F: X, X*X-1
 $3839 DEFB $1B      ; #R$346E: X, 1-X*X
 $383A DEFB $28      ; #R$384A: X, SQR (1-X*X)
 $383B DEFB $A1      ; #R$341B(stk_one): X, SQR (1-X*X), 1
 $383C DEFB $0F      ; #R$3014: X, 1+SQR (1-X*X)
 $383D DEFB $05      ; #R$31AF: X/(1+SQR (1-X*X))=TAN (Y/2)
 $383E DEFB $24      ; #R$37E2: Y/2
 $383F DEFB $31      ; #R$33C0: Y/2, Y/2
 $3840 DEFB $0F      ; #R$3014: Y=ASN X
 $3841 DEFB $38      ; #R$369B
 $3842 RET           ; Finished: 'last value'=ASN X.

; THE 'ARCCOS' FUNCTION (offset &23)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called indirectly via #R$33A2.
; .
; This subroutine handles the function ACS X and returns a real number from 0
; to #pi inclusive which is equal to the value in radians of the angle whose
; cosine is X.
; .
; This subroutine uses the relation ACS X=#pi/2-ASN X.
@refs=$335B
@label=acs
c$3843 RST $28       ; X
 $3844 DEFB $22      ; #R$3833: ASN X
 $3845 DEFB $A3      ; #R$341B(stk_pi_2): ASN X, #pi/2
 $3846 DEFB $03      ; #R$300F: ASN X-#pi/2
 $3847 DEFB $1B      ; #R$346E: #pi/2-ASN X=ACS X
 $3848 DEFB $38      ; #R$369B
 $3849 RET           ; Finished: 'last value'=ACS X.

; THE 'SQUARE ROOT' FUNCTION (offset &28)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called via the calculator literal &28 by the routines at #R$247D and
; #R$3833. It is also called indirectly via #R$33A2.
; .
; This subroutine handles the function SQR X and returns the positive square
; root of the real number X if X is positive, and zero if X is zero. A negative
; value of X gives rise to report A - invalid argument (via #R$3851).
; .
; This subroutine treats the square root operation as being X**0.5 and
; therefore stacks the value 0.5 and proceeds directly into #R$3851.
@refs=$335B
@label=sqr
c$384A RST $28       ; X
 $384B DEFB $31      ; #R$33C0: X, X
 $384C DEFB $30      ; #R$3501: X, (1/0)
 $384D DEFB $00      ; {#R$368F to #R$386C: X
 $384E DEFB $1E      ; }
; The jump is made if X=0; otherwise continue with:
 $384F DEFB $A2      ; #R$341B(stk_half): X, 0.5
 $3850 DEFB $38      ; #R$369B
; Continue into #R$3851 to find the result of X**0.5.

; THE 'EXPONENTIATION' OPERATION (offset &06)
;
; The address of this routine is found in the #R$32D7(table of addresses). It
; is called indirectly via #R$33A2, and the routine at #R$384A continues here.
; .
; This subroutine performs the binary operation of raising the first number, X,
; to the power of the second number, Y.
; .
; The subroutine treats the result X**Y as being equivalent to EXP (Y*LN X). It
; returns this value unless X is zero, in which case it returns 1 if Y is also
; zero (0**0=1), returns zero if Y is positive, and reports arithmetic overflow
; if Y is negative.
@refs=$335B
@label=to_power
c$3851 RST $28       ; X, Y
 $3852 DEFB $01      ; #R$343C: Y, X
 $3853 DEFB $31      ; #R$33C0: Y, X, X
 $3854 DEFB $30      ; #R$3501: Y, X, (1/0)
 $3855 DEFB $00      ; {#R$368F to #R$385D: Y, X
 $3856 DEFB $07      ; }
; The jump is made if X=0, otherwise EXP (Y*LN X) is formed.
 $3857 DEFB $25      ; #R$3713: Y, LN X
; Giving report A if X is negative.
 $3858 DEFB $04      ; #R$30CA: Y*LN X
 $3859 DEFB $38      ; #R$369B
 $385A JP $36C4      ; Exit via #R$36C4 to form EXP (Y*LN X).
; The value of X is zero so consider the three possible cases involved.
@label=XIS0
 $385D DEFB $02      ; #R$33A1: Y
 $385E DEFB $31      ; #R$33C0: Y, Y
 $385F DEFB $30      ; #R$3501: Y, (1/0)
 $3860 DEFB $00      ; {#R$368F to #R$386A: Y
 $3861 DEFB $09      ; }
; The jump is made if X=0 and Y=0, otherwise proceed.
 $3862 DEFB $A0      ; #R$341B(stk_zero): Y, 0
 $3863 DEFB $01      ; #R$343C: 0, Y
 $3864 DEFB $37      ; #R$34F9: 0, (1/0)
 $3865 DEFB $00      ; {#R$368F to #R$386C: 0
 $3866 DEFB $06      ; }
; The jump is made if X=0 and Y is positive, otherwise proceed.
 $3867 DEFB $A1      ; #R$341B(stk_one): 0, 1
 $3868 DEFB $01      ; #R$343C: 1, 0
 $3869 DEFB $05      ; #R$31AF: Exit via #R$31AF as dividing by zero gives
                     ; 'arithmetic overflow'.
; The result is to be 1 for the operation.
@label=ONE
 $386A DEFB $02      ; #R$33A1: -
 $386B DEFB $A1      ; #R$341B(stk_one): 1
; Now return with the 'last value' on the stack being 0**Y.
@label=LAST
 $386C DEFB $38      ; #R$369B: (1/0)
 $386D RET           ; Finished: 'last value' is 0 or 1.

; Unused
s$386E DEFS $0492,$FF ; These locations are 'spare'. They all hold &FF.

; Character set
;
; Used by the routines at #R$0B24 and #R$11B7.
; .
; These locations hold the 'character set'. There are 8-byte representations
; for all the characters with codes &20 (space) to &7F (#CHR169).
@label=CHARSET
b$3D00 DEFB %00000000 ; {#CHAR$3D00
 $3D01 DEFB %00000000 ;
 $3D02 DEFB %00000000 ;
 $3D03 DEFB %00000000 ;
 $3D04 DEFB %00000000 ;
 $3D05 DEFB %00000000 ;
 $3D06 DEFB %00000000 ;
 $3D07 DEFB %00000000 ; }
 $3D08 DEFB %00000000 ; {#CHAR$3D08
 $3D09 DEFB %00010000 ;
 $3D0A DEFB %00010000 ;
 $3D0B DEFB %00010000 ;
 $3D0C DEFB %00010000 ;
 $3D0D DEFB %00000000 ;
 $3D0E DEFB %00010000 ;
 $3D0F DEFB %00000000 ; }
 $3D10 DEFB %00000000 ; {#CHAR$3D10
 $3D11 DEFB %00100100 ;
 $3D12 DEFB %00100100 ;
 $3D13 DEFB %00000000 ;
 $3D14 DEFB %00000000 ;
 $3D15 DEFB %00000000 ;
 $3D16 DEFB %00000000 ;
 $3D17 DEFB %00000000 ; }
 $3D18 DEFB %00000000 ; {#CHAR$3D18
 $3D19 DEFB %00100100 ;
 $3D1A DEFB %01111110 ;
 $3D1B DEFB %00100100 ;
 $3D1C DEFB %00100100 ;
 $3D1D DEFB %01111110 ;
 $3D1E DEFB %00100100 ;
 $3D1F DEFB %00000000 ; }
 $3D20 DEFB %00000000 ; {#CHAR$3D20
 $3D21 DEFB %00001000 ;
 $3D22 DEFB %00111110 ;
 $3D23 DEFB %00101000 ;
 $3D24 DEFB %00111110 ;
 $3D25 DEFB %00001010 ;
 $3D26 DEFB %00111110 ;
 $3D27 DEFB %00001000 ; }
 $3D28 DEFB %00000000 ; {#CHAR$3D28
 $3D29 DEFB %01100010 ;
 $3D2A DEFB %01100100 ;
 $3D2B DEFB %00001000 ;
 $3D2C DEFB %00010000 ;
 $3D2D DEFB %00100110 ;
 $3D2E DEFB %01000110 ;
 $3D2F DEFB %00000000 ; }
 $3D30 DEFB %00000000 ; {#CHAR$3D30
 $3D31 DEFB %00010000 ;
 $3D32 DEFB %00101000 ;
 $3D33 DEFB %00010000 ;
 $3D34 DEFB %00101010 ;
 $3D35 DEFB %01000100 ;
 $3D36 DEFB %00111010 ;
 $3D37 DEFB %00000000 ; }
 $3D38 DEFB %00000000 ; {#CHAR$3D38
 $3D39 DEFB %00001000 ;
 $3D3A DEFB %00010000 ;
 $3D3B DEFB %00000000 ;
 $3D3C DEFB %00000000 ;
 $3D3D DEFB %00000000 ;
 $3D3E DEFB %00000000 ;
 $3D3F DEFB %00000000 ; }
 $3D40 DEFB %00000000 ; {#CHAR$3D40
 $3D41 DEFB %00000100 ;
 $3D42 DEFB %00001000 ;
 $3D43 DEFB %00001000 ;
 $3D44 DEFB %00001000 ;
 $3D45 DEFB %00001000 ;
 $3D46 DEFB %00000100 ;
 $3D47 DEFB %00000000 ; }
 $3D48 DEFB %00000000 ; {#CHAR$3D48
 $3D49 DEFB %00100000 ;
 $3D4A DEFB %00010000 ;
 $3D4B DEFB %00010000 ;
 $3D4C DEFB %00010000 ;
 $3D4D DEFB %00010000 ;
 $3D4E DEFB %00100000 ;
 $3D4F DEFB %00000000 ; }
 $3D50 DEFB %00000000 ; {#CHAR$3D50
 $3D51 DEFB %00000000 ;
 $3D52 DEFB %00010100 ;
 $3D53 DEFB %00001000 ;
 $3D54 DEFB %00111110 ;
 $3D55 DEFB %00001000 ;
 $3D56 DEFB %00010100 ;
 $3D57 DEFB %00000000 ; }
 $3D58 DEFB %00000000 ; {#CHAR$3D58
 $3D59 DEFB %00000000 ;
 $3D5A DEFB %00001000 ;
 $3D5B DEFB %00001000 ;
 $3D5C DEFB %00111110 ;
 $3D5D DEFB %00001000 ;
 $3D5E DEFB %00001000 ;
 $3D5F DEFB %00000000 ; }
 $3D60 DEFB %00000000 ; {#CHAR$3D60
 $3D61 DEFB %00000000 ;
 $3D62 DEFB %00000000 ;
 $3D63 DEFB %00000000 ;
 $3D64 DEFB %00000000 ;
 $3D65 DEFB %00001000 ;
 $3D66 DEFB %00001000 ;
 $3D67 DEFB %00010000 ; }
 $3D68 DEFB %00000000 ; {#CHAR$3D68
 $3D69 DEFB %00000000 ;
 $3D6A DEFB %00000000 ;
 $3D6B DEFB %00000000 ;
 $3D6C DEFB %00111110 ;
 $3D6D DEFB %00000000 ;
 $3D6E DEFB %00000000 ;
 $3D6F DEFB %00000000 ; }
 $3D70 DEFB %00000000 ; {#CHAR$3D70
 $3D71 DEFB %00000000 ;
 $3D72 DEFB %00000000 ;
 $3D73 DEFB %00000000 ;
 $3D74 DEFB %00000000 ;
 $3D75 DEFB %00011000 ;
 $3D76 DEFB %00011000 ;
 $3D77 DEFB %00000000 ; }
 $3D78 DEFB %00000000 ; {#CHAR$3D78
 $3D79 DEFB %00000000 ;
 $3D7A DEFB %00000010 ;
 $3D7B DEFB %00000100 ;
 $3D7C DEFB %00001000 ;
 $3D7D DEFB %00010000 ;
 $3D7E DEFB %00100000 ;
 $3D7F DEFB %00000000 ; }
 $3D80 DEFB %00000000 ; {#CHAR$3D80
 $3D81 DEFB %00111100 ;
 $3D82 DEFB %01000110 ;
 $3D83 DEFB %01001010 ;
 $3D84 DEFB %01010010 ;
 $3D85 DEFB %01100010 ;
 $3D86 DEFB %00111100 ;
 $3D87 DEFB %00000000 ; }
 $3D88 DEFB %00000000 ; {#CHAR$3D88
 $3D89 DEFB %00011000 ;
 $3D8A DEFB %00101000 ;
 $3D8B DEFB %00001000 ;
 $3D8C DEFB %00001000 ;
 $3D8D DEFB %00001000 ;
 $3D8E DEFB %00111110 ;
 $3D8F DEFB %00000000 ; }
 $3D90 DEFB %00000000 ; {#CHAR$3D90
 $3D91 DEFB %00111100 ;
 $3D92 DEFB %01000010 ;
 $3D93 DEFB %00000010 ;
 $3D94 DEFB %00111100 ;
 $3D95 DEFB %01000000 ;
 $3D96 DEFB %01111110 ;
 $3D97 DEFB %00000000 ; }
 $3D98 DEFB %00000000 ; {#CHAR$3D98
 $3D99 DEFB %00111100 ;
 $3D9A DEFB %01000010 ;
 $3D9B DEFB %00001100 ;
 $3D9C DEFB %00000010 ;
 $3D9D DEFB %01000010 ;
 $3D9E DEFB %00111100 ;
 $3D9F DEFB %00000000 ; }
 $3DA0 DEFB %00000000 ; {#CHAR$3DA0
 $3DA1 DEFB %00001000 ;
 $3DA2 DEFB %00011000 ;
 $3DA3 DEFB %00101000 ;
 $3DA4 DEFB %01001000 ;
 $3DA5 DEFB %01111110 ;
 $3DA6 DEFB %00001000 ;
 $3DA7 DEFB %00000000 ; }
 $3DA8 DEFB %00000000 ; {#CHAR$3DA8
 $3DA9 DEFB %01111110 ;
 $3DAA DEFB %01000000 ;
 $3DAB DEFB %01111100 ;
 $3DAC DEFB %00000010 ;
 $3DAD DEFB %01000010 ;
 $3DAE DEFB %00111100 ;
 $3DAF DEFB %00000000 ; }
 $3DB0 DEFB %00000000 ; {#CHAR$3DB0
 $3DB1 DEFB %00111100 ;
 $3DB2 DEFB %01000000 ;
 $3DB3 DEFB %01111100 ;
 $3DB4 DEFB %01000010 ;
 $3DB5 DEFB %01000010 ;
 $3DB6 DEFB %00111100 ;
 $3DB7 DEFB %00000000 ; }
 $3DB8 DEFB %00000000 ; {#CHAR$3DB8
 $3DB9 DEFB %01111110 ;
 $3DBA DEFB %00000010 ;
 $3DBB DEFB %00000100 ;
 $3DBC DEFB %00001000 ;
 $3DBD DEFB %00010000 ;
 $3DBE DEFB %00010000 ;
 $3DBF DEFB %00000000 ; }
 $3DC0 DEFB %00000000 ; {#CHAR$3DC0
 $3DC1 DEFB %00111100 ;
 $3DC2 DEFB %01000010 ;
 $3DC3 DEFB %00111100 ;
 $3DC4 DEFB %01000010 ;
 $3DC5 DEFB %01000010 ;
 $3DC6 DEFB %00111100 ;
 $3DC7 DEFB %00000000 ; }
 $3DC8 DEFB %00000000 ; {#CHAR$3DC8
 $3DC9 DEFB %00111100 ;
 $3DCA DEFB %01000010 ;
 $3DCB DEFB %01000010 ;
 $3DCC DEFB %00111110 ;
 $3DCD DEFB %00000010 ;
 $3DCE DEFB %00111100 ;
 $3DCF DEFB %00000000 ; }
 $3DD0 DEFB %00000000 ; {#CHAR$3DD0
 $3DD1 DEFB %00000000 ;
 $3DD2 DEFB %00000000 ;
 $3DD3 DEFB %00010000 ;
 $3DD4 DEFB %00000000 ;
 $3DD5 DEFB %00000000 ;
 $3DD6 DEFB %00010000 ;
 $3DD7 DEFB %00000000 ; }
 $3DD8 DEFB %00000000 ; {#CHAR$3DD8
 $3DD9 DEFB %00000000 ;
 $3DDA DEFB %00010000 ;
 $3DDB DEFB %00000000 ;
 $3DDC DEFB %00000000 ;
 $3DDD DEFB %00010000 ;
 $3DDE DEFB %00010000 ;
 $3DDF DEFB %00100000 ; }
 $3DE0 DEFB %00000000 ; {#CHAR$3DE0
 $3DE1 DEFB %00000000 ;
 $3DE2 DEFB %00000100 ;
 $3DE3 DEFB %00001000 ;
 $3DE4 DEFB %00010000 ;
 $3DE5 DEFB %00001000 ;
 $3DE6 DEFB %00000100 ;
 $3DE7 DEFB %00000000 ; }
 $3DE8 DEFB %00000000 ; {#CHAR$3DE8
 $3DE9 DEFB %00000000 ;
 $3DEA DEFB %00000000 ;
 $3DEB DEFB %00111110 ;
 $3DEC DEFB %00000000 ;
 $3DED DEFB %00111110 ;
 $3DEE DEFB %00000000 ;
 $3DEF DEFB %00000000 ; }
 $3DF0 DEFB %00000000 ; {#CHAR$3DF0
 $3DF1 DEFB %00000000 ;
 $3DF2 DEFB %00010000 ;
 $3DF3 DEFB %00001000 ;
 $3DF4 DEFB %00000100 ;
 $3DF5 DEFB %00001000 ;
 $3DF6 DEFB %00010000 ;
 $3DF7 DEFB %00000000 ; }
 $3DF8 DEFB %00000000 ; {#CHAR$3DF8
 $3DF9 DEFB %00111100 ;
 $3DFA DEFB %01000010 ;
 $3DFB DEFB %00000100 ;
 $3DFC DEFB %00001000 ;
 $3DFD DEFB %00000000 ;
 $3DFE DEFB %00001000 ;
 $3DFF DEFB %00000000 ; }
 $3E00 DEFB %00000000 ; {#CHAR$3E00
 $3E01 DEFB %00111100 ;
 $3E02 DEFB %01001010 ;
 $3E03 DEFB %01010110 ;
 $3E04 DEFB %01011110 ;
 $3E05 DEFB %01000000 ;
 $3E06 DEFB %00111100 ;
 $3E07 DEFB %00000000 ; }
 $3E08 DEFB %00000000 ; {#CHAR$3E08
 $3E09 DEFB %00111100 ;
 $3E0A DEFB %01000010 ;
 $3E0B DEFB %01000010 ;
 $3E0C DEFB %01111110 ;
 $3E0D DEFB %01000010 ;
 $3E0E DEFB %01000010 ;
 $3E0F DEFB %00000000 ; }
 $3E10 DEFB %00000000 ; {#CHAR$3E10
 $3E11 DEFB %01111100 ;
 $3E12 DEFB %01000010 ;
 $3E13 DEFB %01111100 ;
 $3E14 DEFB %01000010 ;
 $3E15 DEFB %01000010 ;
 $3E16 DEFB %01111100 ;
 $3E17 DEFB %00000000 ; }
 $3E18 DEFB %00000000 ; {#CHAR$3E18
 $3E19 DEFB %00111100 ;
 $3E1A DEFB %01000010 ;
 $3E1B DEFB %01000000 ;
 $3E1C DEFB %01000000 ;
 $3E1D DEFB %01000010 ;
 $3E1E DEFB %00111100 ;
 $3E1F DEFB %00000000 ; }
 $3E20 DEFB %00000000 ; {#CHAR$3E20
 $3E21 DEFB %01111000 ;
 $3E22 DEFB %01000100 ;
 $3E23 DEFB %01000010 ;
 $3E24 DEFB %01000010 ;
 $3E25 DEFB %01000100 ;
 $3E26 DEFB %01111000 ;
 $3E27 DEFB %00000000 ; }
 $3E28 DEFB %00000000 ; {#CHAR$3E28
 $3E29 DEFB %01111110 ;
 $3E2A DEFB %01000000 ;
 $3E2B DEFB %01111100 ;
 $3E2C DEFB %01000000 ;
 $3E2D DEFB %01000000 ;
 $3E2E DEFB %01111110 ;
 $3E2F DEFB %00000000 ; }
 $3E30 DEFB %00000000 ; {#CHAR$3E30
 $3E31 DEFB %01111110 ;
 $3E32 DEFB %01000000 ;
 $3E33 DEFB %01111100 ;
 $3E34 DEFB %01000000 ;
 $3E35 DEFB %01000000 ;
 $3E36 DEFB %01000000 ;
 $3E37 DEFB %00000000 ; }
 $3E38 DEFB %00000000 ; {#CHAR$3E38
 $3E39 DEFB %00111100 ;
 $3E3A DEFB %01000010 ;
 $3E3B DEFB %01000000 ;
 $3E3C DEFB %01001110 ;
 $3E3D DEFB %01000010 ;
 $3E3E DEFB %00111100 ;
 $3E3F DEFB %00000000 ; }
 $3E40 DEFB %00000000 ; {#CHAR$3E40
 $3E41 DEFB %01000010 ;
 $3E42 DEFB %01000010 ;
 $3E43 DEFB %01111110 ;
 $3E44 DEFB %01000010 ;
 $3E45 DEFB %01000010 ;
 $3E46 DEFB %01000010 ;
 $3E47 DEFB %00000000 ; }
 $3E48 DEFB %00000000 ; {#CHAR$3E48
 $3E49 DEFB %00111110 ;
 $3E4A DEFB %00001000 ;
 $3E4B DEFB %00001000 ;
 $3E4C DEFB %00001000 ;
 $3E4D DEFB %00001000 ;
 $3E4E DEFB %00111110 ;
 $3E4F DEFB %00000000 ; }
 $3E50 DEFB %00000000 ; {#CHAR$3E50
 $3E51 DEFB %00000010 ;
 $3E52 DEFB %00000010 ;
 $3E53 DEFB %00000010 ;
 $3E54 DEFB %01000010 ;
 $3E55 DEFB %01000010 ;
 $3E56 DEFB %00111100 ;
 $3E57 DEFB %00000000 ; }
 $3E58 DEFB %00000000 ; {#CHAR$3E58
 $3E59 DEFB %01000100 ;
 $3E5A DEFB %01001000 ;
 $3E5B DEFB %01110000 ;
 $3E5C DEFB %01001000 ;
 $3E5D DEFB %01000100 ;
 $3E5E DEFB %01000010 ;
 $3E5F DEFB %00000000 ; }
 $3E60 DEFB %00000000 ; {#CHAR$3E60
 $3E61 DEFB %01000000 ;
 $3E62 DEFB %01000000 ;
 $3E63 DEFB %01000000 ;
 $3E64 DEFB %01000000 ;
 $3E65 DEFB %01000000 ;
 $3E66 DEFB %01111110 ;
 $3E67 DEFB %00000000 ; }
 $3E68 DEFB %00000000 ; {#CHAR$3E68
 $3E69 DEFB %01000010 ;
 $3E6A DEFB %01100110 ;
 $3E6B DEFB %01011010 ;
 $3E6C DEFB %01000010 ;
 $3E6D DEFB %01000010 ;
 $3E6E DEFB %01000010 ;
 $3E6F DEFB %00000000 ; }
 $3E70 DEFB %00000000 ; {#CHAR$3E70
 $3E71 DEFB %01000010 ;
 $3E72 DEFB %01100010 ;
 $3E73 DEFB %01010010 ;
 $3E74 DEFB %01001010 ;
 $3E75 DEFB %01000110 ;
 $3E76 DEFB %01000010 ;
 $3E77 DEFB %00000000 ; }
 $3E78 DEFB %00000000 ; {#CHAR$3E78
 $3E79 DEFB %00111100 ;
 $3E7A DEFB %01000010 ;
 $3E7B DEFB %01000010 ;
 $3E7C DEFB %01000010 ;
 $3E7D DEFB %01000010 ;
 $3E7E DEFB %00111100 ;
 $3E7F DEFB %00000000 ; }
 $3E80 DEFB %00000000 ; {#CHAR$3E80
 $3E81 DEFB %01111100 ;
 $3E82 DEFB %01000010 ;
 $3E83 DEFB %01000010 ;
 $3E84 DEFB %01111100 ;
 $3E85 DEFB %01000000 ;
 $3E86 DEFB %01000000 ;
 $3E87 DEFB %00000000 ; }
 $3E88 DEFB %00000000 ; {#CHAR$3E88
 $3E89 DEFB %00111100 ;
 $3E8A DEFB %01000010 ;
 $3E8B DEFB %01000010 ;
 $3E8C DEFB %01010010 ;
 $3E8D DEFB %01001010 ;
 $3E8E DEFB %00111100 ;
 $3E8F DEFB %00000000 ; }
 $3E90 DEFB %00000000 ; {#CHAR$3E90
 $3E91 DEFB %01111100 ;
 $3E92 DEFB %01000010 ;
 $3E93 DEFB %01000010 ;
 $3E94 DEFB %01111100 ;
 $3E95 DEFB %01000100 ;
 $3E96 DEFB %01000010 ;
 $3E97 DEFB %00000000 ; }
 $3E98 DEFB %00000000 ; {#CHAR$3E98
 $3E99 DEFB %00111100 ;
 $3E9A DEFB %01000000 ;
 $3E9B DEFB %00111100 ;
 $3E9C DEFB %00000010 ;
 $3E9D DEFB %01000010 ;
 $3E9E DEFB %00111100 ;
 $3E9F DEFB %00000000 ; }
 $3EA0 DEFB %00000000 ; {#CHAR$3EA0
 $3EA1 DEFB %11111110 ;
 $3EA2 DEFB %00010000 ;
 $3EA3 DEFB %00010000 ;
 $3EA4 DEFB %00010000 ;
 $3EA5 DEFB %00010000 ;
 $3EA6 DEFB %00010000 ;
 $3EA7 DEFB %00000000 ; }
 $3EA8 DEFB %00000000 ; {#CHAR$3EA8
 $3EA9 DEFB %01000010 ;
 $3EAA DEFB %01000010 ;
 $3EAB DEFB %01000010 ;
 $3EAC DEFB %01000010 ;
 $3EAD DEFB %01000010 ;
 $3EAE DEFB %00111100 ;
 $3EAF DEFB %00000000 ; }
 $3EB0 DEFB %00000000 ; {#CHAR$3EB0
 $3EB1 DEFB %01000010 ;
 $3EB2 DEFB %01000010 ;
 $3EB3 DEFB %01000010 ;
 $3EB4 DEFB %01000010 ;
 $3EB5 DEFB %00100100 ;
 $3EB6 DEFB %00011000 ;
 $3EB7 DEFB %00000000 ; }
 $3EB8 DEFB %00000000 ; {#CHAR$3EB8
 $3EB9 DEFB %01000010 ;
 $3EBA DEFB %01000010 ;
 $3EBB DEFB %01000010 ;
 $3EBC DEFB %01000010 ;
 $3EBD DEFB %01011010 ;
 $3EBE DEFB %00100100 ;
 $3EBF DEFB %00000000 ; }
 $3EC0 DEFB %00000000 ; {#CHAR$3EC0
 $3EC1 DEFB %01000010 ;
 $3EC2 DEFB %00100100 ;
 $3EC3 DEFB %00011000 ;
 $3EC4 DEFB %00011000 ;
 $3EC5 DEFB %00100100 ;
 $3EC6 DEFB %01000010 ;
 $3EC7 DEFB %00000000 ; }
 $3EC8 DEFB %00000000 ; {#CHAR$3EC8
 $3EC9 DEFB %10000010 ;
 $3ECA DEFB %01000100 ;
 $3ECB DEFB %00101000 ;
 $3ECC DEFB %00010000 ;
 $3ECD DEFB %00010000 ;
 $3ECE DEFB %00010000 ;
 $3ECF DEFB %00000000 ; }
 $3ED0 DEFB %00000000 ; {#CHAR$3ED0
 $3ED1 DEFB %01111110 ;
 $3ED2 DEFB %00000100 ;
 $3ED3 DEFB %00001000 ;
 $3ED4 DEFB %00010000 ;
 $3ED5 DEFB %00100000 ;
 $3ED6 DEFB %01111110 ;
 $3ED7 DEFB %00000000 ; }
 $3ED8 DEFB %00000000 ; {#CHAR$3ED8
 $3ED9 DEFB %00001110 ;
 $3EDA DEFB %00001000 ;
 $3EDB DEFB %00001000 ;
 $3EDC DEFB %00001000 ;
 $3EDD DEFB %00001000 ;
 $3EDE DEFB %00001110 ;
 $3EDF DEFB %00000000 ; }
 $3EE0 DEFB %00000000 ; {#CHAR$3EE0
 $3EE1 DEFB %00000000 ;
 $3EE2 DEFB %01000000 ;
 $3EE3 DEFB %00100000 ;
 $3EE4 DEFB %00010000 ;
 $3EE5 DEFB %00001000 ;
 $3EE6 DEFB %00000100 ;
 $3EE7 DEFB %00000000 ; }
 $3EE8 DEFB %00000000 ; {#CHAR$3EE8
 $3EE9 DEFB %01110000 ;
 $3EEA DEFB %00010000 ;
 $3EEB DEFB %00010000 ;
 $3EEC DEFB %00010000 ;
 $3EED DEFB %00010000 ;
 $3EEE DEFB %01110000 ;
 $3EEF DEFB %00000000 ; }
 $3EF0 DEFB %00000000 ; {#CHAR$3EF0
 $3EF1 DEFB %00010000 ;
 $3EF2 DEFB %00111000 ;
 $3EF3 DEFB %01010100 ;
 $3EF4 DEFB %00010000 ;
 $3EF5 DEFB %00010000 ;
 $3EF6 DEFB %00010000 ;
 $3EF7 DEFB %00000000 ; }
 $3EF8 DEFB %00000000 ; {#CHAR$3EF8
 $3EF9 DEFB %00000000 ;
 $3EFA DEFB %00000000 ;
 $3EFB DEFB %00000000 ;
 $3EFC DEFB %00000000 ;
 $3EFD DEFB %00000000 ;
 $3EFE DEFB %00000000 ;
 $3EFF DEFB %11111111 ; }
 $3F00 DEFB %00000000 ; {#CHAR$3F00
 $3F01 DEFB %00011100 ;
 $3F02 DEFB %00100010 ;
 $3F03 DEFB %01111000 ;
 $3F04 DEFB %00100000 ;
 $3F05 DEFB %00100000 ;
 $3F06 DEFB %01111110 ;
 $3F07 DEFB %00000000 ; }
 $3F08 DEFB %00000000 ; {#CHAR$3F08
 $3F09 DEFB %00000000 ;
 $3F0A DEFB %00111000 ;
 $3F0B DEFB %00000100 ;
 $3F0C DEFB %00111100 ;
 $3F0D DEFB %01000100 ;
 $3F0E DEFB %00111100 ;
 $3F0F DEFB %00000000 ; }
 $3F10 DEFB %00000000 ; {#CHAR$3F10
 $3F11 DEFB %00100000 ;
 $3F12 DEFB %00100000 ;
 $3F13 DEFB %00111100 ;
 $3F14 DEFB %00100010 ;
 $3F15 DEFB %00100010 ;
 $3F16 DEFB %00111100 ;
 $3F17 DEFB %00000000 ; }
 $3F18 DEFB %00000000 ; {#CHAR$3F18
 $3F19 DEFB %00000000 ;
 $3F1A DEFB %00011100 ;
 $3F1B DEFB %00100000 ;
 $3F1C DEFB %00100000 ;
 $3F1D DEFB %00100000 ;
 $3F1E DEFB %00011100 ;
 $3F1F DEFB %00000000 ; }
 $3F20 DEFB %00000000 ; {#CHAR$3F20
 $3F21 DEFB %00000100 ;
 $3F22 DEFB %00000100 ;
 $3F23 DEFB %00111100 ;
 $3F24 DEFB %01000100 ;
 $3F25 DEFB %01000100 ;
 $3F26 DEFB %00111100 ;
 $3F27 DEFB %00000000 ; }
 $3F28 DEFB %00000000 ; {#CHAR$3F28
 $3F29 DEFB %00000000 ;
 $3F2A DEFB %00111000 ;
 $3F2B DEFB %01000100 ;
 $3F2C DEFB %01111000 ;
 $3F2D DEFB %01000000 ;
 $3F2E DEFB %00111100 ;
 $3F2F DEFB %00000000 ; }
 $3F30 DEFB %00000000 ; {#CHAR$3F30
 $3F31 DEFB %00001100 ;
 $3F32 DEFB %00010000 ;
 $3F33 DEFB %00011000 ;
 $3F34 DEFB %00010000 ;
 $3F35 DEFB %00010000 ;
 $3F36 DEFB %00010000 ;
 $3F37 DEFB %00000000 ; }
 $3F38 DEFB %00000000 ; {#CHAR$3F38
 $3F39 DEFB %00000000 ;
 $3F3A DEFB %00111100 ;
 $3F3B DEFB %01000100 ;
 $3F3C DEFB %01000100 ;
 $3F3D DEFB %00111100 ;
 $3F3E DEFB %00000100 ;
 $3F3F DEFB %00111000 ; }
 $3F40 DEFB %00000000 ; {#CHAR$3F40
 $3F41 DEFB %01000000 ;
 $3F42 DEFB %01000000 ;
 $3F43 DEFB %01111000 ;
 $3F44 DEFB %01000100 ;
 $3F45 DEFB %01000100 ;
 $3F46 DEFB %01000100 ;
 $3F47 DEFB %00000000 ; }
 $3F48 DEFB %00000000 ; {#CHAR$3F48
 $3F49 DEFB %00010000 ;
 $3F4A DEFB %00000000 ;
 $3F4B DEFB %00110000 ;
 $3F4C DEFB %00010000 ;
 $3F4D DEFB %00010000 ;
 $3F4E DEFB %00111000 ;
 $3F4F DEFB %00000000 ; }
 $3F50 DEFB %00000000 ; {#CHAR$3F50
 $3F51 DEFB %00000100 ;
 $3F52 DEFB %00000000 ;
 $3F53 DEFB %00000100 ;
 $3F54 DEFB %00000100 ;
 $3F55 DEFB %00000100 ;
 $3F56 DEFB %00100100 ;
 $3F57 DEFB %00011000 ; }
 $3F58 DEFB %00000000 ; {#CHAR$3F58
 $3F59 DEFB %00100000 ;
 $3F5A DEFB %00101000 ;
 $3F5B DEFB %00110000 ;
 $3F5C DEFB %00110000 ;
 $3F5D DEFB %00101000 ;
 $3F5E DEFB %00100100 ;
 $3F5F DEFB %00000000 ; }
 $3F60 DEFB %00000000 ; {#CHAR$3F60
 $3F61 DEFB %00010000 ;
 $3F62 DEFB %00010000 ;
 $3F63 DEFB %00010000 ;
 $3F64 DEFB %00010000 ;
 $3F65 DEFB %00010000 ;
 $3F66 DEFB %00001100 ;
 $3F67 DEFB %00000000 ; }
 $3F68 DEFB %00000000 ; {#CHAR$3F68
 $3F69 DEFB %00000000 ;
 $3F6A DEFB %01101000 ;
 $3F6B DEFB %01010100 ;
 $3F6C DEFB %01010100 ;
 $3F6D DEFB %01010100 ;
 $3F6E DEFB %01010100 ;
 $3F6F DEFB %00000000 ; }
 $3F70 DEFB %00000000 ; {#CHAR$3F70
 $3F71 DEFB %00000000 ;
 $3F72 DEFB %01111000 ;
 $3F73 DEFB %01000100 ;
 $3F74 DEFB %01000100 ;
 $3F75 DEFB %01000100 ;
 $3F76 DEFB %01000100 ;
 $3F77 DEFB %00000000 ; }
 $3F78 DEFB %00000000 ; {#CHAR$3F78
 $3F79 DEFB %00000000 ;
 $3F7A DEFB %00111000 ;
 $3F7B DEFB %01000100 ;
 $3F7C DEFB %01000100 ;
 $3F7D DEFB %01000100 ;
 $3F7E DEFB %00111000 ;
 $3F7F DEFB %00000000 ; }
 $3F80 DEFB %00000000 ; {#CHAR$3F80
 $3F81 DEFB %00000000 ;
 $3F82 DEFB %01111000 ;
 $3F83 DEFB %01000100 ;
 $3F84 DEFB %01000100 ;
 $3F85 DEFB %01111000 ;
 $3F86 DEFB %01000000 ;
 $3F87 DEFB %01000000 ; }
 $3F88 DEFB %00000000 ; {#CHAR$3F88
 $3F89 DEFB %00000000 ;
 $3F8A DEFB %00111100 ;
 $3F8B DEFB %01000100 ;
 $3F8C DEFB %01000100 ;
 $3F8D DEFB %00111100 ;
 $3F8E DEFB %00000100 ;
 $3F8F DEFB %00000110 ; }
 $3F90 DEFB %00000000 ; {#CHAR$3F90
 $3F91 DEFB %00000000 ;
 $3F92 DEFB %00011100 ;
 $3F93 DEFB %00100000 ;
 $3F94 DEFB %00100000 ;
 $3F95 DEFB %00100000 ;
 $3F96 DEFB %00100000 ;
 $3F97 DEFB %00000000 ; }
 $3F98 DEFB %00000000 ; {#CHAR$3F98
 $3F99 DEFB %00000000 ;
 $3F9A DEFB %00111000 ;
 $3F9B DEFB %01000000 ;
 $3F9C DEFB %00111000 ;
 $3F9D DEFB %00000100 ;
 $3F9E DEFB %01111000 ;
 $3F9F DEFB %00000000 ; }
 $3FA0 DEFB %00000000 ; {#CHAR$3FA0
 $3FA1 DEFB %00010000 ;
 $3FA2 DEFB %00111000 ;
 $3FA3 DEFB %00010000 ;
 $3FA4 DEFB %00010000 ;
 $3FA5 DEFB %00010000 ;
 $3FA6 DEFB %00001100 ;
 $3FA7 DEFB %00000000 ; }
 $3FA8 DEFB %00000000 ; {#CHAR$3FA8
 $3FA9 DEFB %00000000 ;
 $3FAA DEFB %01000100 ;
 $3FAB DEFB %01000100 ;
 $3FAC DEFB %01000100 ;
 $3FAD DEFB %01000100 ;
 $3FAE DEFB %00111000 ;
 $3FAF DEFB %00000000 ; }
 $3FB0 DEFB %00000000 ; {#CHAR$3FB0
 $3FB1 DEFB %00000000 ;
 $3FB2 DEFB %01000100 ;
 $3FB3 DEFB %01000100 ;
 $3FB4 DEFB %00101000 ;
 $3FB5 DEFB %00101000 ;
 $3FB6 DEFB %00010000 ;
 $3FB7 DEFB %00000000 ; }
 $3FB8 DEFB %00000000 ; {#CHAR$3FB8
 $3FB9 DEFB %00000000 ;
 $3FBA DEFB %01000100 ;
 $3FBB DEFB %01010100 ;
 $3FBC DEFB %01010100 ;
 $3FBD DEFB %01010100 ;
 $3FBE DEFB %00101000 ;
 $3FBF DEFB %00000000 ; }
 $3FC0 DEFB %00000000 ; {#CHAR$3FC0
 $3FC1 DEFB %00000000 ;
 $3FC2 DEFB %01000100 ;
 $3FC3 DEFB %00101000 ;
 $3FC4 DEFB %00010000 ;
 $3FC5 DEFB %00101000 ;
 $3FC6 DEFB %01000100 ;
 $3FC7 DEFB %00000000 ; }
 $3FC8 DEFB %00000000 ; {#CHAR$3FC8
 $3FC9 DEFB %00000000 ;
 $3FCA DEFB %01000100 ;
 $3FCB DEFB %01000100 ;
 $3FCC DEFB %01000100 ;
 $3FCD DEFB %00111100 ;
 $3FCE DEFB %00000100 ;
 $3FCF DEFB %00111000 ; }
 $3FD0 DEFB %00000000 ; {#CHAR$3FD0
 $3FD1 DEFB %00000000 ;
 $3FD2 DEFB %01111100 ;
 $3FD3 DEFB %00001000 ;
 $3FD4 DEFB %00010000 ;
 $3FD5 DEFB %00100000 ;
 $3FD6 DEFB %01111100 ;
 $3FD7 DEFB %00000000 ; }
 $3FD8 DEFB %00000000 ; {#CHAR$3FD8
 $3FD9 DEFB %00001110 ;
 $3FDA DEFB %00001000 ;
 $3FDB DEFB %00110000 ;
 $3FDC DEFB %00001000 ;
 $3FDD DEFB %00001000 ;
 $3FDE DEFB %00001110 ;
 $3FDF DEFB %00000000 ; }
 $3FE0 DEFB %00000000 ; {#CHAR$3FE0
 $3FE1 DEFB %00001000 ;
 $3FE2 DEFB %00001000 ;
 $3FE3 DEFB %00001000 ;
 $3FE4 DEFB %00001000 ;
 $3FE5 DEFB %00001000 ;
 $3FE6 DEFB %00001000 ;
 $3FE7 DEFB %00000000 ; }
 $3FE8 DEFB %00000000 ; {#CHAR$3FE8
 $3FE9 DEFB %01110000 ;
 $3FEA DEFB %00010000 ;
 $3FEB DEFB %00001100 ;
 $3FEC DEFB %00010000 ;
 $3FED DEFB %00010000 ;
 $3FEE DEFB %01110000 ;
 $3FEF DEFB %00000000 ; }
 $3FF0 DEFB %00000000 ; {#CHAR$3FF0
 $3FF1 DEFB %00010100 ;
 $3FF2 DEFB %00101000 ;
 $3FF3 DEFB %00000000 ;
 $3FF4 DEFB %00000000 ;
 $3FF5 DEFB %00000000 ;
 $3FF6 DEFB %00000000 ;
 $3FF7 DEFB %00000000 ; }
 $3FF8 DEFB %00111100 ; {#CHAR$3FF8
 $3FF9 DEFB %01000010 ;
 $3FFA DEFB %10011001 ;
 $3FFB DEFB %10100001 ;
 $3FFC DEFB %10100001 ;
 $3FFD DEFB %10011001 ;
 $3FFE DEFB %01000010 ;
 $3FFF DEFB %00111100 ; }

@end
@assemble=0
i$4000 DEFS $1C00

; KSTATE - Used in reading the keyboard
;
; Initialised by the routine at #R$11B7, and used by the routine at #R$02BF.
; KSTATE0 (#h5C00) and KSTATE4 (#h5C04) are accessed by the routine at #R$11B7
; via the #REGiy register at #iy-$3A and #iy-$36.
; .
; There are two sets of four bytes here, each set corresponding to a separate
; keypress. The bytes in each set are used as follows:
; .
; #TABLE(default,centre,:w)
; { =h Byte | =h Contents }
; { 0 | &FF if the set is unused, or a main code from the #R$0205#$0205(main
; key table) otherwise }
; { 1 | Call counter; initially &05, and decremented on each call to #R$02BF }
; { 2 | Repeat delay counter; initially #SYSVAR(REPDEL), decremented on each
; call to #R$02BF, reset to #SYSVAR(REPPER) whenever it reaches zero }
; { 3 | Final code from the #R$0205(key tables) (as computed by #R$0333) }
; TABLE#
@label=KSTATE
g$5C00 DEFB $FF,$00,$00,$00
 $5C04 DEFB $FF,$00,$00,$00

; LAST-K - Last key pressed
;
; Read by the routine at #R$10A8, and updated by the routine at #R$02BF.
@label=LAST_K
g$5C08 DEFB $00

; REPDEL - Time that a key must be held down before it repeats
;
; Initialised by the routine at #R$11B7, and read by the routine at #R$02BF.
@label=REPDEL
g$5C09 DEFB $23

; REPPER - Delay between successive repeats of a key held down
;
; Initialised by the routine at #R$11B7, and read by the routine at #R$02BF.
@label=REPPER
g$5C0A DEFB $05

; DEFADD - Address of arguments of user defined function
;
; Read by the routines at #R$28B2 and #R$2951, and updated by the routines at
; #R$12A2 and #R$27BD.
@label=DEFADD
@keep
g$5C0B DEFW $0000

; K-DATA - Second byte of colour controls entered from keyboard
;
; Used by the routine at #R$10A8 (by direct addressing and also via the #REGiy
; register at #iy-$2D).
@label=K_DATA
g$5C0D DEFB $00

; TVDATA - Colour, AT and TAB controls going to television
;
; Used by the routine at #R$0A6D. When a control character (codes &10 to &17)
; and its operand(s) are being processed, these two bytes are used as temporary
; storage for the character code and its first operand.
@label=TVDATA
g$5C0E DEFB $00,$00

; STRMS - Addresses of channels attached to streams
;
; Initialised by the routine at #R$11B7 (from the #R$15C6(initial stream data)
; table), and read by the routines at #R$1601 and #R$171E. Each of these values
; is an offset that is added to the base address of the channel data (stored at
; #SYSVAR(CHANS)) to find the corresponding entry in the channel information
; table (#SYSVAR(CHINFO)).
@label=STRMS
@keep
g$5C10 DEFW $0001    ; Stream &FD (keyboard).
@keep
 $5C12 DEFW $0006    ; Stream &FE (screen).
@keep
 $5C14 DEFW $000B    ; Stream &FF (work space).
@keep
 $5C16 DEFW $0001    ; Stream &00 (keyboard).
@keep
 $5C18 DEFW $0001    ; Stream &01 (keyboard).
@keep
 $5C1A DEFW $0006    ; Stream &02 (screen).
@keep
 $5C1C DEFW $0010    ; Stream &03 (printer).
@keep
 $5C1E DEFW $0000    ; Stream &04.
@keep
 $5C20 DEFW $0000    ; Stream &05.
@keep
 $5C22 DEFW $0000    ; Stream &06.
@keep
 $5C24 DEFW $0000    ; Stream &07.
@keep
 $5C26 DEFW $0000    ; Stream &08.
@keep
 $5C28 DEFW $0000    ; Stream &09.
@keep
 $5C2A DEFW $0000    ; Stream &0A.
@keep
 $5C2C DEFW $0000    ; Stream &0B.
@keep
 $5C2E DEFW $0000    ; Stream &0C.
@keep
 $5C30 DEFW $0000    ; Stream &0D.
@keep
 $5C32 DEFW $0000    ; Stream &0E.
@keep
 $5C34 DEFW $0000    ; Stream &0F.

; CHARS - 256 less than address of character set
;
; Initialised by the routine at #R$11B7, and read by the routines at #R$0B24
; and #R$2535.
@label=CHARS
@keep
g$5C36 DEFW $3C00

; RASP - Length of warning buzz
;
; Initialised by the routine at #R$11B7, and read by the routines at #R$107F
; and #R$111D. This system variable is accessed by some routines via the #REGiy
; register at #iy-$02.
@label=RASP
g$5C38 DEFB $40

; PIP - Length of keyboard click
;
; Initialised by the routine at #R$11B7, and read by the routine at #R$0F2C
; (via the #REGiy register at #iy-$01).
@label=PIP
g$5C39 DEFB $00

; ERR-NR - One less than the error report code
;
; Read by the routine at #R$1024, and updated by the routines at #R$0053,
; #R$0FF3, #R$107F, #R$111D, #R$12A2, #R$1B17 and #R$2089. The #REGiy register
; is initialised to #h5C3A by the routine at #R$11B7, and reinitialised by the
; routine at #R$2D2B. This system variable is accessed by some routines via the
; #REGiy register at #iy+$00.
@label=ERR_NR
g$5C3A DEFB $00

; FLAGS - Various flags to control the BASIC system
;
; Initialised by the routine at #R$11B7, read by the routines at #R$04AA,
; #R$0A23, #R$0A4F, #R$0ADC, #R$0B03, #R$0C0A, #R$0DD9, #R$1C22, #R$1C56,
; #R$1C79, #R$1C96, #R$1F60, #R$1FFC, #R$2089, #R$2530, #R$26C9 and #R$2AFF,
; and updated by the routines at #R$02BF, #R$0A6D, #R$0B24, #R$0C55, #R$10A8,
; #R$12A2, #R$1634, #R$1642, #R$164D, #R$1855, #R$18E1, #R$1925, #R$1B17,
; #R$1F3A, #R$25B3, #R$2634, #R$268D, #R$27BD, #R$28B2, #R$2996, #R$2A52,
; #R$2AB and #R$35DE. This system variable is accessed by some routines via the
; #REGiy register at #iy+$01.
; .
; #TABLE(default,centre)
; { =h Bit | =h Description }
; { 0      | Leading space flag (set to suppress leading space) }
; { 1      | Printer flag (set when printer in use) }
; { 2      | Printer mode: K (reset) or L (set) }
; { 3      | Keyboard mode: K (reset) or L (set) }
; { 4      | Unused }
; { 5      | Set when a new key has been pressed }
; { 6      | Variable type flag: string (reset) or numeric (set) }
; { 7      | Reset when checking syntax, set during execution }
; TABLE#
@label=FLAGS
g$5C3B DEFB $00

; TV-FLAG - Flags associated with the television
;
; Initialised by the routine at #R$11B7, read by the routines at #R$0A6D,
; #R$0ADC, #R$0B03, #R$0D4D, #R$0DD9 and #R$0E44, and updated by the routines
; at #R$0970, #R$0C55, #R$0D6B, #R$10A8, #R$111D, #R$12A2, #R$15D4, #R$1634,
; #R$1642, #R$1795, #R$17F9, #R$1C96, #R$1CBE and #R$2089. This system variable
; is accessed by some routines via the #REGiy register at #iy+$02.
; .
; #TABLE(default,centre)
; { =h Bit | =h Description }
; { 0      | Set when printing to the lower screen }
; { 1      | Unused }
; { 2      | Unused }
; { 3      | Set when the input mode has changed }
; { 4      | Set when an automatic listing is being produced }
; { 5      | Set when the lower screen needs clearing }
; { 6      | Unused }
; { 7      | Unused }
; TABLE#
@label=TV_FLAG
g$5C3C DEFB $00

; ERR-SP - Address of item on machine stack to use as error return
;
; Initialised by the routine at #R$11B7, read by the routine at #R$0053, and
; updated by the routines at #R$0F2C, #R$1024, #R$111D, #R$1EAC, #R$1EED,
; #R$1F23 and #R$2089.
@label=ERR_SP
@keep
g$5C3D DEFW $FF54

; LIST-SP - Return address from automatic listing
;
; Read by the routine at #R$0C55, and updated by the routine at #R$1795.
@label=LIST_SP
@keep
g$5C3F DEFW $0000

; MODE - Specifies K, L, C, E or G cursor
;
; Read by the routines at #R$02BF and #R$18E1, and updated by the routines at
; #R$0F2C, #R$1097 and #R$10A8. This system variable is accessed by some
; routines via the #REGiy register at #iy+$07. It holds one of the following
; values:
; .
; #TABLE(default,centre)
; { =h Value | =h Cursor }
; { 0 | C, K or L }
; { 1 | E }
; { 2 | G }
; TABLE#
@label=MODE
g$5C41 DEFB $00

; NEWPPC - Line to be jumped to
;
; Read by the routine at #R$1B76, and updated by the routines at #R$0808,
; #R$1D03, #R$1D86 and #R$1E67.
@label=NEWPPC
@keep
g$5C42 DEFW $0000

; NSPPC - Statement number in line to be jumped to
;
; Read by the routines at #R$1B76, #R$1B8A and #R$1B9E, and updated by the
; routines at #R$0808, #R$12A2, #R$1BD1, #R$1D03 and #R$1E67. This system
; variable is accessed by some routines via the #REGiy register at #iy+$0A.
@label=NSPPC
g$5C44 DEFB $00

; PPC - Line number of statement being executed
;
; Read by the routines at #R$12A2, #R$1D03 and #R$1EED, and updated by the
; routines at #R$1B8A and #R$1BBF.
@label=PPC
@keep
g$5C45 DEFW $0000

; SUBPPC - Number within line of statement being executed
;
; Read by the routines at #R$1D03 and #R$1EED, and updated by the routines at
; #R$12A2, #R$1B17, #R$1B28 and #R$1BD1. This system variable is accessed by
; some routines via the #REGiy register at #iy+$0D.
@label=SUBPPC
g$5C47 DEFB $00

; BORDCR - Border colour
;
; Initialised by the routine at #R$11B7, read by the routines at #R$03B5,
; #R$053F, #R$0D4D (via the #REGiy register at #iy+$0E) and #R$0E44, and
; updated by the routine at #R$2294. The border colour (0-7) is stored in bits
; 3-5.
@label=BORDCR
g$5C48 DEFB $38

; E-PPC - Number of current line
;
; Read by the routines at #R$0FF3, #R$1059, #R$1795 and #R$1855, and updated by
; the routines at #R$0FA9, #R$155D and #R$17F9. The first byte of this system
; variable (the LSB) is accessed by the routine at #R$0FA9 via the #REGiy
; register at #iy+$0F.
@label=E_PPC
@keep
g$5C49 DEFW $0000

; VARS - Address of variables
;
; Initialised by the routine at #R$11B7, read by the routines at #R$0605,
; #R$08B6, #R$1EAC and #R$28B2, and updated by the routines at #R$0808 and
; #R$1664.
@label=VARS
@keep
g$5C4B DEFW $5CCB

; DEST - Address of variable in assignment
;
; Read by the routine at #R$1DAB, and updated by the routines at #R$1664,
; #R$1C22 and #R$2AFF.
@label=DEST
@keep
g$5C4D DEFW $0000

; CHANS - Address of channel data
;
; Initialised by the routine at #R$11B7, read by the routines at #R$10A8,
; #R$1601, #R$1701 and #R$1736, and updated by the routine at #R$1664.
@label=CHANS
g$5C4F DEFW $5CB6

; CURCHL - Address of information used for input and output
;
; Read by the routines at #R$0A6D, #R$0D6B, #R$0DAF, #R$0FA9, #R$15E6, #R$15EF,
; #R$21D6, #R$361F and #R$3645, and updated by the routines at #R$1615 and
; #R$1664.
@label=CURCHL
@keep
g$5C51 DEFW $0000

; PROG - Address of BASIC program
;
; Initialised by the routine at #R$11B7, read by the routines at #R$0605,
; #R$08B6, #R$196E and #R$27BD, and updated by the routines at #R$092C, #R$155D
; and #R$1664.
@label=PROG
@keep
g$5C53 DEFW $5CCB

; NXTLIN - Address of next line in program
;
; Read by the routine at #R$1BB3, and updated by the routines at #R$1664,
; #R$1BD1 and #R$1D03.
@label=NXTLIN
@keep
g$5C55 DEFW $0000

; DATADD - Address of terminator of last DATA item
;
; Initialised by the routine at #R$11B7, used by the routine at #R$1DEC, and
; updated by the routines at #R$1664 and #R$1E42.
@label=DATADD
@keep
g$5C57 DEFW $5CCA

; E-LINE - Address of command being typed in
;
; Initialised by the routine at #R$11B7, read by the routines at #R$0605,
; #R$0808, #R$0FA9, #R$1190, #R$12A2, #R$16B0, #R$19FB, #R$1B8A, #R$1EAC,
; #R$2AFF and #R$2C02, and updated by the routine at #R$1664.
@label=E_LINE
@keep
g$5C59 DEFW $5CCC

; K-CUR - Address of cursor
;
; Read by the routine at #R$18E1, and updated by the routines at #R$0F2C,
; #R$0FA9, #R$100C, #R$1097, #R$1664, #R$16B0, #R$2089 and #R$361F. The second
; byte of this system variable is accessed by the routine at #R$2089 via the
; #REGiy register at #iy+$22.
@label=K_CUR
@keep
g$5C5B DEFW $0000

; CH-ADD - Address of the next character to be interpreted
;
; Initialised by the routine at #R$12A2, read by the routines at #R$0008,
; #R$0018, #R$155D and #R$1D03, and updated by the routines at #R$0074,
; #R$007D, #R$1664, #R$198B, #R$19FB, #R$1BD1, #R$2089, #R$21B9, #R$268D,
; #R$27BD, #R$2996 and #R$35DE.
@label=CH_ADD
@keep
g$5C5D DEFW $0000

; X-PTR - Address of the character after the '?' marker
;
; Read by the routine at #R$1855, and updated by the routines at #R$0008,
; #R$0808, #R$092C, #R$111D, #R$12A2, #R$1664, #R$1DEC and #R$2089. The second
; byte of this system variable is accessed by some routines via the #REGiy
; register at #iy+$26.
@label=X_PTR
@keep
g$5C5F DEFW $0000

; WORKSP - Address of temporary work space
;
; Initialised by the routine at #R$11B7, read by the routines at #R$0030,
; #R$1190, #R$155D, #R$1B8A, #R$2089 and #R$21B9, and updated by the routines
; at #R$1664, #R$169E and #R$16B0.
@label=WORKSP
@keep
g$5C61 DEFW $5CCE

; STKBOT - Address of bottom of calculator stack
;
; Initialised by the routine at #R$11B7, read by the routines at #R$1190,
; #R$169E and #R$2089, and updated by the routines at #R$1664 and #R$16B0.
@label=STKBOT
@keep
g$5C63 DEFW $5CCE

; STKEND - Address of start of spare space
;
; Initialised by the routine at #R$11B7, read by the routines at #R$1652,
; #R$1EAC, #R$1F05 and #R$35BF, and updated by the routines at #R$1664,
; #R$16B0, #R$19FB, #R$268D, #R$27BD, #R$2951, #R$2AB1, #R$2BF1, #R$335B and
; #R$33B4.
@label=STKEND
@keep
g$5C65 DEFW $5CCE

; BREG - Calculator's B register
;
; Read by the routines at #R$0C55 and #R$33A2, and updated by the routines at
; #R$1855, #R$335B and #R$367A. This system variable is accessed by some
; routines via the #REGiy register at #iy+$2D.
@label=BREG
g$5C67 DEFB $00

; MEM - Address of area used for calculator's memory
;
; Read by the routines at #R$340F and #R$342D, and updated by the routines at
; #R$16B0, #R$1D03 and #R$1DAB.
@label=MEM
@keep
g$5C68 DEFW $0000

; FLAGS2 - More flags
;
; Read by the routines at #R$0333, #R$107F, #R$12A2, #R$18E1, #R$1925 and
; #R$2089, and updated by the routines at #R$0B24, #R$0DAF, #R$0EDF, #R$10A8,
; #R$1615, #R$1634, #R$1795 and #R$1855. This system variable is accessed by
; most routines via the #REGiy register at #iy+$30.
; .
; #TABLE(default,centre)
; { =h Bit | =h Description }
; { 0      | Reset when the screen is clear }
; { 1      | Set when the printer buffer is in use }
; { 2      | Set when in quotes during line parsing }
; { 3      | Set when CAPS LOCK is on }
; { 4      | Set when using channel K (keyboard) }
; { 5      | Unused }
; { 6      | Unused }
; { 7      | Unused }
; TABLE#
@label=FLAGS2
g$5C6A DEFB $00

; DF-SZ - The number of lines in the lower part of the screen
;
; Initialised by the routine at #R$11B7, read by the routines at #R$0A6D,
; #R$0C55, #R$0DD9, #R$1795, #R$17F9 and #R$2089, and updated by the routines
; at #R$0D6B and #R$12A2. This system variable is accessed by some routines via
; the #REGiy register at #iy+$31.
@label=DF_SZ
g$5C6B DEFB $02

; S-TOP - The number of the top program line in automatic listings
;
; Used by the routines at #R$1795 and #R$17F9.
@label=S_TOP
@keep
g$5C6C DEFW $0000

; OLDPPC - Line number to which CONTINUE jumps
;
; Read by the routine at #R$1E5F, and updated by the routine at #R$12A2.
@label=OLDPPC
@keep
g$5C6E DEFW $0000

; OSPCC - Number within line of statement to which CONTINUE jumps
;
; Read by the routine at #R$1E5F (via the #REGiy register at #iy+$36), and
; updated by the routine at #R$12A2.
@label=OSPCC
g$5C70 DEFB $00

; FLAGX - Various flags
;
; Read by the routines at #R$0F2C, #R$0FA9, #R$0FF3, #R$1059, #R$1076, #R$1190,
; #R$1855, #R$190F, #R$1925, #R$1DAB, #R$21B9 and #R$2AFF, and updated by the
; routines at #R$12A2, #R$1C22 and #R$2089. This system variable is accessed by
; most routines via the #REGiy register at #iy+$37.
; .
; #TABLE(default,centre)
; { =h Bit | =h Description }
; { 0      | Set when dealing with a complete simple string }
; { 1      | Set when dealing with a new (rather than existing) variable }
; { 2      | Unused }
; { 3      | Unused }
; { 4      | Unused }
; { 5      | Reset when in editing mode, set when in INPUT mode }
; { 6      | Unused }
; { 7      | Set when dealing with INPUT LINE }
; TABLE#
@label=FLAGX
g$5C71 DEFB $00

; STRLEN - Length of string type destination in assignment
;
; Read by the routines at #R$1D03 and #R$2AFF, and updated by the routine at
; #R$1C22. The first byte of this system variable (which holds the variable's
; name in some cases) is accessed by the routine at #R$1D03 via the #REGiy
; register at #iy+$38.
@label=STRLEN
@keep
g$5C72 DEFB $00,$00

; T-ADDR - Address of next item in parameter table
;
; Read by the routines at #R$07CB, #R$1C0D and #R$1C96, and updated by the
; routines at #R$0605 and #R$1B28.
@label=T_ADDR
@keep
g$5C74 DEFW $0000

; SEED - The seed for RND
;
; Used by the routine at #R$25F8, and updated by the routine at #R$1E4F.
@label=SEED
@keep
g$5C76 DEFW $0000

; FRAMES - Frame counter
;
; Read by the routine at #R$1E4F, and updated by the routine at #R$0038. The
; third byte of this system variable is accessed by the routine at #R$0038 via
; the #REGiy register at #iy+$40.
@label=FRAMES
g$5C78 DEFB $00,$00,$00

; UDG - Address of first user defined graphic
;
; Initialised by the routine at #R$11B7, and read by the routines at #R$0B24
; and #R$34BC.
@label=UDG
@keep
g$5C7B DEFW $FF58

; COORDS - Coordinates of last point plotted
;
; Read by the routines at #R$2382 and #R$24B7, and updated by the routines at
; #R$0DAF, #R$22DC and #R$2320.
@label=COORDS
g$5C7D DEFB $00      ; x-coordinate
 $5C7E DEFB $00      ; y-coordinate

; P-POSN - Column number of printer position
;
; Read by the routine at #R$0B03, and updated by the routine at #R$0ADC. This
; system variable is accessed via the #REGiy register at #iy+$45.
@label=P_POSN
g$5C7F DEFB $00

; PR-CC - Address of next position for LPRINT to print at
;
; Read by the routine at #R$0B03, and updated by the routines at #R$0ADC and
; #R$0EDF. The first byte of this system variable is accessed by the routine at
; #R$0EDF via the #REGiy register at #iy+$46.
@label=PR_CC
@keep
g$5C80 DEFW $0000

; ECHO-E - Column and line number of end of input buffer
;
; Read by the routine at #R$2089, and updated by the routines at #R$0ADC and
; #R$111D.
@label=ECHO_E
g$5C82 DEFB $00,$00

; DF-CC - Address in display file of PRINT position
;
; Read by the routine at #R$0B03, and updated by the routine at #R$0ADC.
@label=DF_CC
@keep
g$5C84 DEFW $0000

; DF-CCL - Like DF-CC for lower part of screen
;
; Read by the routine at #R$0B03, and updated by the routine at #R$0ADC.
@label=DF_CCL
@keep
g$5C86 DEFW $0000

; S-POSN - Column and line number for PRINT position
;
; Read by the routines at #R$0B03, #R$0C55, #R$12A2 and #R$17F9, and updated by
; the routines at #R$0ADC and #R$2089. The second byte of this system variable
; (the line number) is accessed by some routines via the #REGiy register at
; #iy+$4F.
@label=S_POSN
g$5C88 DEFB $00,$00

; S-POSNL - Like S-POSN for lower part of screen
;
; Read by the routines at #R$0B03 and #R$111D, and updated by the routine at
; #R$0ADC. The first byte of this system variable (the column number) is
; accessed by the routine at #R$111D via the #REGiy register at #iy+$50.
@label=S_POSNL
g$5C8A DEFB $00,$00

; SCR-CT - Scroll counter
;
; Used by the routines at #R$0605, #R$0C55, #R$0DAF, #R$12A2 and #R$2089. This
; system variable is accessed by some routines via the #REGiy register at
; #iy+$52. It is decremented by the routine at #R$0C55 whenever the PRINT
; position moves to the next line down; when it reaches zero, the 'scroll?'
; prompt is printed.
@label=SCR_CT
g$5C8C DEFB $00

; ATTR-P - Permanent current colours
;
; Initialised by the routine at #R$11B7, read by the routines at #R$0D4D,
; #R$0D6B and #R$0E44, and updated by the routine at #R$1C96. Holds the
; attribute byte that is used for the main part of the display when the screen
; is cleared.
@label=ATTR_P
g$5C8D DEFB $38      ; FLASH 0: BRIGHT 0: PAPER 7: INK 0

; MASK-P - Used for transparent colours
;
; Read by the routine at #R$0D4D, and updated by the routine at #R$1C96. It
; holds the attribute mask for the main part of the display, and is used only
; after first being copied to #SYSVAR(MASK-T).
@label=MASK_P
g$5C8E DEFB $00

; ATTR-T - Temporary current colours
;
; Initialised by the routine at #R$11B7, read by the routines at #R$0BDB,
; #R$1C96 and #R$21E1, and updated by the routines at #R$0C55, #R$0D4D and
; #R$18C1. Holds the attribute byte that is used for printing to the main part
; of the display, which will be the same as #SYSVAR(ATTR-P) unless temporary
; colours have been specified.
@label=ATTR_T
g$5C8F DEFB $38      ; FLASH 0: BRIGHT 0: PAPER 7: INK 0

; MASK-T - Temporary transparent colours
;
; Read by the routines at #R$0BDB and #R$1C96, and updated by the routines at
; #R$0C55, #R$0D4D, #R$18C1, #R$1CBE and #R$21E1. Holds the attribute mask that
; is used when printing to the main part of the display. Set bits in the mask
; preserve the corresponding bits in the original (on-screen) attribute; reset
; bits in the mask replace the corresponding bits in the original attribute
; with those in the target attribute (#SYSVAR(ATTR-T)).
@label=MASK_T
g$5C90 DEFB $00

; P-FLAG - More flags
;
; Read by the routines at #R$0B24, #R$0BDB and #R$22DC, and updated by the
; routines at #R$0A3D, #R$0C55, #R$0D4D, #R$18C1, #R$1C96, #R$1CBE and #R$21E1.
; This system variable is accessed by some routines via the #REGiy register at
; #iy+$57.
; .
; #TABLE(default,centre)
; { =h Bit | =h Description }
; { 0      | OVER bit (temporary) }
; { 1      | OVER bit (permanent) }
; { 2      | INVERSE bit (temporary) }
; { 3      | INVERSE bit (permanent) }
; { 4      | INK 9 if set (temporary) }
; { 5      | INK 9  if set (permanent) }
; { 6      | PAPER 9 if set (temporary) }
; { 7      | PAPER 9 if set (permanent) }
; TABLE#
@label=P_FLAG
g$5C91 DEFB $00

; MEMBOT - Calculator's memory area
;
; Used by the routines at #R$03F8, #R$0B24, #R$2320, #R$2D4F and #R$2DE3. The
; 11th, 24th, 26th and 27th bytes of this area are accessed by some routines
; via the #REGiy register at #iy+$62, #iy+$6F, #iy+$71 and #iy+$72.
@label=MEMBOT
g$5C92 DEFB $00,$00,$00,$00,$00 ; mem-0
 $5C97 DEFB $00,$00,$00,$00,$00 ; mem-1
 $5C9C DEFB $00,$00,$00,$00,$00 ; mem-2
 $5CA1 DEFB $00,$00,$00,$00,$00 ; mem-3
 $5CA6 DEFB $00,$00,$00,$00,$00 ; mem-4
 $5CAB DEFB $00,$00,$00,$00,$00 ; mem-5

; NMIADD - Non-maskable interrupt address
;
; Read by the routine at #R$0066.
@label=NMIADD
@keep
g$5CB0 DEFW $0000

; RAMTOP - Address of last byte of BASIC system area
;
; Initialised by the routine at #R$11B7, and used by the routine at #R$1EAC.
@label=RAMTOP
@keep
g$5CB2 DEFW $FF57

; P-RAMT - Address of last byte of physical RAM
;
; Initialised by the routine at #R$11B7, and read by the routine at #R$1EAC.
@label=P_RAMT
@keep
g$5CB4 DEFW $FFFF

; Channel information
;
; Initialised by the routine at #R$11B7 (from the #R$15AF(initial channel
; information) table), read by the routines at #R$1615, #R$1701 and #R$1736,
; and updated by the routine at #R$10A8. For each channel the output routine
; address comes before the input routine address and the channel's code.
@label=CHINFO
g$5CB6 DEFW $09F4    ; {Keyboard.
 $5CB8 DEFW $10A8    ;
 $5CBA DEFB "K"      ; }
 $5CBB DEFW $09F4    ; {Screen.
 $5CBD DEFW $15C4    ;
 $5CBF DEFB "S"      ; }
 $5CC0 DEFW $0F81    ; {Work space.
 $5CC2 DEFW $15C4    ;
 $5CC4 DEFB "R"      ; }
 $5CC5 DEFW $09F4    ; {Printer.
 $5CC7 DEFW $15C4    ;
 $5CC9 DEFB "P"      ; }
 $5CCA DEFB $80      ; End marker.
